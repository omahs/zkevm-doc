{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#about-polygon-zkevm","title":"About Polygon zkEVM","text":"<p>Polygon zkEVM is a powerful, decentralized technology developed to provide Layer 2 scalability solutions to Ethereum blockchain users. It is therefore designed to seamlessly integrate with the Ethereum ecosystem. Given the tremendous increase in the number of Ethereum's on-chain transactions, the Layer 1 solution is already facing the blockchain trilemma: decentralization, scalability, and security. This is where Polygon zkEVM steps in. By providing zero-knowledge-rollups (zk-rollups) that sit on top of the Ethereum Mainnet, the scalability and the transactions per second (TPS) can be dramatically improved. </p> <p>In order to prove that the off-chain computations are correct, Polygon zkEVM employs easily verifiable zero-knowledge proofs. The Layer 2 zero-knowledge proofs are based on the complex polynomial computations that provide fast finality to off-chain transactions.</p>"},{"location":"#what-is-polygon-zkevm","title":"What is Polygon zkEVM?","text":"<p>The predecessor, Polygon Hermez 1.0, was launched in March 2021. Its goal was to scale payments and transfers of ERC-20 tokens. It currently achieves up to 2000 transactions per second (tps), and thus accomplished the purpose it was designed for. See Ethereum Live TPS to keep track of Ethereum's live transactions per second.</p> <p>Polygon zkEVM, henceforth zkEVM, is a decentralized Ethereum Layer 2 scalability solution utilising cryptographic zero-knowledge technology in order to provide validation and fast finality of off-chain transaction computations. It has been designed and developed to emulate the Ethereum Virtual Machine (EVM) by recreating all existing EVM opcodes for transparent deployment of existing Ethereum smart contracts.</p> <p>The zkEVM carries out state changes, which come from executions of Ethereum\u2019s Layer 2 transactions that users send to the network, and subsequently produces validity proofs attesting to the correctness of the state change computations carried out off-chain.</p> <p>Although taking on this revolutionary design approach was a hard decision to make, the objective is to minimise the users and dApps friction when using the solution. It is an approach that requires recreation of all EVM opcodes for the transparent deployment of existing Ethereum smart contracts. For this purpose, a new set of technologies and tools has been created and engineered by the team.</p>"},{"location":"#continue-here-for-polygon-zkevm-documentation","title":"Continue here for Polygon zkEVM documentation","text":""},{"location":"#continue-here-for-hermez-10-documentation","title":"Continue here for Hermez 1.0 documentation","text":""},{"location":"Hermez_1.0/about/faq/","title":"FAQ","text":"<p>TODO</p>"},{"location":"Hermez_1.0/about/model/","title":"Hermez Network Model","text":""},{"location":"Hermez_1.0/about/model/#hermez-protocol","title":"Hermez Protocol","text":"<p>Hermez provides the decentralized components in the form of smart contracts and open source tools (SDK, Block Explorer, Wallet,...) to enable a new  ecosystem of actors to participate in the network. Hermez Network interacts with the rest of the ecosystem either via smart contracts or via a  standardized REST API exported by all operative coordinators.</p>"},{"location":"Hermez_1.0/about/model/#coordinators","title":"Coordinators","text":"<p>Coordinators are Hermez Network's version of block producers. This means they are the ones who effectively  run the network by computing the zero-knowledge proof of validity of the transactions made by the users.</p> <p>Coordinators use systems infrastructure to: * Synchronize with the Hermez Network  fetching data (historical and updates) from layer 1 * Receive transaction requests from users * Process transaction requests in order to build rollup batches * Save the  Merkle root together with a ZK-proof of correctness and the data necessary to reconstruct the full Merkle tree on Ethereum.</p> <p>The boot coordinator is a special seed coordinator which will be assigned to create batches of transactions by default, until\u00a0an alternative permissionless operator will place a bid in an attempt to obtain the right to run the network in a future slot of time.</p>"},{"location":"Hermez_1.0/about/model/#auction","title":"Auction","text":"<p>Multiple coordinators can coexist in the network running Hermez nodes. They will compete in a continuous decentralized auction process managed by smart contract for the right to  build rollup batches and collect the fees associated with each user transaction.  The right to forge is structured in time slots, which are defined to be 10 minutes long.</p> <p>The winning bid is the one with the highest amount of HEZ, an ERC-20 utility token whose value is not pre-determined  or pegged to a reference asset.</p> <p>All bids will be processed by the auction smart contract , and all of the HEZ tokens placed will be used as follows:</p> <ul> <li>30% will be burned (permanently removed).</li> <li>40% will be automatically and permanently transferred to a donations account controlled by the Ethereum Foundation. These donations will be initially sent to Gitcoin quadratic funding grants\u00a0but with the future-proof ability to donate also to other quadratic funding matching pools as they become available;</li> <li>30%\u00a0will be allocated as Hermez Network usage incentives, compensating active engagement and network adoption, e.g. rewarding transaction and rewarding the holding of specific tokens in Hermez L2 addresses, instead of on L1 Ethereum addresses.</li> </ul> <p>The auction process incentivises efficiency, as coordinators need to include as many transactions as possible in each time slot to compensate for their bidding costs and operative expenses.</p> <p>To prevent bidders from buying up all the slots in one go, nobody will be able to bid on a specific slot more than one month in advance. And the auction will be closed two time slots before the time of creating the slot.</p> <p>The auction will be structured in a series of six time slots to cover one hour (%0-5), with 10 HEZ as the initial minimal bidding price for all of them.</p> <p>The first bid in each time slot must be over the minimum bidding price in order to be accepted as valid. Thereafter, any bid placed in the auction should outbid the previous bid by at least 10%.</p> <p>The minimum bidding amount for each slot in an auction series will be\u00a0decided by the network governance (see section \"Hermez Governance\"), and it will be possible to change it dynamically, affecting future, even already open, auctions.</p> <p>Also, governance will be able to implement the effective decentralisation of the network by locking the price of specific slots of the auction to 0 HEZ and therefore wouldn't require any minimum bid, this being an irreversible configuration.</p>"},{"location":"Hermez_1.0/about/model/#users","title":"Users","text":"<p>Network users will be provided with easy-to-use interfaces to register their L1 Ethereum addresses as Hermez  L2 accounts. They will then be able to deposit and withdraw their funds, ETH or ERC-20 tokens, into or out of these L2 accounts.</p> <p>Initially, users will access the Hermez Network through an interface based on a non-custodial individually  owned wallet solution that relies on Metamask for the management of private keys.</p> <p>Through this interface, users will be able to:</p> <ul> <li>Register their Ethereum L1 address into the Hermez Network and obtain an internal address - one for each type of token they wish to deposit;</li> <li>Deposit L1 tokens into their Hermez Network addresses with a simple transaction;</li> <li>Transfer tokens between Hermez addresses much faster and for very low fees;</li> <li>Withdraw tokens from Hermez Network addresses back to their chosen\u00a0L1 addresses.</li> </ul> <p>Hermez provides protection mechanisms (enforced in the smart contract) that guarantee all tokens locked in  the L2 solution can always be recovered by the users, even in the unlikely event that the auction-winning coordinator is malicious \u2014 in other words, stealing, censoring or blocking transactions is impossible.</p> <p>The Hermez Network does not provide in any way custodial or exchange services. Hermez only and exclusively provides a L2 scaling solution for faster, low fee Ethereum tokens transfers.</p>"},{"location":"Hermez_1.0/about/model/#third-party-volume-aggregators","title":"Third-Party Volume Aggregators","text":"<p>Third-Party Exchanges and other volume aggregators will use an SDK to connect to the network to access L1 smart contracts and coordinator REST API endpoints and thus exploit Hermez's full potential. Hermez will provide an interesting feature of atomic transactions, which implements a link between transactions that need to be executed together, and it's very useful for token swaps.</p>"},{"location":"Hermez_1.0/about/scalability/","title":"Ethereum Scalability and ZK-Rollups","text":""},{"location":"Hermez_1.0/about/scalability/#background","title":"Background","text":"<p>During the last year, it has become clear that rollups will be the dominant scaling paradigm on the Ethereum public blockchain: with this in mind, Iden3 has developed and recently launched Hermez, a ZK-Rollup focused on scaling payments and token transfers on Ethereum.</p> <p>Why the focus on transfers? It turns out that more than 50% of transactions on the Ethereum network are transfers, and a large percent of these are deposits and withdrawals from exchanges. Demand could be reduced by a significant amount if exchanges started using rollups, or (in the ideal case) even agreed to meet on the same rollup.</p> <p>In addition to significantly reducing transaction costs for users, this could have the added benefit of greatly reducing gas prices, and freeing up the base chain for more complex contracts.</p>"},{"location":"Hermez_1.0/about/scalability/#zero-knowledge-rollups","title":"Zero-Knowledge Rollups","text":"<p>A ZK-Rollup, such as Hermez, is a layer 2 construction which uses the Ethereum blockchain for data storage instead of computation: - All funds are held by a smart contract on the main-chain.</p> <ul> <li> <p>For every batch of transactions, a ZK-SNARK cryptographic proof is generated off-chain.</p> </li> <li> <p>This ZK-SNARK proves the validity of every transaction in the batch which means it is not necessary to rely on the Ethereum main-chain to verify each signature transaction.</p> </li> </ul> <p>The significance of this is that it allows verification to be carried out in constant time regardless of the number of transactions. This ability to verify proofs both efficiently and in constant time is at the heart of all ZK-Rollups.</p> <p>In addition to this, all transaction data is published cheaply on-chain, without signatures \u2014 under call data. Since the data is published on-chain, there are no data availability problems that have plagued other L2 solutions such as Plasma.</p> <p>Anyone can reconstruct the current state and history from this on-chain data. This prevents censorship and avoids the centralization of coordinators (rollup batch producers) \u2014 since anyone can build the state tree from scratch (and therefore become a coordinator).</p>"},{"location":"Hermez_1.0/about/scalability/#why-the-need-for-zk-rollups","title":"Why the Need for ZK-Rollups?","text":"<p>Trust-minimised blockchain scaling mechanisms are sorely needed if blockchain applications are ever to achieve mass adoption.</p> <p>For context, the Ethereum network can handle approximately 15 transactions per second (tps), while the Visa network averages around 2,000 tps. This limitation in throughput directly affects the price paid for each transaction and constraints its adoption.</p> <p>As outlined in an earlier Iden3 post, ZK-Rollups have the potential to increase the Ethereum network\u2019s maximum tps by two orders of magnitude, making it comparable to the Visa network\u2019s average.</p>"},{"location":"Hermez_1.0/about/scalability/#how-is-2000-tps-possible","title":"How is 2000 tps Possible?","text":"<p>Blockchain scalability is improved by compressing each transaction to ~10 bytes: instead of including signatures on-chain, we send a ZK-SNARK which proves that 1000\u2019s of signature verifications and other transaction validation checks have been correctly carried out off-chain.</p> <p>Since signatures make up a large percentage of transaction costs (gas), in practice ZK-Rollups have the effect of significantly reducing the average cost per transaction. This allows Hermez to fit more transactions per batch, which results in a greater overall throughput.</p> <p></p> <p>Bytes breakdown: vanilla Eth transaction (109+ bytes) vs ZK-Rollup transaction (8 bytes)</p>"},{"location":"Hermez_1.0/about/security/","title":"Security","text":"<p>Hermez relies on certain assumptions that guarantee users can always recover their assets deposited on the network. These assumptions are based on several design and architectural decisions that we will review here.</p> <p>Hermez is a Layer2 solution running on top of Ethereum 1.0. This means that the security of Hermez depends  on the security assumptions and guarantees provided by Ethereum.  In addition, Hermez is a ZK-Rollup protocol:  on top of Ethereum blockchain, Hermez adds another layer of security borrowed from Zcash. Following their work, Hermez integrates a ZK-SNARK prover/verifier module to validate in constant time the execution of a series of transactions.</p> <p>These ZK-SNARKs make use of certain cryptographic primitives such as hashes and signatures that make further security assumptions as it will be reviewed later.  Finally, Hermez embeds operating rules in different smart contracts to guarantee that user's transactions cannot be blocked by operators and can withdraw their assets at all times.</p> <p>As a summary, Hermez makes the following security assumptions: 1. Security assumptions of Ethereum. 2. Groth16 assumptions (knowledge of exponent assumption). 3. Certain cryptographic assumptions from  primitives such as signatures and hashes 4. Software security assumptions that rely on correct design and implementation.</p>"},{"location":"Hermez_1.0/about/security/#ethereum","title":"Ethereum","text":"<p>Hermez runs on top of Ethereum. All Hermez data is available on Ethereum and borrows layer 1 security too.</p>"},{"location":"Hermez_1.0/about/security/#zk-proofs","title":"ZK-Proofs","text":"<p>User transactions are always verified by an Ethereum smart contract by verifying the ZK-Proof supplied by the coordinator. The specific ZK-SNARK that is used in these ZK-Proofs is <code>Groth16</code>. This protocol has been widely used and tested by the Zcash team of researchers and it is currently considered mature enough to be used in production.</p> <p>At this time, Ethereum precompiled smart contracts only support BN254 elliptic curve operations for zk-SNARK proofs validation. For this reason, Hermez uses this curve for generating and validating proofs and Baby Jubjub <code>here</code> and <code>here</code> for implementing elliptic curve cryptography inside circuits.</p> <p>In place of BN254, which offers 100 bits of security, Zcash uses <code>BLS12-381</code>, with 128 bits of security <code>see here</code>. Hermez will likely migrate to [<code>BLS12-381</code>] curve as soon as it is available for Ethereum.</p> <p>Among other benefits, BLS12-381 provides <code>128 bits</code> of security instead of the 100 bits provided by BN256.  The <code>EIP</code> that implements BLS12-381 curve was already approved and the migration is very likely to happen by the next planned Berlin Hard Fork. This change will improve the security level. At this point Baby Jubjub will be substituted by <code>Jubjub curve</code>.</p> <p>Baby Jubjub curve satisfies security standards as shown <code>here</code> and <code>here</code>.</p>"},{"location":"Hermez_1.0/about/security/#multi-party-computation-for-the-trusted-setup","title":"Multi-party Computation for the Trusted Setup","text":"<p>The proving and verification keys of the ZK-SNARK protocol require the generation of some random values that need to be eliminated. This elimination process is a crucial step: if these values are ever exposed, the security of the whole scheme is compromised. To construct the setting, Hermez uses a <code>Multi-party computation (MPC)</code>  ceremony that allows multiple independent parties to collaboratively construct the parameters or trusted setup. With MPC, it is enough that one single participant deletes its secret counterpart of the contribution in order to keep the whole scheme secure.</p> <p>The construction of the trusted setup has two phases: 1. General MPC ceremony that is valid for any circuit (also known as Powers of Tau ceremony) 2. Phase 2 that is constructed for each specific circuit.</p> <p>Anyone can contribute with their randomness to the MPC ceremonies and typically, before getting the final parameters, a random beacon is applied.</p> <p>To contribute to the robustness of the setup, Hermez implemented an independent  <code>snarkjs</code> module for computing and validating the MPC ceremonies.  The software is compatible with current <code>Powers of Tau</code>, and it allows one to see the list of contributions of a given setup, to import a response, export a challenge of the ceremony, or to verify if the whole process has been correctly computed. Hermez\u2019 contribution can be  found <code>here</code>).</p>"},{"location":"Hermez_1.0/about/security/#cryptography","title":"Cryptography","text":"<p>Hermez makes use of two main cryptographic primitives inside circuits: a signature and a hash function. 1. The signature schema is the <code>Edwards Digital Signature Algorithm (EdDSA)</code>  on Baby Jubjub (after the migration, it will use EdDSA on Jubjub). This protocol was implemented making use of  the circuit language <code>circom</code> and following the circuit design of Zcash. 2. The hash function used is <code>Poseidon</code>, a similar hash to <code>MiMC</code> but with a mixing layer. These hash functions  have been used in projects such as <code>TornadoCash</code> (MiMC) and <code>Semaphore</code> (Poseidon)</p> <p>Assumptions made on Poseidon hash function include that it is collision and preimage resistant.</p>"},{"location":"Hermez_1.0/about/security/#design","title":"Design","text":"<p>Hermez attempts to decentralize the role of coordinators while simultaneously enforcing some rules or guidelines on the coordinators to ensure user transactions cannot be blocked. Some of these features are:</p> <ol> <li>Coordinators are required to process L1 user transactions periodically as established in the smart contract. Since L1 transactions are concatenated together, a coordinator must process all pending L1 transactions, thus preventing  it from blocking specific users or L1 operations. Note that withdrawal of funds is a L1 transaction so it cannot be blocked by a coordinator.</li> <li>If a coordinator doesn't process (or forge) transactions during its allotted time, any online coordinator can forge  transactions. This mechanism is known as Coordinator override.</li> <li>HermezDAO foundation controls a last resort coordinator called Boot coordinator. If there are no coordinators available to forge any batches, the boot coordinator will forge transactions. The HermezDAO foundation is a non-profit organization created for the maintenance and operation of the Hermez Network, registered under BVI 2043757 in Wickhams Cay II, Road Town, Tortola, VG1110, British Virgin Islands.</li> <li>Bidding process format allows the governance to set different minimum bidding prices to different sots to  increase the chances that transactions are forged by Boot coordinator.</li> </ol>"},{"location":"Hermez_1.0/about/security/#security-audits","title":"Security Audits","text":"<p>Smart contracts and circuits designed for ZK-proof system are being audited by different entities. The results will be published here as soon as they are available.</p> <p>Results from the first audit performed by <code>Solidified</code> can be found <code>here</code></p> <p>Results from the second audit performed by <code>Trail of Bits</code> can be found <code>here</code></p>"},{"location":"Hermez_1.0/about/value-proposition/","title":"Hermez Value Proposition","text":"<p>Hermez network project has some properties that will provide value to the users and the community:</p>"},{"location":"Hermez_1.0/about/value-proposition/#production-ready-solution","title":"Production Ready Solution","text":"<p>Hermez will launch in mainnet a project which is intended to be a usable token transfers network from day one. This product will have support, maintenance, and technological evolution to provide users with the most updated functionalities with the right risk management.</p> <p>The first release starts with the specific scope of token transfers implemented with a technological stack and cryptography setup considered the most tested so far.</p>"},{"location":"Hermez_1.0/about/value-proposition/#decentralized","title":"Decentralized","text":"<p>Hermez is called a network because the model is natively decentralized. It is a layer 2 construction and intends to transact at thousands per second, so the consensus algorithm has to be simple for one agent (coordinator) to process this amount of transactions at any given time. With this model, it still keeps the properties of being permissionless to participate and censorship resistant for user transactions.</p>"},{"location":"Hermez_1.0/about/value-proposition/#efficient","title":"Efficient","text":"<p>The decentralized model is implemented through a permissionless auction system for potential coordinators of the network to earn the right to process transactions during a slot of time.</p> <p>This auction model incentivises the efficiency of coordinators since they need to process as many transactions as they can to collect the fees and compensate their investment and their operation expenses (and make money out of it).</p> <p>Hermez implements a ZK-Rollup based on ZK-SNARK proofs, the most efficient in terms of batch cost in Ethereum.</p> <p>Since the batches of transactions are a maximum of 2,000 in size, users will benefit from the scale and the underlying technology for nominal maximum savings up to 97% compared to the Ethereum cost for a single token transfer.</p>"},{"location":"Hermez_1.0/about/value-proposition/#security-in-mind","title":"Security in Mind","text":"<p>Scalability can be achieved in different ways. Hermez is a layer 2 construction because it leverages Ethereum not only by using its native tokens but by also borrowing Ethereum's security as a strong public blockchain.</p> <p>The implementation of Hermez is based on iden3's own technology (Circom and SnarkJS libraries) and the cryptographic technology which has been proven as the most robust so far, as used in the ZCash blockchain.</p> <p>As a new network with a bootstrap period, Hermez has transitory security measures to protect the system with the objective to remove them and leave it fully decentralized.</p>"},{"location":"Hermez_1.0/about/value-proposition/#part-of-the-community","title":"Part of the Community","text":"<p>Hermez is designed to contribute to the community, since the project wouldn\u2019t be possible without it. Innovations in scalability are a rare opportunity to realign incentives around the community and the public goods they provide.</p> <p>40% of the generated value in the network will be sent to a donation process where the ecosystem projects will benefit from the donations. It will start with Gitcoin but other pools might be enabled in the future.</p> <p>Hermez will open source all the protocol and coordinator code, is open to contributions, and has committed to contribute to the creation of a L2 ecosystem for initiatives such as a better L2 interoperability .</p>"},{"location":"Hermez_1.0/about/value-proposition/#focused-on-usability","title":"Focused on Usability","text":"<p>ZK-Rollups provide the technology for instant finality of transactions, which Hermez understands is a key feature for usability.</p> <p>Hermez Protocol also provides a guarantee that user transactions can not be censored and that all funds can always be sent back to layer 1. Layer 2 solutions increase complexity for the users, but the Hermez project focus is to provide the best possible usability for user onboarding, transactions and reduce friction and confusion between layers.</p>"},{"location":"Hermez_1.0/about/value-proposition/#with-a-vision","title":"With a Vision","text":"<p>Hermez project derives from the iden3 initiative, where a highly qualified team work to implement the vision of a universal and private by default self-sovereign identity. Scalability was required for the identity protocol to be universal and individuals could issue claims on other identities for (almost) free.</p> <p>Symbiotically, Hermez Network is expected to benefit from the advancements in identity infrastructure such as validation, private credentials and reputation for improved usability and extend the range of potential use cases of a high throughput transaction network.</p> <p>Hermez will guide its efforts in becoming an infrastructure which can serve the maximum number of users.</p>"},{"location":"Hermez_1.0/developers/api/","title":"REST API","text":"<p>The API is the layer that allows 3rd party apps and services to interface with the coordinator to explore, monitor and use the Hermez rollup. Example of these apps include: * Wallet: send L2 transactions, check balance, ... * Explorer: List transactions, slots, batches, ... * Exchange integrations</p> <p>The documentation of the API can be found here</p> <p>Hermez Testnet API can be found here</p> <p>Hermez Mainnet API can be found here</p>"},{"location":"Hermez_1.0/developers/batch-explorer/","title":"Batch Explorer","text":""},{"location":"Hermez_1.0/developers/batch-explorer/#what-is-hermez-block-explorer","title":"What is Hermez Block Explorer","text":"<p>Hermez Block Explorer, as the name suggests is a block explorer for the Hermez Network. It is a tool that allows anyone to search and lookup details about transactions, batches, coordinators, accounts or slots. It also provides basic information on the network performance.</p>"},{"location":"Hermez_1.0/developers/batch-explorer/#batches","title":"Batches","text":"<p>By searching for a particular batch number, or simply navigating to one, user is able to see the details of a given batch. Among other information the page displays: * block hash * status of a batch * timestamp * collected fees * link to the coordinator in question * link to the given slot, and * a full list of transactions included in that batch</p> <p></p>"},{"location":"Hermez_1.0/developers/batch-explorer/#transactions","title":"Transactions","text":"<p>By searching for a transaction id, or simply clicking on one of the transaction links users land on a page showing all important details of that transaction. Such as: * status of a batch * timestamp * transaction type     * for an L1 transaction:         * Exit         * Transfer         * Deposit         * CreateAccountDeposit         * CreateAccountDepositTransfer         * DepositTransfer         * ForceTransfer         * ForceExit         * TransferToEthAddr         * TransferToBJJ     * for an L2 transaction:         * Exit         * Transfer         * TransferToEthAddr         * TransferToBJJ * id of a batch that transaction is part of</p> <p></p>"},{"location":"Hermez_1.0/developers/batch-explorer/#user-address","title":"User address","text":"<p>User address page is displaying basic information about the given Hermez Ethereum or BJJ address. That information includes the addresses themselves as well as a total number of token accounts. Apart from that, basic information for each token as well as each related transaction is listed in two separate views.</p> <p></p>"},{"location":"Hermez_1.0/developers/batch-explorer/#slots","title":"Slots","text":"<p>By navigating through a corresponding link, users land on the slot details page. Here are shown all relevant information for a slot, as: * slot status (whether the auction of the slot is open or not) * total number of bids * bids details (including coordinator and the bid amount)</p> <p>If a given slot auction is closed, the following information will be shown as well: * list of batches included in that slot (with some details about each batch)</p>"},{"location":"Hermez_1.0/developers/batch-explorer/#coordinator","title":"Coordinator","text":"<p>By searching for the Ethereum address of an existing coordinator, or by navigating through the app the user lands on the page listing details of that coordinator. Those details include: * forger and withdrawal addresses * full list of forged batches * full list of winner bids (including slot, total bids and bid amount)</p> <p></p>"},{"location":"Hermez_1.0/developers/batch-explorer/#searching-through-hermez-batch-explorer","title":"Searching through Hermez Batch Explorer","text":"<p>There are limited options available for search and navigation in the app itself. Those include: * Ethereum address * HEZ Ethereum address * BJJ address * Batch number * Id of a Transaction * Account index</p>"},{"location":"Hermez_1.0/developers/coordinator/","title":"Hermez Node","text":"<p>This tutorial describes how to launch a Hermez node. It starts by explaining how to launch a Boot Coordinator in localhost. Next, it describes how to initialize a Proof Server and how to connect it to the Boot Coordinator. The next section describes how to spin up a second Hermez node in synchronizer mode to track the rollup status independently from the Boot Coordinator. This second node will be launched in Rinkeby testnet. The last part of the tutorial includes an explanation on how to add a second Coordinator node to Hermez testnet Rinkeby that bids for the right to forge batches.</p> <ol> <li>Preparing the Environment </li> <li>Launching the Boot Coordinator</li> <li>Launching a Proof Server</li> <li>Launching a Price Updater</li> <li>Launching a Synchronizer Node</li> <li>Launching a Second Coordinator</li> </ol>"},{"location":"Hermez_1.0/developers/coordinator/#preparing-the-environment","title":"Preparing the Environment","text":"<p>Hermez node requires a PostgreSQL database and connectivity to an Ethereum node. In this part, we describe how you can set this environment up using docker containers.</p>"},{"location":"Hermez_1.0/developers/coordinator/#dependencies","title":"Dependencies","text":"<ul> <li>golang 1.16+ </li> <li>golangci-lint</li> <li>packr utility to bundle the database migrations. Make sure your <code>$PATH</code> contains <code>$GOPATH/bin</code>, otherwise the packr utility will not be found.</li> </ul> <pre><code>cd /tmp &amp;&amp; go get -u github.com/gobuffalo/packr/v2/packr2 &amp;&amp; cd -\n</code></pre> <ul> <li>docker and docker-compose without sudo permission (optional if you want to use the provided PostgreSQL and Geth containers)</li> <li>docker</li> <li>docker-compose</li> <li>aws cli 2 (optional if you want to use the provided Geth container)</li> </ul>"},{"location":"Hermez_1.0/developers/coordinator/#setup","title":"Setup","text":"<ol> <li>Clone hermez-node repository</li> </ol> <pre><code>git clone https://github.com/hermeznetwork/hermez-node.git\n</code></pre> <ol> <li>Build <code>hermez-node</code> executable</li> </ol> <pre><code>cd hermez-node\nmake \n</code></pre> <p>The executable can be found in <code>dist/heznode</code></p> <ol> <li>Deploy PostgreSQL database and Geth node containers. For this step we provide a docker-compose file example. Copy file to <code>docker-compose.sandbox.yaml</code>.</li> </ol> <p>Login to AWS public ECR to be able to download the Geth docker image:</p> <pre><code>export AWS_REGION=eu-west-3\naws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/r7d5k1t8\n</code></pre> <p>Ensure that port 5432 is not being used. Otherwise, PostgreSQL docker will fail.</p> <p>To start start database and Geth node containers:</p> <pre><code>DEV_PERIOD=3 docker-compose -f docker-compose.sandbox.yaml up -d\n</code></pre> <p>This command will start a Geth node mining a block every 3 seconds.  Database is available at port 5432. Geth node is available at port 8545.</p> <p>To stop containers:</p> <pre><code>docker-compose -f docker-compose.sandbox.yaml down\n</code></pre> <p>The Geth container comes with pre-deployed Hermez contracts and with 200 funded accounts. The relevant information about the contract deployment can be found below</p> <pre><code> \"hermezAuctionProtocolAddress\": \"0x317113D2593e3efF1FfAE0ba2fF7A61861Df7ae5\"\n \"hermezAddress\": \"0x10465b16615ae36F350268eb951d7B0187141D3B\"\n \"withdrawalDelayeAddress\": \"0x8EEaea23686c319133a7cC110b840d1591d9AeE0\"\n \"HEZTokenAddress\": \"0x5E0816F0f8bC560cB2B9e9C87187BeCac8c2021F\"\n \"hermezGovernanceIndex\": 1\n \"hermezGovernanceAddress\": \"0x8401Eb5ff34cc943f096A32EF3d5113FEbE8D4Eb\"\n \"emergencyCouncilIndex\": 2\n \"emergencyCouncilAddress\": \"0x306469457266CBBe7c0505e8Aad358622235e768\"\n \"donationIndex\": 3\n \"donationAddress\": \"0xd873F6DC68e3057e4B7da74c6b304d0eF0B484C7\"\n \"bootCoordinatorIndex\": 4\n \"mnemonic\": \"explain tackle mirror kit van hammer degree position ginger unfair soup bonus\"\n \"chainId\" : 1337\n}\n</code></pre> <ol> <li>Customize Hermez Node configuration file. For this example, we can use this configuration file. Just copy this file to <code>cmd/heznode/cfg.sandbox.boot.coordinator.toml</code></li> </ol> <p>For more information on the parameters in the configuration file, read the configuration parameters description.</p> <ol> <li>Ensure correct permissions are granted to /var/hermez folder</li> </ol> <pre><code>sudo mkdir -p /var/hermez\nsudo chown $USER:$USER /var/hermez\n</code></pre>"},{"location":"Hermez_1.0/developers/coordinator/#launching-the-boot-coordinator","title":"Launching the Boot Coordinator","text":"<p>It is recommended to run the Coordinator node in a server with 8+ cores, 16 GB+ of RAM and 250GB of disk (AWS c5a.2xlarge or equivalent).</p> <ol> <li>Import the Coordinator and Fee Ethereum accounts private keys into the keystore. </li> </ol> <pre><code>./dist/heznode importkey --mode coord --cfg ./cmd/heznode/cfg.sandbox.boot-coordinator.toml --privatekey 0x705df2ae707e25fa37ca84461ac6eb83eb4921b653e98fdc594b60bea1bb4e52\n./dist/heznode importkey --mode coord --cfg ./cmd/heznode/cfg.sandbox.boot-coordinator.toml --privatekey 0xfdb75ceb9f3e0a6c1721e98b94ae451ecbcb9e8c09f9fc059938cb5ab8cc8a7c\n</code></pre> <p>The Coordinator account is used to pay the gas required to forge batches. The  Fee account is used to collect the fees paid by users submitting transactions to Hermez Network. You only need to import these keys once.</p> <ol> <li>Start a mock proof server. </li> </ol> <pre><code>cd test/proofserver/cmd\ngo build -o proof-server\n./proof-server -d 15s -a 0.0.0.0:3000\n</code></pre> <p>The <code>hermez-node</code> repository provides a mock proof server that generates proofs every 15 seconds. The mock prover is launched at http://localhost:3000, and it exports two endpoints: - GET /api/status: Queries the prover's status. - POST /api/input: Starts the generation of a new proof.</p> <ol> <li>Wipe SQL database</li> </ol> <p>Before starting the Coordinator node, you may want to wipe the pre-existing SQL database. This command will wipe the pre-existing database if it exists, and it will force the Coordinator to resynchronize the full state.</p> <pre><code>./dist/heznode wipedbs --mode coord --cfg cmd/heznode/cfg.sandbox.boot-coordinator.toml \n</code></pre> <ol> <li>Launch the Hermez Node</li> </ol> <pre><code>./dist/heznode run --mode coord --cfg cmd/heznode/cfg.sandbox.boot-coordinator.toml\n</code></pre> <p>Once the Hermez Node is launched, the API can be queried at <code>localhost:8086/v1</code>. You can find more information on the API here</p>"},{"location":"Hermez_1.0/developers/coordinator/#launching-a-proof-server","title":"Launching a Proof Server","text":"<p>We will use rapidsnark as the Hermez proof server. <code>rapidsnarks</code> is a zkSnark proof generator written in C++. It is recommended to run the proof server in servers with 48+ cores, 96 GB+ of RAM and 250GB of disk (AWS c5a.12xlarge or equivalent).</p> <p>rapidsnark requires a host CPU that supports ADX extensions. You can check this with <code>cat /proc/cpuinfo | grep adx</code></p>"},{"location":"Hermez_1.0/developers/coordinator/#dependencies_1","title":"Dependencies","text":"<ul> <li>node v16+</li> <li>npm</li> </ul> <pre><code>apt install npm\n</code></pre> <ul> <li>npx</li> </ul> <pre><code>npm i -g npx\n</code></pre> <ul> <li>Install gcc, libsodium, gmp, cmake</li> </ul> <pre><code>sudo apt install build-essential\nsudo apt-get install libgmp-dev libsodium-dev nasm cmake\n</code></pre>"},{"location":"Hermez_1.0/developers/coordinator/#circuit-files","title":"Circuit Files","text":"<p>Download circuit and auxiliary files. These files are extremely large (20GB+), so make sure you have enough bandwidth and disk space.</p> <p>There are two Hermez circuits that have undergone the Trusted Setup Ceremony.  - circuit-2048-32-256-64 with 2048 transactions per batch (~2^27 constraints) - circuit-400-32-256-64 with 400 transactions per batch (~2^25 constraints)</p> <p>For each type of circuit, you will need the following files: - C++ source file (extension .cpp) - Data file (extension .dat) - Verification and Proving Key files (extension .zkey)</p> <p>circuit-400-32-256-64.cpp</p> <p>circuit-400-32-256-64.dat</p> <p>circuit-400-32-256-64_hez4_final.zkey</p> <p>circuit-2048-32-256-64.cpp</p> <p>circuit-2048-32-256-64.dat</p> <p>circuit-2048-32-256-64_hez4_final.zkey</p> <p>More information on Trusted Setup can be found here.</p>"},{"location":"Hermez_1.0/developers/coordinator/#setup_1","title":"Setup","text":"<ol> <li>Clone rapidsnark repository</li> </ol> <pre><code>git clone  https://github.com/iden3/rapidsnark.git\n</code></pre> <ol> <li>Compile the prover.</li> </ol> <p>In this example we are building the 400 transactions prover.</p> <pre><code>cd rapidsnark\nnpm install\ngit submodule init\ngit submodule update\nnpx task createFieldSources\nnpx task buildPistche\nnpx task buildProverServer ../circuit-400-32-256-64.cpp\n</code></pre> <ol> <li>Launch prover</li> </ol> <pre><code>cd ..\n./rapidsnark/build/proverServer circuit-400-32-256-64.dat circuit-400-32-256-64_hez4_final.zkey\n</code></pre> <p>Prover is deployed at port 9080.</p> <ol> <li>Check prover status</li> </ol> <pre><code>curl -i -H \"Accept: application/json\" -H \"Content-Type: application/json\" -X GET http://localhost:9080/status\n</code></pre>"},{"location":"Hermez_1.0/developers/coordinator/#generate-a-prover-input-file","title":"Generate a Prover Input File","text":"<ol> <li>Clone circuits repository</li> </ol> <pre><code>git clone https://github.com/hermeznetwork/circuits.git\n</code></pre> <ol> <li>Install dependencies</li> </ol> <pre><code>cd circuits\nnpm install\ncd tools\n</code></pre> <p>In this example we are working with <code>circuit-400-32-236-64_hez1.zkey</code>, which corresponds to a circuit with 400 transactions, 32 levels, 256 maxL1Tx and 64 maxFeeTx.</p> <ol> <li>Generate Input file</li> </ol> <p>To generate a new input file with empty transactions:</p> <pre><code>node build-circuit.js input 400 32 256 64\n</code></pre> <p>This command generates a new input file <code>rollup-400-32-256-64/input-400-32-256-64.json</code></p> <p>To generate a new input file with random transactions</p> <pre><code>node generate-input.js 256 144 400 32 256 64\n</code></pre> <p>This will create a new input file called <code>inputs-256.json</code> </p>"},{"location":"Hermez_1.0/developers/coordinator/#generate-a-new-proof","title":"Generate a New Proof","text":"<p>You can use curl to post any of the inputs generated in the previous step.</p> <pre><code>curl -X POST -d @inputs-256.json http://localhost:9080/input\n</code></pre> <p>or</p> <pre><code>curl -X POST -d @input-400-32-256-64.json http://localhost:9080/input\n</code></pre> <p>You check the status of the prover by querying the <code>/status</code> endpoint.</p> <pre><code>curl -i -H \"Accept: application/json\" -H \"Content-Type: application/json\" -X GET http://localhost:9080/status\n</code></pre> <p><code>/status</code> returns if the prover is ready to accept a new input as well as the proof result and input data of the previous iteration. An example is shown below.</p> <pre><code>{\"proof\":\"{\\\"pi_a\\\":[\\\"15669797899330531899539165505099185328127025552675136844487912123159422688332\\\",\\\"4169184787514663864223014515796569609423571145125431603092380267213494033234\\\",\\\"1\\\"],\\\"pi_b\\\":[[\\\"15897268173694161686615535760524608158592057931378775361036549860571955196024\\\",\\\"7259544064908843863227076126721939493856845778102643664527079112408898332246\\\"],[\\\"11114029940357001415257752309672127606595008143716611566922301064883221118673\\\",\\\"11641375208941828855753998380661873329613421331584366604363069099895897057080\\\"],[\\\"1\\\",\\\"0\\\"]],\\\"pi_c\\\":[\\\"3069279014559805068186938831761517403137936718184152637949316506268770388068\\\",\\\"17615095679439987436388060423042830905459966122501664486007177405315943656120\\\",\\\"1\\\"],\\\"protocol\\\":\\\"groth16\\\"}\",\"pubData\":\"[\\\"18704199975058268984020790304481139232906477725400223723702831520660895945049\\\"]\",\"status\":\"success\"}\n</code></pre>"},{"location":"Hermez_1.0/developers/coordinator/#connect-prover-to-coordinator-node","title":"Connect Prover to Coordinator Node","text":"<p>Once you have verified the prover is working, you can connect it to the Hermez Coordinator by configuring the <code>cfg.sandbox.boot-coordinator.toml</code> configuration file. You need to substitute sections <code>ServerProofs</code> with the updated URLs where prover is deployed, and the <code>Circuit</code> section where the verifier smart contract is specified.</p> <pre><code>[Coordinator.ServerProofs]\n#TODO: Add Prover URL\n#URLs = [\"http://localhost:9080\"]\n</code></pre> <pre><code>[Coordinator.Circuit]\nMaxTx = 400\nNLevels = 32\n</code></pre> <p>At this point, you can stop the mock server if it is still running, and re-launch the coordinator as we saw in the previous section. The new prover will be running at http://localhost:9080 (or at the configured URL), and the two endpoints are <code>/status</code> and <code>/input</code></p>"},{"location":"Hermez_1.0/developers/coordinator/#launching-a-price-updater","title":"Launching a Price Updater","text":"<p>Price Updater service is used to consult and updater the tokens and fiat currency used by Hermez Node. Once Hermez Node has been deployed, the Price Updater service can be deployed. Follow these instructions to set up the Price Updater service.</p>"},{"location":"Hermez_1.0/developers/coordinator/#launching-a-synchronizer-node","title":"Launching a Synchronizer Node","text":"<p>In synchronizer mode, the node is capable of keeping track of the rollup and consensus smart contracts, storing all the history of events, and keeping the rollup state updated, handling reorgs when they happen. This mode is intended for entities that want to gather all the rollup data by themselves and not rely on third party APIs. For this part of the tutorial, we are going to deploy the syncrhonizer node in testnet on Rinkeby.</p> <ol> <li>Stop Coordinator node launched in localhost in previous steps.</li> </ol> <p>Stop prover, coordinator node and containers from previous phases as you will be working in testnet with a real Boot Coordinator node.</p> <pre><code>docker-compose -f docker-compose.sandbox.yaml down\n</code></pre> <ol> <li>Launch PostgreSQL database.</li> </ol> <p>The Hermez node in synchronizer mode needs to run on a separate database</p> <pre><code>docker run --rm --name hermez-db -p 5432:5432 -e POSTGRES_DB=hermez -e POSTGRES_USER=hermez -e POSTGRES_PASSWORD=\"yourpasswordhere\" -d postgres\n</code></pre> <ol> <li>Start an Ethereum node in Rinkeby</li> </ol> <p>You will need to run your own Ethreum node on Rinkeby. We recommend using Geth. - Pre-built binaries for all platforms on our downloads page (https://geth.ethereum.org/downloads/). - Ubuntu packages in our Launchpad PPA repository (https://launchpad.net/~ethereum/+archive/ubuntu/ethereum). - OSX packages in our Homebrew Tap repository (https://github.com/ethereum/homebrew-ethereum).</p> <p>Sync this node with Rinkeby testnet where all of Hermez's smart contracts are deployed. </p> <ol> <li>Get contract addresses</li> </ol> <p>Query Testnet API for the addresses of the Hermez smart contracts. You can use a web browser or the command below.</p> <pre><code>curl -i -H \"Accept: application/json\" -H \"Content-Type: application/json\" -X GET api.testnet.hermez.io/v1/config\n</code></pre> <p>At this moment, Hermez Network is deployed in this address:</p> <pre><code>\"Rollup\":\"0x679b11e0229959c1d3d27c9d20529e4c5df7997c\"\n</code></pre> <ol> <li>Copy configuration file to <code>hermez-node/cmd/heznode/cfg.testnet.sync.toml</code>. You will need to edit the following sections:</li> <li>PostgreSQL Values provided are valid for docker postgreSQL container. You will need to supply the actual values for your database.  </li> <li>Web3 URL of your Rinkeby Ethereum node</li> <li> <p>SmartContracts Double check that the address provided in the configuration file corresponds to the current Hermez Network contract deployed in Rinkeby</p> </li> <li> <p>Launch <code>hermez-node</code> in synchronizer mode</p> </li> </ol> <pre><code>./dist/heznode run --mode sync --cfg cmd/heznode/cfg.testnet.sync.toml\n</code></pre> <ol> <li>Kill and relaunch Price Updater service in testnet Follow instructions to set up the Price Updater service.</li> </ol> <p>Once the Hermez node is launched, the API can be queried at the location specified in the configuration file in <code>API.Address</code> section, as well as at https://api.testnet.hermez.io/v1/ serviced by the Boot Coordinator node.</p>"},{"location":"Hermez_1.0/developers/coordinator/#launching-a-second-coordinator-node","title":"Launching a Second Coordinator Node","text":"<p>In this part of the tutorial we will start a second Coordinator Node in testnet that will bid for the right to forge batches.</p>"},{"location":"Hermez_1.0/developers/coordinator/#dependencies_2","title":"Dependencies","text":"<ul> <li>node 14+</li> </ul>"},{"location":"Hermez_1.0/developers/coordinator/#start-coordinator-in-testnet","title":"Start Coordinator in Testnet","text":"<ol> <li> <p>Stop Synchronizer node and PostgreSQL container launched in previous steps.</p> </li> <li> <p>Launch PostgreSQL database</p> </li> </ol> <pre><code>docker run --rm --name hermez-db -p 5432:5432 -e POSTGRES_DB=hermez -e POSTGRES_USER=hermez -e POSTGRES_PASSWORD=\"yourpasswordhere\" -d postgres\n</code></pre> <ol> <li> <p>Launch Prover as shown here</p> </li> <li> <p>Create two Ethereum accounts in Rinkeby using Metamask wallet. One account is the <code>forger</code> account (needs to pay for gas to forge batches in Ethereum and for bids in auction in HEZ), and the second is the <code>fee</code> account (receives the HEZ fees). The fees are collected in L2. You can convert from ETH to HEZ in Uniswap</p> </li> <li> <p>Create a Wallet with <code>fee</code> account Ethereum Private Key. </p> </li> </ol> <p>This wallet is needed to generate a Baby JubJub address where fees will be collected. There is an example code in the SDK that can be used. Simply substitute <code>EXAMPLES_WEB3_URL</code> by your Rinkeby Node URL and <code>EXAMPLES_PRIVATE_KEY1</code> by <code>fee</code> account private key.</p> <p>This script will generate a similar output:</p> <pre><code>{\n  privateKey: &lt;Buffer 3e 12 35 91 e9 99 61 98 24 74 dc 9c 09 70 0a cb d1 a5 c9 6f 34 2f ab 35 ca 44 90 01 31 f4 dc 19&gt;,\n  publicKey: [\n    '554747587236068008597553797728983628103889817758448212785555888433332778905',\n    '5660923625742030187027289840534366342931920530664475168036204263114974152564'\n  ],\n  publicKeyHex: [\n    '139f9dba06599c54e09934b242161b80041cda4be9192360b997e4751b07799',\n    'c83f81f4fce3e2ccc78530099830e29bf69713fa11c546ad152bf5226cfc774'\n  ],\n  publicKeyCompressed: '5660923625742030187027289840534366342931920530664475168036204263114974152564',\n  publicKeyCompressedHex: '0c83f81f4fce3e2ccc78530099830e29bf69713fa11c546ad152bf5226cfc774',\n  publicKeyBase64: 'hez:dMfPJlK_UtFqVByhP3FpvykOg5kAU3jMLD7OTx_4gwzO',\n  hermezEthereumAddress: 'hez:0x74d5531A3400f9b9d63729bA9C0E5172Ab0FD0f6'\n}\n</code></pre> <p>The Baby JubJub address is <code>publicKeyCompressedHex</code>. In this case, <code>0x0c83f81f4fce3e2ccc78530099830e29bf69713fa11c546ad152bf5226cfc774</code>.</p> <ol> <li>Copy configuration file to <code>hermez-node/cmd/heznode/cfg.testnet.coord.toml</code>. You will need to edit the following sections:</li> <li>PostgreSQL Values provided are valid for docker postgreSQL container. You will need to supply the actual values for your database.  </li> <li>Web3 URL of your Rinkeby Ethereum node</li> <li>SmartContracts Double check that the address provided in the configuration file corresponds to the current Hermez Network contract deployed in Rinkeby</li> <li>Coordinator.ForgerAddress Ethereum account in Ethereum Rinkeby. This account is used to bid during the slots auction and to pay the gas to forge batches in Ethereum</li> <li>Coordinator.FeeAccount You need to supply the Fee account in Ethereum Rinkeby and the Baby JubJub address computed in previous step. This account is used to colled the fees paid by transactions.</li> <li>Coordinator.ServerProofs Provide a valid URL for the proof server.</li> <li> <p>Coordinator.Circuit Ensure the <code>MaxTx</code> parameters matches with the circuit size configed in the proof server.</p> </li> <li> <p>Import the <code>forger</code> and <code>fee</code> Ethereum private keys into the keystore. </p> </li> </ol> <pre><code>./dist/heznode importkey --mode coord --cfg cmd/heznode/cfg.coord.toml --privatekey &lt;FORGER ACCOUNT_PRIVATE KEY&gt;\n./dist/heznode importkey --mode coord --cfg cmd/heznode/cfg.coord.toml --privatekey &lt;FEE_ACCOUNT PRIVATE KEY&gt;\n</code></pre> <p>This private key corresponds to the new Coordinator node </p> <ol> <li>Launch New Coordinator Node</li> </ol> <pre><code>./dist/heznode run --mode coord --cfg cmd/heznode/cfg.testnet.coord.toml\n</code></pre> <p>The node will start synchronizing with the Hermez Network in testnet. This may take a while.</p> <ol> <li>Launch new Price Updater service and connect it to the newly launched Hermez node Follow instructions to set up the Price Updater service.</li> </ol>"},{"location":"Hermez_1.0/developers/coordinator/#bidding-process","title":"Bidding Process","text":"<p>Once the node is synchronized, you can start bidding for the right to forge a batch.</p> <ol> <li>Install cli-bidding</li> </ol> <p><code>cli-bidding</code> is a tool that allows to register a Coordinator in Hermez Network and place bids in the auction.</p> <pre><code>git clone https://github.com/hermeznetwork/cli-bidding.git\n</code></pre> <p>Once downloaded, follow the installation steps in the README.</p> <p>NOTE that <code>PRIVATE_KEY_CLI_BIDDING</code> corresponds to the <code>forger</code> private key.</p> <ol> <li>Approve HEZ transfers.</li> </ol> <p>Before the coordinator can start bidding, it needs to approve the use of HEZ tokens. To do this go to HEZ address in Etherscan, select <code>Contract</code> -&gt; <code>Write Contract</code> -&gt; <code>Approve</code> and set <code>spender address</code> to Coordinator address and <code>value</code> to quantity you want to approve. The recommendation is to set this quantity value very high.</p> <ol> <li>Register Forger</li> </ol> <p>Using <code>cli-bidding</code>, you need to register the new Coordinator API URL. In our case, we have the Coordinator node running at <code>http://134.255.190.114:8086</code></p> <pre><code>node src/biddingCLI.js register --url http://134.255.190.114:8086\n</code></pre> <p>NOTE. In order for the wallet-ui to be able to forward transactions to this coordinator, the API needs to be accessible from a https domain.</p> <ol> <li>Get Current Slot and Minimum Bid in Hermez bid</li> </ol> <p>Take a look at the current slot being bid in Hermez. When bidding, you need to bid at least 2 slots after the curent slot</p> <pre><code>node src/biddingCLI.js slotinfo\n</code></pre> <p>In our case, minimum bidding is set to 11.0 HEZ, and first biddable slot is 4200.</p> <ol> <li>Bidding Process</li> </ol> <p>Send a simple bid of \\(11 \\times 10^{18}\\) HEZ for slot 4200. </p> <pre><code>node src/biddingCLI.js bid --amount 11 --slot 4200 --bidAmount 11\n</code></pre> <p>Parameter <code>amount</code> is the quantity to be transferred to the auction smart contract, and  <code>bidAmount</code> is the actual bid amount. </p> <p>If the bidding process is successful, an Etherscan URL with the transaction id is returned to verify transaction.</p> <p>You can check the allocated nextForgers using /v1/state endpoint</p> <p><code>cli-bidding</code> provides additional mechanisms to bid in multple slots at once. Check the README file</p>"},{"location":"Hermez_1.0/developers/dev-guide/","title":"Developer Guide","text":"<p>This document is an overview of the Hermez Protocol. Its objective is to provide an introduction to developers on the Hermez Protocol so that the use of the tools which interact with Hermez Network, such as <code>HermezJS</code> (javascript SDK) and the <code>REST API</code>, become simpler.  This document assumes you are familiar with the Ethereum ecosystem and L2 Rollups (in particular ZK-Rollups). </p> <p>For a more in depth analysis, read the <code>protocol</code> section.</p> <p>Hermez smart contracts can be downloaded from <code>here</code>.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#overview","title":"Overview","text":"<p>Hermez is a <code>zk-rollup</code> solution that allows scaling payments and token transfers on top of the Ethereum public blockchain. It uses Ethereum for data storage but not for computation. In addition, by using zero-knowledge proofs, it is easy to verify on-chain that computations have been carried out correctly.</p> <p>All accounts and balances in Hermez Network are stored off-chain in a <code>state tree</code>. Incoming user <code>transactions</code> are <code>batched</code> together, and through a <code>zk-SNARK</code> that proves that those transactions meet certain rules specified in a smart contract, the state tree transitions to a new verifiable valid state.</p> <p>The <code>coordinator</code> is the entity that collects and codifies these transactions, calculates the ZK-SNARK proof and submits the result to the smart contract that validates the transition. Transactions are made public to provide <code>data availability</code> to the protocol so that anyone can rebuild the state tree from on-chain data.</p> <p>Users typically send transactions to Hermez via a wallet. The purpose of this tool is to improve the experience of using Hermez by hiding the internal interactions between the different Hermez components and simplifying the usage. </p> <p>The <code>governance</code> is the  entity that oversees the sustainability and evolution of the network. Some functions delegated to the governance include the upgrade of smart contracts, the modification of <code>system parameters</code>, or the execution of the <code>withdrawal delay</code> mechanism among others.</p> <p>Hermez deploys three main smart contracts: 1. Hermez smart contract: Manages the <code>forging</code> stage by checking the zk-proofs provided by the selected coordinator, and updates the state and exit trees. It also interacts with users by collecting L1 transactions and adding them to the transaction queue. 2. Consensus smart contract: Manages the selection of a coordinator node via an auction process. 3. WithdrawalDelayer smart contract: Manages a withdrawal protection mechanism embedded into the system.</p> <p>The overall picture of Hermez can be seen in the diagram below.</p> <p></p> <p>Users send L1 transactions (such as Create account, Deposit or Withdrawal requests) using a UI. These transactions are collected by the Hermez smart contract and added into a queue of pending transactions.  Users may also send L2 transactions (Transfer, Exit) directly to the coordinator node. The UI hides all the unnecessary complexities from the user, who just selects the type of operation and the input data for a given operation (source account, destination account, amount to transfer,...). At the time of processing a batch, the coordinator takes the pending L1 transactions from the Hermez smart contract and the received L2 transactions, and generates a proof showing that these transactions have been carried out correctly. This proof is given to the smart contract that verifies it and updates the state of the network.  In the meantime, an auction process is ongoing to select the coordinator node for a given amount of time. In this auction, nodes bid for the right to forge upcoming batches and thus collecting the fees associated to those transactions. The proceedings of these bids will be sent to different accounts, including a  Gitcoin grants account.</p> <p>Hermez functionalities can be summarized in 4 major groups: 1. Handling L1-user and L2-user transactions 2. Forging batches 3. Reaching <code>consensus</code> to select a coordinator 4. Withdrawal of funds.</p> <p></p>"},{"location":"Hermez_1.0/developers/dev-guide/#accounts","title":"Accounts","text":"<p>Hermez stores accounts as leaves in the Hermez state tree. Each account stores a single type of token. A user may own multiple rollup accounts.</p> <p>There are two types of accounts to operate in Hermez Network: 1. Regular: Regular accounts can be used in both L1 and L2 transactions. Regular accounts include an Ethereum and a <code>babyjubjub</code> public key. An Ethereum key is used to authorize L1 transactions and the Baby Jubjub key is used to authorize L2 transactions. An Ethereum address may authorize the creation of a Regular account containing that same Ethereum address plus a Baby Jubjub public key. Typically, this is done via a UI.</p> <ol> <li>Internal: Internal accounts only have a Baby Jubjub key, and thus may only be used in L2 transactions. Since there is no Ethereum address, the account creation does not require an authorization and will only require a Baby Jubjub key.</li> </ol>"},{"location":"Hermez_1.0/developers/dev-guide/#transactions","title":"Transactions","text":"<p>There are two types of Hermez transactions: - L1 transactions are those that are executed through the smart contract. These transactions may be started by the user or by the coordinator. - L2 transactions are those that are executed exclusively on L2.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#l1-transactions","title":"L1 Transactions","text":"<p>L1 transactions can be divided in two groups depending the originator of the transaction: - L1 User Transactions: originate from an Hermez end-user using some form of UI.  - L1 Coordinator Transactions: originate from the coordinator.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#l1-user-transactions","title":"L1 User Transactions","text":"<p>L1 user transactions (L1UserTxs) are received by the smart contract. These transactions are concatenated and added in queues to <code>force the coordinator</code> to process them as part of the batch. The queue that will be forged in the next L1L2-batch is always frozen, and the L1 Transactions will be added in the following queues. In case a transaction is invalid (e.g. attempts to send an amount greater than the account balance) it will be processed by the circuit but will be nullified.</p> <p>This system allows the L1 transactions to be uncensorable</p> <p>Examples of L1 User transactions include <code>CreateAccountDeposit</code>, <code>Deposit</code>, <code>DepositTransfer</code>... All the transactions details are handled by the UI.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#l1-coordinator-transactions","title":"L1 Coordinator Transactions","text":"<p>L1 Coordinator Transactions (L1CoordinatorTxs) allow the coordinator to create regular or internal <code>accounts</code> when forging a batch so that a user can transfer funds to another user that doesn't own an account yet.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#l2-transactions","title":"L2 Transactions","text":"<p>L2 transactions (L2Txs) are executed exclusively on L2. Examples of L2 transactions include <code>Transfer</code> of funds between rollup accounts or <code>Exit</code> to transfer funds to the exit tree. All L2 transactions are initiated by the user, who sends the transactions directly to the coordinator via a <code>REST API</code>. Depending on the UI capabilities, the user may be able to select among a number of coordinators (the one currently forging, the ones that have already won the right to forge in upcoming slots,...).</p> <p>Fees are payed on L2 transactions in the same token used in the transaction. The coordinator collects these fees from up to 64 different tokens per batch. If more than 64 tokens are used in the same batch, no fees will be collected for the excess number of tokens. </p>"},{"location":"Hermez_1.0/developers/dev-guide/#transaction-id","title":"Transaction ID","text":"<p>Transaction ID (TxID) allows tracking transactions from the time they are sent to the coordinator to the time they are made available on chain.</p> <p>TxID is computed differently depending on the type of transaction (L1UserTxs, L1CoordinatorTxs or L2Txs). Padding is used to make all TxID (no matter which type) have the same length of 33 bytes.</p> <ul> <li>TxID on L1UserTx:   <code>bytes:   | 1 byte |             32 bytes                |                       SHA256(    8 bytes      |  2 bytes )   content: |   0    | SHA256([ToForgeL1TxsNum | Position ])</code></li> <li>TxID on L1CoordinatorTx:   <code>bytes:   | 1 byte |             32 bytes        |                       SHA256( 8 bytes  |  2 bytes )   content: |   1    | SHA256([BatchNum | Position ])</code></li> <li>TxID on L2Tx:   <code>bytes:   | 1 byte |             32 bytes        |                       SHA256( 6 bytes | 4 bytes | 2 bytes| 5 bytes | 1 byte )   content: |   2    | SHA256([FromIdx | TokenID | Amount |  Nonce  | Fee    ])</code></li> </ul>"},{"location":"Hermez_1.0/developers/dev-guide/#forging","title":"Forging","text":"<p>In this section we will describe how consensus to select a coordinator with the permission to forge batches and collect fees from the processed transactions is reached. We will also describe some of the embedded security mechanisms that discourage these coordinators from acting maliciously.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#consensus","title":"Consensus","text":"<p>In Hermez zkRollup, time is divided into slots of a certain duration:   - Ethereum Block = ~ 15s.   - Slot = 40 Ethereum Blocks ~ 10 min.</p> <p></p> <p>Hermez reaches a consensus on who will play the role of coordinator by running an auction managed by a smart contract. This auction is held among the existing nodes for every slot. The node that places the highest bid for a given slot while the auction is open will claim the role of coordinator for that slot. </p> <p>The coordinator node is allowed to forge batches during the awarded slot, which is the mechanism by which an authorized coordinator processes a batch of transactions, produces a ZK-SNARK attesting to the correctness of the operation and is able to reclaim the processing fees.</p> <p>Auction bids are placed only in <code>HEZ</code>. The auction of future slots opens up to S1 slots in advance. Auction closes S2 slots before the beginning the slot. Tentative S1 and S2 values are 1 month and 2 slots respectively. Additionally, these parameters can be changed by governance at any time.</p> <p>Bids placed during the auction should be at least greater than the minimal bidding price if it's the first bid in a slot, or a premium bid factor P % higher than the previous bid. Both the minimum bidding price and the premium bid factor(P) can be modified by the network governance. Tentative values for minimum bid and premium factor are 10 HEZ and 10% respectively. Bids not meeting these conditions will not be valid and bidders will receive their HEZ when the slot is forged.</p> <p></p> <p></p>"},{"location":"Hermez_1.0/developers/dev-guide/#allocation-of-bids","title":"Allocation of Bids","text":"<p>All bids are deposited in the consensus smart contract the moment they are placed. </p> <p>Once the slot is forged, the tokens bid are assigned to three different accounts: - Part will be burnt.  - Part will be assigned to a donations account with Gitcoin grants, which will decide how to allocate this funds into different projects. - Remaining tokens will be allocated to an incentives account, compensation active engagement and network adoption.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#protection-mechanisms","title":"Protection Mechanisms","text":"<p>There are some rules on how coordinators must process transactions. These rules ensure that a coordinator will behave correctly and efficiently, attempting to forge as many transactions as possible during its allocated slots. </p>"},{"location":"Hermez_1.0/developers/dev-guide/#l1l2-batches","title":"L1/L2 Batches","text":"<p>There are 2 types of batches: - L2-batch: Only L2 transactions are mined. - L1L2-batch: Both L1 and L2 transactions can be mined. In these batches, the coordinator must forge the last L1 queue.</p> <p>In both cases the coordinator may include L1-coordinator-transactions.</p> <p>Coordinators must process L1 user transactions periodically. The smart contract establishes a deadline for the L1L2-batches. This deadline indicates the maximum time between two consecutive L1L2 batches. Once this deadline is reached, the coordinator cannot forge any L2 batches until the deadline is reset which only happens after a L1L2 batch is forged.</p> <p>This mechanism is summarized in the diagram below.</p> <p></p>"},{"location":"Hermez_1.0/developers/dev-guide/#coordinator-override","title":"Coordinator Override","text":"<p>If for some reason the coordinator of the current slot doesn't forge any batch in the N first available blocks inside the slot, any available coordinator may forge batches without bidding. This maximum idle time is called Slot deadline, and defines the amount of time that any coordinator must wait to start forging without bidding, provided that the coordinator that won the current slot action hasn't forged anything during that time.</p> <p>This mechanism ensures that as long as there is one honest working coordinator, Hermez Network will be running and all funds will be recoverable. </p>"},{"location":"Hermez_1.0/developers/dev-guide/#boot-coordinator","title":"Boot Coordinator","text":"<p>Hermez includes the role of Boot coordinator managed by the network. The Boot coordinator acts as the bootstrap mechanism and its mission is to guarantee that there is always coordinator available in the early stages of the project.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#slot-grouping","title":"Slot Grouping","text":"<p>Auction is structured in groups of 6 slots (i.e, slots are sequentially indexed 0,1,2,3,4,5,0,1,...). Each slot index has an independent minimum bidding price. This grouping allows certain flexibility to the governance to influence behavior of coordinators. If slots are frequently wasted (meaning that elected coordinators chose not to forge batches), governance may increase the minimum bid amount for certain slots to make slot wasting less efficient for coordinators, and thus allowing the boot coordinator to forge the batches.</p> <p>When the minimum bidding price is set to 0 HEZ value for a given slot index, the value will be locked and governance will not be able to modify it anymore for that slot. </p>"},{"location":"Hermez_1.0/developers/dev-guide/#withdrawal","title":"Withdrawal","text":"<p>Funds are recovered from Hermez network by executing two transactions back-to-back: 1. Exit transaction: Funds are transferred from the state tree to the exit tree. 2. Withdrawal: Funds are transferred from Hermez smart contract to the user Ethereum address. The limit and rate at which funds can be transferred from the smart contract is regulated by a <code>leaky bucket</code> algorithm. Depending on the amount of available credits in the smart contract, withdrawal may be instantaneous or delayed.</p>"},{"location":"Hermez_1.0/developers/dev-guide/#hermez-withdrawal-limit","title":"Hermez Withdrawal Limit","text":"<p>Withdrawals are classified in one of several buckets depending on the USD amount to be withdrawn. Every bucket contains some amount of credits indicating the maximum amount that can be withdrawn at any point in time. Buckets are re-filled with credits at a specific rate (depending on bucket). When a user attempts to withdraw funds, credits in the selected bucket are subtracted. If the withdrawal amount exceeds the existing value of credits, the instant withdrawal cannot be performed and a delayed withdrawal will be done instead. Delayed withdrawal is handled by the WithdrawalDelayer smart contract.</p> <p>Figure below depicts how the different buckets are structured depending on the amount.</p> <p></p>"},{"location":"Hermez_1.0/developers/dev-guide/#withdrawal-resolution","title":"Withdrawal Resolution","text":"<p>The amount above the <code>withdrawal limit</code> set by the available credits wont be withdrawn instantly. In this case, excess tokens will be sent to the <code>WithdrawalDelayer</code> smart contract. </p> <p>The WithdrawalDelayer smart contract can be in one of two states: 1. Normal Mode: Amount above withdrawal limit is available for withdrawal, but with a delay D. This is the standard state. 2. Emergency Mode: The Hermez Foundation is the only body that may change the  WithdrawalDelayer mode to Emergency in case of an attack. In this scenario, funds can only be  withdrawn by the governance under the tutelage of an emergency council that will return the funds to the users. </p>"},{"location":"Hermez_1.0/developers/dev-guide/#adding-new-tokens","title":"Adding New Tokens","text":"<p>Hermez contains a list with all tokens supported. The following list includes some requirements on the token listing: - Tokens must be ERC20 - Governance can decide the fee cost of adding tokens and therefore can regulate the token listing. - There can be up to 2^{32} different tokens. - Contracts maintain a list of all tokens registered in the rollup and each token needs to be listed before using it. - The token 0 will be reserved for <code>ether</code> - A token only can be added once</p> <p>The list of supported tokens can be retrieved though the <code>REST API</code> </p>"},{"location":"Hermez_1.0/developers/getting-started/","title":"Getting Started","text":"<p>TODO</p>"},{"location":"Hermez_1.0/developers/glossary/","title":"Glossary","text":""},{"location":"Hermez_1.0/developers/glossary/#auction","title":"Auction","text":"<p>Selection of the coordinator is done via an auction process managed by a smart contract. The node with the highest bid in an open slot will earn the right to forge new batches and collect the fees from the transactions included in the batch. This auction is the process by which Hermez Network reaches a consensus on which node shall play the role of coordinator in an upcoming slot.</p>"},{"location":"Hermez_1.0/developers/glossary/#babyjubjub","title":"BabyJubJub","text":"<p>BabyJubJub is an elliptic curve defined over a large prime field. It's useful in zk-SNARKs proofs.</p>"},{"location":"Hermez_1.0/developers/glossary/#batch","title":"Batch","text":"<p>A batch is a rollup block. It is formed by a set of transactions that determines a state transition of the Hermez accounts and sets an exit tree. Batches can be: - L2-Batch: The set of transactions are only L2 - L1-L2 Batch: The set of transactions are L1 or L2</p>"},{"location":"Hermez_1.0/developers/glossary/#coordinator","title":"Coordinator","text":"<p>A coordinator is our term for rollup block producer. At any one time there is one coordinator responsible for collecting transactions and creating blocks on the rollup chain.</p>"},{"location":"Hermez_1.0/developers/glossary/#data-availability","title":"Data Availability","text":"<p>Hermez approach determines that anyone can reconstruct the full tree state by just collecting data from the mainnet. This is done by not having any dependency of third parties holding essential data to reconstruct the full state. This feature ensures liveness of the system, meaning that no third party needs to be active in order to provide data to rebuild the state tree.</p>"},{"location":"Hermez_1.0/developers/glossary/#forging","title":"Forging","text":"<p>Forging refers to the creation of a batch of layer 2 transactions (off-chain), creation of the proof and the subsequent (on-chain) verification of the attached zk-SNARK.</p>"},{"location":"Hermez_1.0/developers/glossary/#governance","title":"Governance","text":"<p>The Hermez Network community intends to follow a strategy of \u201cGovernance minimization\u201d. This model is intended to initially be a bootstrap governance mechanism to adjust and manage some network parameters mainly for security and stability purposes until the network reaches a sufficient degree of maturity to become fully decentralized; at that stage, the initial bootstrap Governance model\u00a0will no longer be necessary and will eventually disappear.</p> <p>The network will start with a governance based on a Community Council formed by some distributed and known Ethereum community members. This council will delegate some specific network parameters adjustments into a reduced Bootstrap Council, which is non custodial,  in order to be more operationally effective in the initial phase.</p> <p>Some decisions that the initial Community Council will be able to make will be:</p> <ul> <li>Governance and policies related changes</li> <li>Upgrade, maintenance and updates of the smart contracts code\u00a0and/or circuits.</li> </ul> <p>The bootstrap Council will be enabled to change some of the initial parameters of the Hermez smart contracts such as:</p> <ul> <li>Minimum bidding amount for the slots auction series;</li> <li>Days an auction is open for and slots before closing auction;</li> <li>Value of the outbidding variable;</li> <li>Boot Coordinator maximum cap reward reduction.</li> </ul>"},{"location":"Hermez_1.0/developers/glossary/#hez","title":"HEZ","text":"<p>Hermez has its own network token: HEZ.</p> <p>HEZ is an ERC-20 utility token used to place bids in the Coordinators auction. Every time a rollup batch is created, a fraction of\u00a0HEZ tokens placed during the proof-of-donation auction will be burned, and therefore permanently removed.</p>"},{"location":"Hermez_1.0/developers/glossary/#l1","title":"L1","text":"<p>Ethereum Layer-1 blockchain</p>"},{"location":"Hermez_1.0/developers/glossary/#l2","title":"L2","text":"<p>Hermez Layer-2 blockchain </p>"},{"location":"Hermez_1.0/developers/glossary/#proof-of-donation","title":"Proof of Donation","text":"<p>Bidding mechanism to select the coordinator for upcoming batches. A fraction of the winning bid goes back to be reinvested in the protocols and services that run on top of Ethereum. </p>"},{"location":"Hermez_1.0/developers/glossary/#system-parameters","title":"System Parameters","text":"<p>Set of parameters defined in the system that allow certain configuration from governance in order to modify the behavior of the network. </p>"},{"location":"Hermez_1.0/developers/glossary/#transactions","title":"Transactions","text":"<p>Transactions is the generic name given to every operation in the Hermez Network. Transactions may be initiated by a user or by the coordinator. Transactions may also happen on L1 or L2. The coordinator node is in charge of collecting and processing transactions in batches generating a ZK-SNARK to prove that the transactions have been carried out according to some rules.</p>"},{"location":"Hermez_1.0/developers/glossary/#atomic-transactions","title":"Atomic Transactions","text":"<p>Hermez provides the capability for some transactions to be processed together. This feature is called Atomic Transactions.</p>"},{"location":"Hermez_1.0/developers/glossary/#trees","title":"Trees","text":"<p>Hermez uses Sparse Merkle Trees to store the state of the Hermez Network. There are two main tree structures: - State Tree - Exit Tree</p>"},{"location":"Hermez_1.0/developers/glossary/#state-tree","title":"State Tree","text":"<p>Merkle tree used to represent the whole zkRollup state which is summarized by its root.  Each leaf of the state tree represents an account, and contains data such us balance, ethereum Address or type of token stored in this account.</p>"},{"location":"Hermez_1.0/developers/glossary/#exit-tree","title":"Exit Tree","text":"<p>Each batch has an associated exit tree with all the exits performed by the user (either L1 or L2 exit transactions). </p> <p>User needs to prove that it owns a leaf in the exit tree in order to perform a withdrawal and get the tokens back. This verification could be done either by submitting a Merkle tree proof or by submitting a zkProof. </p>"},{"location":"Hermez_1.0/developers/glossary/#exit-withdrawal","title":"Exit &amp; Withdrawal","text":"<p>In order to transfer funds from the L2 account to the Ethereum account, two separate transactions are invoked. The first transaction is Exit, where funds are transferred to a smart contract. The second transaction is Withdrawal. If conditions are met, Withdrawal can be instant. If funds to be withdrawn exceed certain limits, the Withdrawal is delayed until the transaction is cleared.</p>"},{"location":"Hermez_1.0/developers/glossary/#zk-rollup","title":"zk-Rollup","text":"<p>A zk-Rollup is a layer 2 construction\u200a\u200awhich uses the Ethereum blockchain for data storage instead of computation.  All funds are held by a smart contract on the main-chain. For every batch, a zk-snark is generated off-chain and verified by this contract. This snark proves the validity of every transaction in the batch.</p>"},{"location":"Hermez_1.0/developers/glossary/#zk-snark","title":"zk-SNARK","text":"<p>A zk-SNARK is a short (and efficiently checkable) cryptographic proof that allows to prove something specific without revealing any extra information.</p>"},{"location":"Hermez_1.0/developers/price-updater/","title":"Price Updater","text":"<p>Price Updater is a web service used to consult and update the tokens and fiat currency used by Hermez Node.</p>"},{"location":"Hermez_1.0/developers/price-updater/#installation","title":"Installation","text":"<pre><code>$ git clone git@github.com:hermeznetwork/price-updater-service.git\n$ cd price-updater-service/\n$ go build -o priceupdater # or other name that you want\n</code></pre>"},{"location":"Hermez_1.0/developers/price-updater/#pre-requirements","title":"Pre-requirements","text":"<ol> <li>It is necessary to have write access to a Hermez node database. The Price updater will update the prices and write them to the database.</li> <li>You need an API Key from <code>https://exchangeratesapi.io/</code> </li> </ol>"},{"location":"Hermez_1.0/developers/price-updater/#usage","title":"Usage","text":"<ol> <li>Configure <code>.env</code> file in the <code>price-updater</code> main folder. Below there is an example of and <code>.env</code> file.</li> </ol> <pre><code>HTTP_HOST=\"0.0.0.0\"\nHTTP_PORT=8037\n\n# POSTGRES information\nPOSTGRES_USER=\"hermez\"\nPOSTGRES_PASSWORD=\"yourpasswordhere\"\nPOSTGRES_HOST=\"localhost\"\nPOSTGRES_PORT=5432\nPOSTGRES_DATABASE=\"hermez\"\nPOSTGRES_SSL_ENABLED=false\nPOSTGRES_MAX_ID_CONNS=10\nPOSTGRES_MAX_OPEN_CONNS=10\n\n# ETHEREUM NODE URL\nETH_NETWORK=\"http://localhost:8545\"\n\n# ROLLUP SMART CONTRACT ADDRESS\nETH_HEZ_ROLLUP=\"0xA68D85dF56E733A06443306A095646317B5Fa633\"\nETH_USDT_ADDRESS=\"0xa1A31DE489C9b977fa78c70C7f001da181e126FB\"\n\n# API KEY from https://exchangeratesapi.io/`. \nFIAT_API_KEY=\"ffffffffffffffffffffffffffff\"\nBBOLT_LOCATION=\"priceupdater.db\"\nMAIN_TIME_TO_UPDATE_PRICES=1m\n</code></pre> <p><code>POSTGRES_USER</code>, <code>POSTGRES_PASSWORD</code>, <code>POSTGRES_HOST</code> and <code>POSTGRES_PORT</code> can be extracted from the Hermez node configuration file</p> <ol> <li>Configure provider priority. Providers are selected in order. </li> </ol> <pre><code>./priceupdater change-priority --priority \"bitfinex,coingecko,uniswap\"\n</code></pre> <p>Price Updater provides configurations files to use Bitfinex, Coingecko and Uniswap as providers depending on the network. 3. Update provided configuration</p> <pre><code>./priceupdater update-config --provider bitfinex --configFile assets/testnet/bitfinex.json\n./priceupdater update-config --provider coingecko --configFile assets/testnet/coingecko.json \n./priceupdater update-config --provider uniswap --configFile assets/testnet/uniswap.json \n</code></pre> <ol> <li>Set up an apiKey to accept incoming requests</li> </ol> <pre><code>./priceupdater setup-apikey --apiKey \"pr1c3upd4t3rw \n</code></pre> <ol> <li>Start server</li> </ol> <pre><code>./priceupdater server\n</code></pre> <p>If everything went well, you should see the following output:</p> <pre><code>\n2021-08-16T14:41:32Z    INFO    cli/server.go:33        connection established with postgresql server\n \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n \u2502                   Fiber v2.14.0                   \u2502 \n \u2502               http://127.0.0.1:8037               \u2502 \n \u2502       (bound on host 0.0.0.0 and port 8037)       \u2502 \n \u2502                                                   \u2502 \n \u2502 Handlers ............ 12  Processes ........... 1 \u2502 \n \u2502 Prefork ....... Disabled  PID ............ 120438 \u2502 \n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/","title":"Examples","text":"<p>Some Golang and Javascript integration examples are provided as a reference. They can be found at: - Hermez Golang examples - Hermez Javascript examples</p> <p>Additionally, Hermez Mobile SDK example provides an example of how to import and use the Mobile SDK.</p>"},{"location":"Hermez_1.0/developers/sdk/#sdk","title":"SDK","text":"<p>A full Javascript SDK and a Flutter Plugin for Hermez Mobile SDK are provided as part of the tools for integration with Hermez Network.</p> <p>HermezJS is an open-source SDK to interact with Hermez Rollup network.  It can be downloaded as an npm package, or via github.</p> <p>Hermez Flutter SDK is a Flutter Plugin for Hermez Mobile SDK, and provides a cross-platform tool (iOS, Android) to communicate with the Hermez API and network. </p> <p>There is an additional Golang SDK to interact with Hermez using Golang.</p>"},{"location":"Hermez_1.0/developers/sdk/#sdk-how-to-javascript","title":"SDK How-To (Javascript)","text":"<p>In this tutorial we will walk through the process of using the SDK to: 1. Installing Hermezjs 2. Initializing Hermezjs 3. Check registered tokens 4. Creating a wallet 5. Making a deposit from Ethereum into the Hermez Network 6. Verifying the balance in a Hermez account 7. Withdrawing funds back to Ethereum network 8. Making transfers 9. Verifying transaction status 10. Authorizing the creation of Hermez accounts 11. Internal accounts</p>"},{"location":"Hermez_1.0/developers/sdk/#install-hermezjs","title":"Install Hermezjs","text":"<pre><code>npm i @hermeznetwork/hermezjs\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#import-modules","title":"Import modules","text":"<p>Load Hermezjs library</p> <pre><code>const hermez = require('@hermeznetwork/hermezjs')\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#initialization","title":"Initialization","text":""},{"location":"Hermez_1.0/developers/sdk/#create-transaction-pool","title":"Create Transaction Pool","text":"<p>Initialize the storage where user transactions are stored. This needs to be initialized at the start of your application.</p> <pre><code>  hermez.TxPool.initializeTransactionPool()\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#configure-hermez-environment","title":"Configure Hermez Environment","text":"<p>In these examples, we are going to connect to <code>Hermez Testnet</code> which is deployed in Rinkeby Ethereum Network. To configure <code>Hermezjs</code> to work with the Testnet, we need to configure a Rinkeby Ethereum node, the Hermez API URL, and the addresses of the Hermez and Withdrawal Delayer smart contracts.</p> <p>Hermez Testnet API URL is deployed at https://api.testnet.hermez.io/v1. </p> <p>NOTE: In order to interact with Hermez Testnet, you will need to supply your own Rinkeby Ethereum node. You can check these links to help you set up a Rinkeby node (https://blog.infura.io/getting-started-with-infura-28e41844cc89, https://blog.infura.io/getting-started-with-infuras-ethereum-api).</p> <p>Currently, Testnet Hermez smart contract is deployed at address <code>0x14a3b6f3328766c7421034e14472f5c14c5ba090</code> and Withdrawal Delayer contract is deployed at address <code>0x6ea0abf3ef52d24427043cad3ec26aa4f2c8e8fd</code>. These addresses could change in the future, so please check these addresses with a query of the API using the browser.</p> <p>For the remainder of the examples, we will configure the basic Hermezjs parameters</p> <pre><code>const EXAMPLES_WEB3_URL = 'https://rinkeby.infura.io/v3/80496a41d0a134ccbc6e856ffd034696'\nconst EXAMPLES_HERMEZ_API_URL = 'https://api.testnet.hermez.io'\nconst EXAMPLES_HERMEZ_ROLLUP_ADDRESS = '0x14a3b6f3328766c7421034e14472f5c14c5ba090'\nconst EXAMPLES_HERMEZ_WDELAYER_ADDRESS = '0x6ea0abf3ef52d24427043cad3ec26aa4f2c8e8fd'\n\nhermez.Providers.setProvider(EXAMPLES_WEB3_URL)\nhermez.Environment.setEnvironment({\n        baseApiUrl: EXAMPLES_HERMEZ_API_URL,\n        contractAddresses: {\n          [hermez.Constants.ContractNames.Hermez]: EXAMPLES_HERMEZ_ROLLUP_ADDRESS,\n          [hermez.Constants.ContractNames.WithdrawalDelayer]: EXAMPLES_HERMEZ_WDELAYER_ADDRESS\n        }\n})\n\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#check-token-exists-in-hermez-network","title":"Check token exists in Hermez Network","text":"<p>Before being able to operate on the Hermez Network, we must ensure that the token we want to operate with is listed. For that we make a call to the Hermez Coordinator API that will list all available tokens. All tokens in Hermez Network must be ERC20.</p> <p>We can see there are 2 tokens registered. <code>ETH</code> will always be configured at index 0. The second token is <code>HEZ</code>. For the rest of the examples we will work with <code>ETH</code>. In the future, more tokens will be included in Hermez.</p> <pre><code>  const token = await hermez.CoordinatorAPI.getTokens()\n  const tokenERC20 = token.tokens[0]\n  console.log(token)\n\n&gt;&gt;&gt;&gt;\n{\n  tokens: [\n    {\n      itemId: 1,\n      id: 0,\n      ethereumBlockNum: 0,\n      ethereumAddress: '0x0000000000000000000000000000000000000000',\n      name: 'Ether',\n      symbol: 'ETH',\n      decimals: 18,\n      USD: 1787,\n      fiatUpdate: '2021-02-28T18:55:17.372008Z'\n    },\n    {\n      itemId: 2,\n      id: 1,\n      ethereumBlockNum: 8153596,\n      ethereumAddress: '0x2521bc90b4f5fb9a8d61278197e5ff5cdbc4fbf2',\n      name: 'Hermez Network Token',\n      symbol: 'HEZ',\n      decimals: 18,\n      USD: 5.365,\n      fiatUpdate: '2021-02-28T18:55:17.386805Z'\n    }\n  ],\n  pendingItems: 0\n\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#create-a-wallet","title":"Create a Wallet","text":"<p>We can create a new Hermez wallet by providing the Ethereum private key of an Ethereum account. This wallet will store the Ethereum and Baby JubJub keys for the Hermez account. The Ethereum address is used to authorize L1 transactions, and the Baby JubJub key is used to authorize L2 transactions. We will create two wallets.</p> <p>NOTE You will need to supply two Rinkeby private keys to initialize both accounts. The keys provided here are invalid and are shown as an example.</p> <pre><code>  const EXAMPLES_PRIVATE_KEY1 = 0x705d123e707e25fa37ca84461ac6eb83eb4921b65680cfdc594b60bea1bb4e52\n  const EXAMPLES_PRIVATE_KEY2 = 0x3a9270c05ac169097808da4b02e8f9146be0f8a38cfad3dcfc0b398076381fdd\n\n  // load first account\n  const wallet = await hermez.HermezWallet.createWalletFromEtherAccount(EXAMPLES_WEB3_URL, { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY1 })\n  const hermezWallet = wallet.hermezWallet\n  const hermezEthereumAddress = wallet.hermezEthereumAddress\n\n  // load second account\n  const wallet2 = await hermez.HermezWallet.createWalletFromEtherAccount(EXAMPLES_WEB3_URL, { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY2 })\n  const hermezWallet2 = wallet2.hermezWallet\n  const hermezEthereumAddress2 = wallet2.hermezEthereumAddress\n\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#deposit-tokens-from-ethereum-into-hermez-network","title":"Deposit Tokens from Ethereum into Hermez Network","text":"<p>Creating a Hermez account and depositing tokens is done simultaneously as an L1 transaction.  In this example we are going to deposit 1 <code>ETH</code> tokens into the newly created Hermez accounts. </p> <pre><code>  // set amount to deposit\n  const amountDepositString = '1.0'\n  const amountDeposit = hermez.Utils.getTokenAmountBigInt(amountDepositString, 18)\n  const compressedDepositAmount = hermez.HermezCompressedAmount.compressAmount(amountDeposit)\n\n  // perform deposit account 1\n  await hermez.Tx.deposit(\n    compressedDepositAmount,\n    hermezEthereumAddress,\n    tokenERC20,\n    hermezWallet.publicKeyCompressedHex,\n    { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY1 }\n  )\n\n  // perform deposit account 2\n  await hermez.Tx.deposit(\n    compressedDepositAmount,\n    hermezEthereumAddress2,\n    tokenERC20,\n    hermezWallet2.publicKeyCompressedHex,\n    { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY2 }\n  )\n\n</code></pre> <p>Internally, the deposit funcion calls the Hermez smart contract to add the L1 transaction.</p>"},{"location":"Hermez_1.0/developers/sdk/#verify-balance","title":"Verify Balance","text":"<p>A token balance can be obtained by querying the API and passing the <code>hermezEthereumAddress</code> of the Hermez account.</p> <pre><code>    // get sender account information\n    const infoAccountSender = (await hermez.CoordinatorAPI.getAccounts(hermezEthereumAddress, [tokenERC20.id]))\n      .accounts[0]\n\n    // get receiver account information\n    const infoAccountReceiver = (await hermez.CoordinatorAPI.getAccounts(hermezEthereumAddress2, [tokenERC20.id]))\n      .accounts[0]\n\n    console.log(infoAccountSender)\n    console.log(infoAccountReceiver)\n\n&gt;&gt;&gt;&gt;&gt;\n{\n  accountIndex: 'hez:ETH:4253',\n  balance: '1099600000000000000',\n  bjj: 'hez:dMfPJlK_UtFqVByhP3FpvykOg5kAU3jMLD7OTx_4gwzO',\n  hezEthereumAddress: 'hez:0x74d5531A3400f9b9d63729bA9C0E5172Ab0FD0f6',\n  itemId: 4342,\n  nonce: 1,\n  token: {\n    USD: 1789,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n{\n  accountIndex: 'hez:ETH:4254',\n  balance: '1097100000000000000',\n  bjj: 'hez:HESLP_6Kp_nn5ANmSGiOnhhYvF3wF5Davf7xGi6lwh3U',\n  hezEthereumAddress: 'hez:0x12FfCe7D5d6d09564768d0FFC0774218458162d4',\n  itemId: 4343,\n  nonce: 6,\n  token: {\n    USD: 1789,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n\n</code></pre> <p>We can see that the field <code>accountIndex</code> is formed by the token symbol it holds and an index. A Hermez account can only hold one type of token. Account indexes start at 256. Indexes 0-255 are reserved for internal use. Note that the balances do not match with the ammount deposited of 1 <code>ETH</code> because accounts already existed in Hermez Network before the deposit, so we performed a <code>deposit on top</code> instead.</p> <p>Alternatively, an account query can be filtered using the assigned <code>accountIndex</code></p> <pre><code>    const account1ByIdx = await hermez.CoordinatorAPI.getAccount(infoAccountSender.accountIndex)\n    const account2ByIdx = await hermez.CoordinatorAPI.getAccount(infoAccountReceiver.accountIndex)\n\n    console.log(account1ByIdx)\n    console.log(account2ByIdx)\n\n&gt;&gt;&gt;&gt;&gt;\n\n{\n  accountIndex: 'hez:ETH:4253',\n  balance: '1099600000000000000',\n  bjj: 'hez:dMfPJlK_UtFqVByhP3FpvykOg5kAU3jMLD7OTx_4gwzO',\n  hezEthereumAddress: 'hez:0x74d5531A3400f9b9d63729bA9C0E5172Ab0FD0f6',\n  itemId: 4342,\n  nonce: 1,\n  token: {\n    USD: 1789,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n{\n  accountIndex: 'hez:ETH:4254',\n  balance: '1097100000000000000',\n  bjj: 'hez:HESLP_6Kp_nn5ANmSGiOnhhYvF3wF5Davf7xGi6lwh3U',\n  hezEthereumAddress: 'hez:0x12FfCe7D5d6d09564768d0FFC0774218458162d4',\n  itemId: 4343,\n  nonce: 6,\n  token: {\n    USD: 1789,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#withdrawing","title":"Withdrawing","text":"<p>Withdrawing funds is a two step process: 1. Exit 2. Withdrawal</p>"},{"location":"Hermez_1.0/developers/sdk/#exit","title":"Exit","text":"<p>The <code>Exit</code> transaction is used as a first step to retrieve the funds from <code>Hermez Network</code> back to Ethereum. There are two types of <code>Exit</code> transactions: - Normal Exit, referred as <code>Exit</code> from now on. This is a L2 transaction type. - <code>Force Exit</code>, an L1 transaction type which has extended guarantees that will be processed by the Coordinator. We will talk more about <code>Force Exit</code> here</p> <p>The <code>Exit</code> is requested as follows:</p> <pre><code>  // set amount to exit\n  const amountExit = hermez.HermezCompressedAmount.compressAmount(hermez.Utils.getTokenAmountBigInt('1.0', 18))\n\n  // set fee in transaction\n  const state = await hermez.CoordinatorAPI.getState()\n  const userFee = state.recommendedFee.existingAccount\n\n  // generate L2 transaction\n  const l2ExitTx = {\n    type: 'Exit',\n    from: infoAccountSender.accountIndex,\n    amount: amountExit,\n    fee: userFee\n  }\n\n  const exitResponse = await hermez.Tx.generateAndSendL2Tx(l2ExitTx, hermezWallet, infoAccountSender.token)\n  console.log(exitResponse)\n\n&gt;&gt;&gt;&gt;\n{\n  status: 200,\n  id: '0x0257305cdc43060a754a5c2ea6b0e0f6e28735ea8e75d841ca4a7377aa099d91b7',\n  nonce: 2\n}\n\n</code></pre> <p>After submitting our <code>Exit</code> request to the Coordinator, we can check the status of the transaction by calling the Coordinator's Transaction Pool. The Coordinator's transaction pool stores all those transactions  that are waiting to be forged.</p> <pre><code>  const txPool = await hermez.CoordinatorAPI.getPoolTransaction(exitResponse.id)\n  console.log(txPool)\n\n&gt;&gt;&gt;&gt;&gt;\n{\n  amount: '1000000000000000000',\n  fee: 204,\n  fromAccountIndex: 'hez:ETH:4253',\n  fromBJJ: 'hez:dMfPJlK_UtFqVByhP3FpvykOg5kAU3jMLD7OTx_4gwzO',\n  fromHezEthereumAddress: 'hez:0x74d5531A3400f9b9d63729bA9C0E5172Ab0FD0f6',\n  id: '0x0257305cdc43060a754a5c2ea6b0e0f6e28735ea8e75d841ca4a7377aa099d91b7',\n  info: null,\n  nonce: 2,\n  requestAmount: null,\n  requestFee: null,\n  requestFromAccountIndex: null,\n  requestNonce: null,\n  requestToAccountIndex: null,\n  requestToBJJ: null,\n  requestToHezEthereumAddress: null,\n  requestTokenId: null,\n  signature: '38f23d06826be8ea5a0893ee67f4ede885a831523c0c626c102edb05e1cf890e418b5820e3e6d4b530386d0bc84b3c3933d655527993ad77a55bb735d5a67c03',\n  state: 'pend',\n  timestamp: '2021-03-16T12:31:50.407428Z',\n  toAccountIndex: 'hez:ETH:1',\n  toBjj: null,\n  toHezEthereumAddress: null,\n  token: {\n    USD: 1781.9,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  },\n  type: 'Exit'\n}\n\n\n</code></pre> <p>We can see the <code>state</code> field is set to <code>pend</code> (meaning pending). There are 4 possible states:  1. pend : Pending 2. fging : Forging 3. fged : Forged 4. invl : Invalid</p> <p>If we continue polling the Coordinator about the status of the transaction, the state will eventually be set to <code>fged</code>.</p> <p>We can also query the Coordinator to check whether or not our transaction has been forged. <code>getHistoryTransaction</code> reports those transactions that have been forged by the Coordinator.</p> <pre><code>  const txExitConf = await hermez.CoordinatorAPI.getHistoryTransaction(txExitPool.id)\n  console.log(txExitConf)\n\n</code></pre> <p>And we can confirm our account status and check that the correct amount has been transfered out of the account.</p> <pre><code>  console.log((await hermez.CoordinatorAPI.getAccounts(hermezEthereumAddress, [tokenERC20.id]))\n    .accounts[0])\n\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#withdrawing-funds-from-hermez","title":"Withdrawing Funds from Hermez","text":"<p>After doing any type of <code>Exit</code> transaction, which moves the user's funds from their token account to a specific Exit Merkle tree, one needs to do a <code>Withdraw</code> of those funds to an Ethereum L1 account. To do a <code>Withdraw</code> we need to indicate the <code>accountIndex</code> that includes the Ethereum address where the funds will be transferred, the amount and type of tokens, and some information to verify the ownership of those tokens. Additionally, there is one boolean flag. If set to true, the <code>Withdraw</code> will be instantaneous.</p> <pre><code>    const exitInfoN = (await hermez.CoordinatorAPI.getExits(infoAccountSender.hezEthereumAddress, true)).exits\n    const exitInfo = exitInfoN[exitInfoN.length - 1]\n    // set to perform instant withdraw\n    const isInstant = true\n\n    // perform withdraw\n    await hermez.Tx.withdraw(\n      exitInfo.balance,\n      exitInfo.accountIndex,\n      exitInfo.token,\n      hermezWallet.publicKeyCompressedHex,\n      exitInfo.batchNum,\n      exitInfo.merkleProof.siblings,\n      isInstant,\n      { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY1 }\n    )\n\n</code></pre> <p>The funds should now appear in the Ethereum account that made the withdrawal.</p>"},{"location":"Hermez_1.0/developers/sdk/#force-exit","title":"Force Exit","text":"<p>This is the L1 equivalent of an Exit. With this option, the smart contract forces Coordinators to pick up L1 transactions before they pick up L2 transactions to ensure that L1 transactions will eventually be picked up.</p> <p>This is a security measure. We don't expect users to need to make a Force Exit.</p> <pre><code>  // set amount to force-exit\n  const amountForceExit = hermez.HermezCompressedAmount.compressAmount(hermez.Utils.getTokenAmountBigInt('1.0', 18))\n\n  // perform force-exit\n  await hermez.Tx.forceExit(\n    amountForceExit,\n    infoAccountSender.accountIndex,\n    tokenERC20,\n    { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY1 }\n  )\n</code></pre> <p>The last step to recover the funds will be to send a new <code>Withdraw</code> request to the smart contract as we did after the regular <code>Exit</code> request.</p> <pre><code>  ```js\n    const exitInfoN = (await hermez.CoordinatorAPI.getExits(infoAccountSender.hezEthereumAddress, true)).exits\n    const exitInfo = exitInfoN[exitInfoN.length - 1]\n    // set to perform instant withdraw\n    const isInstant = true\n\n    // perform withdraw\n    await hermez.Tx.withdraw(\n      exitInfo.balance,\n      exitInfo.accountIndex,\n      exitInfo.token,\n      hermezWallet.publicKeyCompressedHex,\n      exitInfo.batchNum,\n      exitInfo.merkleProof.siblings,\n      isInstant,\n      { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY1 }\n    )\n\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#transfers","title":"Transfers","text":"<p>First, we compute the fees for the transaction. For this we consult the recommended fees from the Coordinator.</p> <pre><code>  // fee computation\n  const state = await hermez.CoordinatorAPI.getState()\n  console.log(state.recommendedFee)\n\n&gt;&gt;&gt;&gt;\n{\n  existingAccount: 96.34567219671051,\n  createAccount: 192.69134439342102,\n  createAccountInternal: 240.86418049177627\n}\n\n</code></pre> <p>The returned fees are the suggested fees for different transactions: - existingAccount : Make a transfer to an existing account - createAccount   : Make a transfer to a non-existent account, and create a regular account - createAccountInternal : Make a transfer to an non-existent account and create internal account</p> <p>The fee amounts are given in USD. However, fees are payed in the token of the transaction. So, we need to do a conversion.</p> <pre><code>  const usdTokenExchangeRate = tokenERC20.USD\n  const fee = fees.existingAccount / usdTokenExchangeRate\n</code></pre> <p>Finally we make the final transfer transaction.</p> <pre><code>  // set amount to transfer\n  const amountTransfer = hermez.HermezCompressedAmount.compressAmount(hermez.Utils.getTokenAmountBigInt('1.0', 18))\n  // generate L2 transaction\n  const l2TxTransfer = {\n    from: infoAccountSender.accountIndex,\n    to: infoAccountReceiver.accountIndex,\n    amount: amountTransfer,\n    fee: fee\n  }\n  const transferResponse = await hermez.Tx.generateAndSendL2Tx(l2TxTransfer, hermezWallet, infoAccountSender.token)\n  console.log(transferResponse)\n\n&gt;&gt;&gt;&gt;&gt;\n{\n  status: 200,\n  id: '0x02e7c2c293173f21249058b1d71afd5b1f3c0de4f1a173bac9b9aa4a2d149483a2',\n  nonce: 3\n}\n\n</code></pre> <p>The result status 200 shows that transaction has been correctly received. Additionally, we receive the nonce matching the transaction we sent, and an id that we can use to verify the status of the transaction either using <code>hermez.CoordinatorAPI.getHistoryTransaction()</code> or <code>hermez.CoordinatorAPI.getPoolTransaction()</code>.</p> <p>As we saw with the <code>Exit</code> transaction, every transaction includes a \u00b4nonce\u00b4. This <code>nonce</code> is a protection mechanism to avoid replay attacks. Every L2 transaction will increase the nonce by 1.</p>"},{"location":"Hermez_1.0/developers/sdk/#verifying-transaction-status","title":"Verifying Transaction Status","text":"<p>Transactions received by the Coordinator will be stored in its transaction pool while they haven't been processed. To check a transaction in the transaction pool we make a query to the Coordinator node.</p> <pre><code>  const txXferPool = await hermez.CoordinatorAPI.getPoolTransaction(transferResponse.id)\n  console.log(txXferPool)\n\n&gt;&gt;&gt;&gt;&gt;\n{\n  amount: '100000000000000',\n  fee: 202,\n  fromAccountIndex: 'hez:ETH:4253',\n  fromBJJ: 'hez:dMfPJlK_UtFqVByhP3FpvykOg5kAU3jMLD7OTx_4gwzO',\n  fromHezEthereumAddress: 'hez:0x74d5531A3400f9b9d63729bA9C0E5172Ab0FD0f6',\n  id: '0x02e7c2c293173f21249058b1d71afd5b1f3c0de4f1a173bac9b9aa4a2d149483a2',\n  info: null,\n  nonce: 3,\n  requestAmount: null,\n  requestFee: null,\n  requestFromAccountIndex: null,\n  requestNonce: null,\n  requestToAccountIndex: null,\n  requestToBJJ: null,\n  requestToHezEthereumAddress: null,\n  requestTokenId: null,\n  signature: 'c9e1a61ce2c3c728c6ec970ae646b444a7ab9d30aa6015eb10fb729078c1302978fe9fb0419b4d944d4f11d83582043a48546dff7dda22de7c1e1da004cd5401',\n  state: 'pend',\n  timestamp: '2021-03-16T13:20:33.336469Z',\n  toAccountIndex: 'hez:ETH:4254',\n  toBjj: 'hez:HESLP_6Kp_nn5ANmSGiOnhhYvF3wF5Davf7xGi6lwh3U',\n  toHezEthereumAddress: 'hez:0x12FfCe7D5d6d09564768d0FFC0774218458162d4',\n  token: {\n    USD: 1786,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  },\n  type: 'Transfer'\n}\n\n\n</code></pre> <p>We can also check directly with the Coordinator in the database of forged transactions.</p> <pre><code>  const transferConf = await hermez.CoordinatorAPI.getHistoryTransaction(transferResponse.id)\n  console.log(transferConf)\n\n&gt;&gt;&gt;&gt;&gt;\n{\n  L1Info: null,\n  L1orL2: 'L2',\n  L2Info: { fee: 202, historicFeeUSD: 182.8352, nonce: 3 },\n  amount: '100000000000000',\n  batchNum: 4724,\n  fromAccountIndex: 'hez:ETH:4253',\n  fromBJJ: 'hez:dMfPJlK_UtFqVByhP3FpvykOg5kAU3jMLD7OTx_4gwzO',\n  fromHezEthereumAddress: 'hez:0x74d5531A3400f9b9d63729bA9C0E5172Ab0FD0f6',\n  historicUSD: 0.17855,\n  id: '0x02e7c2c293173f21249058b1d71afd5b1f3c0de4f1a173bac9b9aa4a2d149483a2',\n  itemId: 14590,\n  position: 1,\n  timestamp: '2021-03-16T13:24:48Z',\n  toAccountIndex: 'hez:ETH:4254',\n  toBJJ: 'hez:HESLP_6Kp_nn5ANmSGiOnhhYvF3wF5Davf7xGi6lwh3U',\n  toHezEthereumAddress: 'hez:0x12FfCe7D5d6d09564768d0FFC0774218458162d4',\n  token: {\n    USD: 1787.2,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  },\n  type: 'Transfer'\n}\n\n</code></pre> <p>At this point, the balances in both accounts will be updated with the result of the transfer</p> <pre><code>  // check balances\n  console.log((await hermez.CoordinatorAPI.getAccounts(wallet.hermezEthereumAddress, [tokenERC20.id])).accounts[0])\n  console.log((await hermez.CoordinatorAPI.getAccounts(wallet2.hermezEthereumAddress2, [tokenERC20.id])).accounts[0])\n&gt;&gt;&gt;&gt;&gt;\n\n{\n  accountIndex: 'hez:ETH:4253',\n  balance: '477700000000000000',\n  bjj: 'hez:dMfPJlK_UtFqVByhP3FpvykOg5kAU3jMLD7OTx_4gwzO',\n  hezEthereumAddress: 'hez:0x74d5531A3400f9b9d63729bA9C0E5172Ab0FD0f6',\n  itemId: 4342,\n  nonce: 4,\n  token: {\n    USD: 1793,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n{\n  accountIndex: 'hez:ETH:256',\n  balance: '1874280899837791518',\n  bjj: 'hez:YN2DmRh0QgDrxz3NLDqH947W5oNys7YWqkxsQmFVeI_m',\n  hezEthereumAddress: 'hez:0x9F255048EC1141831A28019e497F3f76e559356E',\n  itemId: 1,\n  nonce: 2,\n  token: {\n    USD: 1793,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-02-28T18:55:17.372008Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#create-account-authorization","title":"Create Account Authorization","text":"<p>Imagine that Bob wants to send a transfer of Ether to Mary using Hermez, but Mary only has an Ethereum account but no Hermez account. To complete this transfer, Mary could open a Hermez account and proceed as the previous transfer example. Alternatively, Mary could authorize the Coordinator to create a Hermez account on her behalf so that she can receive Bob's transfer. </p> <p>First we create a wallet for Mary:</p> <pre><code>  // load second account\n  const wallet3 = await hermez.HermezWallet.createWalletFromEtherAccount(EXAMPLES_WEB3_URL, { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY3 })\n  const hermezWallet3 = wallet3.hermezWallet\n  const hermezEthereumAddress3 = wallet3.hermezEthereumAddress\n</code></pre> <p>The authorization for the creation of a Hermez account is done using the private key stored in the newly created Hermez wallet. </p> <p>Note that the account is not created at this moment. The account will be created when Bob performs the transfer. Also, it is Bob  that pays for the fees associated with the account creation.</p> <pre><code>  const EXAMPLES_PRIVATE_KEY3 = '0x3d228fed4dc371f56b8f82f66ff17cd6bf1da7806d7eabb21810313dee819a53'\n  const signature = await hermezWallet3.signCreateAccountAuthorization(EXAMPLES_WEB3_URL, { type: 'WALLET', privateKey: EXAMPLES_PRIVATE_KEY3 })\n  const res = await hermez.CoordinatorAPI.postCreateAccountAuthorization(\n    hermezWallet3.hermezEthereumAddress,\n    hermezWallet3.publicKeyBase64,\n    signature\n  )\n</code></pre> <p>We can find out if the Coordinator has been authorized to create a Hermez account on behalf of a user by:</p> <pre><code>  const authResponse = await hermez.CoordinatorAPI.getCreateAccountAuthorization(wallet3.hermezEthereumAddress)\n  console.log(authResponse)\n\n&gt;&gt;&gt;&gt;\n\n{\n  hezEthereumAddress: 'hez:0xd3B6DcfCA7Eb3207905Be27Ddfa69453625ffbf9',\n  bjj: 'hez:ct0ml6FjdUN6uGUHZ70qOq5-58cZ19SJDeldMH021oOk',\n  signature: '0x22ffc6f8d569a92c48a4e784a11a9e57b840fac21eaa7fedc9dc040c4a45d502744a35eeb0ab173234c0f687b252bd0364647bff8db270ffcdf1830257de28e41c',\n  timestamp: '2021-03-16T14:56:05.295946Z'\n}\n\n</code></pre> <p>Once we verify the receiving Ethereum account has authorized the creation of a Hermez account, we can proceed with the transfer from Bob's account to Mary's account. For this, we set the destination address to Mary's Ethereum address and set the fee using  the <code>createAccount</code> value.</p> <pre><code>  // set amount to transfer\n  const amountTransferAuth = hermez.HermezCompressedAmount.compressAmount(hermez.Utils.getTokenAmountBigInt('1.0', 18))\n  // generate L2 transaction\n  const l2AuthTxTransfer = {\n    from: infoAccountSender.accountIndex,\n    to: hermezWallet3.hermezEthereumAddress\n    amount: amountTransferAuth,\n    fee: state.recommendedFee.createAccount / usdTokenExchangeRate\n  }\n  const accountAuthTransferResponse = await hermez.Tx.generateAndSendL2Tx(l2AuthTxTransfer, hermezWallet, infoAccountSender.token)\n  console.log(accountAuthTransferResponse)\n\n&gt;&gt;&gt;&gt;&gt;\n{\n  status: 200,\n  id: '0x025398af5b69f132d8c2c5b7b225df1436baf7d1774a6b017a233bf273b4675c8f',\n  nonce: 0\n}\n\n</code></pre> <p>After the transfer has been forged, we can check Mary's account on Hermez</p> <pre><code>    // get receiver account information\n    const infoAccountAuth = (await hermez.CoordinatorAPI.getAccounts(hermezWallet3.hermezEthereumAddress, [tokenERC20.id]))\n      .accounts[0]\n    console.log(infoAccountAuth)\n\n&gt;&gt;&gt;&gt;&gt;\n\n{\n  accountIndex: 'hez:ETH:265',\n  balance: '1000000000000000',\n  bjj: 'hez:ct0ml6FjdUN6uGUHZ70qOq5-58cZ19SJDeldMH021oOk',\n  hezEthereumAddress: 'hez:0xd3B6DcfCA7Eb3207905Be27Ddfa69453625ffbf9',\n  itemId: 10,\n  nonce: 0,\n  token: {\n    USD: 1795.94,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-03-16T14:56:57.460862Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n</code></pre>"},{"location":"Hermez_1.0/developers/sdk/#create-internal-accounts","title":"Create Internal Accounts","text":"<p>Until now we have seen that accounts have an Ethereum address and a Baby JubJub key. This is the case for normal accounts. However, there is a second type of account that only requires a Baby JubJub key. These accounts are called <code>internal accounts</code>.</p> <p>The advantage of these accounts is that they are much more inexpensive to create than a <code>normal account</code>, since these accounts only exist on Hermez. The downside is that one cannot perform deposits or withdrawals from this type of account. However, there are some scenarios where these accounts are useful. For example, in those scenarios where one requires a temporary account. (for example, Exchanges could use these accounts to receive a transfer from users).</p> <pre><code>  // Create Internal Account\n  // create new bjj private key to receive user transactions\n  const pvtBjjKey = Buffer.allocUnsafe(32).fill('1')\n\n  // create rollup internal account from bjj private key\n  const wallet4 = await hermez.HermezWallet.createWalletFromBjjPvtKey(pvtBjjKey)\n  const hermezWallet4 = wallet4.hermezWallet\n\n  // set amount to transfer\n  const amountTransferInternal = hermez.HermezCompressedAmount.compressAmount(hermez.Utils.getTokenAmountBigInt('1.0', 18))\n  // generate L2 transaction\n  const transferToInternal = {\n    from: infoAccountSender.accountIndex,\n    to: hermezWallet4.publicKeyBase64,\n    amount: amountTransferInternal,\n    fee: state.recommendedFee.createAccountInternal / usdTokenExchangeRate\n  }\n  const internalAccountResponse = await hermez.Tx.generateAndSendL2Tx(transferToInternal, hermezWallet, tokenERC20)\n  console.log(internalAccountResponse)\n\n\n&gt;&gt;&gt;&gt;&gt;\n\n{\n  status: 200,\n  id: '0x02ac000f39eee60b198c85348443002991753de912337720b9ef85d48e9dcfe83e',\n  nonce: 0\n}\n</code></pre> <p>Once the transaction is forged, we can check the account information</p> <pre><code>    // get internal account information\n    const infoAccountInternal = (await hermez.CoordinatorAPI.getAccounts(hermezWallet4.publicKeyBase64, [tokenERC20.id]))\n      .accounts[0]\n    console.log(infoAccountInternal)\n\n\n&gt;&gt;&gt;&gt;&gt;&gt;\n\n{\n  accountIndex: 'hez:ETH:259',\n  balance: '1000000000000000000',\n  bjj: 'hez:KmbnR34pOUhSaaPOkeWbaeZVjMqojfyYy8sYIHRSlaKx',\n  hezEthereumAddress: 'hez:0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF',\n  itemId: 4,\n  nonce: 0,\n  token: {\n    USD: 1798.51,\n    decimals: 18,\n    ethereumAddress: '0x0000000000000000000000000000000000000000',\n    ethereumBlockNum: 0,\n    fiatUpdate: '2021-03-16T15:44:08.33507Z',\n    id: 0,\n    itemId: 1,\n    name: 'Ether',\n    symbol: 'ETH'\n  }\n}\n\n\n</code></pre> <p>We can verify it is in fact an <code>internal account</code> because the associated <code>hezEthereumAddress</code> is <code>hez:0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code>.</p>"},{"location":"Hermez_1.0/developers/coord-files/cfg.sandbox.boot-coordinator/","title":"Cfg.sandbox.boot coordinator","text":"<pre><code>#[API]\n### Url and port where the API will listen\n#Address = \"0.0.0.0:8086\"\n### Enables the Explorer API endpoints\n#Explorer = true\n### Interval between updates of the API metrics\n#UpdateMetricsInterval = \"10s\"\n### Interval between updates of the recommended fees\n#UpdateRecommendedFeeInterval = \"10s\"\n### Maximum concurrent connections allowed between API and SQL\n#MaxSQLConnections = 100\n### Maximum amount of time that an API request can wait to establish a SQL connection\n#SQLConnectionTimeout = \"2s\"\n\n[Debug]\n### If it is set, the debug api will listen in this address and port\nAPIAddress = \"0.0.0.0:12345\"\n### Enables meddler debug mode, where unused columns and struct fields will be logged\nMeddlerLogs = true\n### Sets the web framework Gin-Gonic to run in debug mode\nGinDebugMode = true\n\n[StateDB]\n### Path where the synchronizer StateDB is stored\nPath = \"/tmp/hermez/statedb\"\n### Number of checkpoints to keep\n#Keep = 256\n\n[PostgreSQL]\n## Port of the PostgreSQL write server\nPortWrite     = 5432\n## Host of the PostgreSQL write server\nHostWrite     = \"localhost\"\n## User of the PostgreSQL write server\nUserWrite     = \"hermez\"\n## Password of the PostgreSQL write server\nPasswordWrite = \"yourpasswordhere\"\n## Name of the PostgreSQL write server database\nNameWrite     = \"hermez\"\n\n[Web3]\n## Url of the web3 Ethereum-node RPC server. Only geth is officially supported\nURL = \"http://localhost:8545\"\n\n#[Synchronizer]\n### Interval between attempts to synchronize a new block from an Ethereum node\n#SyncLoopInterval = \"1s\"\n### Threshold of a number of Ethereum blocks left to synchronize, such that if there are more blocks to sync than the defined value synchronizer can aggressively skip calling UpdateEth to save network bandwidth and time. After reaching the threshold UpdateEth is called on each block. This value only affects the reported % of synchronization of blocks and batches, nothing else.\n#StatsUpdateBlockNumDiffThreshold = 100\n### While having more blocks to sync than updateEthBlockNumThreshold, UpdateEth will be called once in a defined number of blocks. This value only affects the reported % of synchronization of blocks and batches, nothing else\n#StatsUpdateFrequencyDivider = 100\n\n[SmartContracts]\n## Smart contract address of the rollup Hermez.sol\nRollup   = \"0x10465b16615ae36F350268eb951d7B0187141D3B\"\n\n\n[Coordinator]\n## Ethereum address that the Coordinator is using to forge batches\nForgerAddress = \"0xDcC5dD922fb1D0fd0c450a0636a8cE827521f0eD\" # Non-Boot Coordinator\n# ForgerAddressPrivateKey = \"0x705df2ae707e25fa37ca84461ac6eb83eb4921b653e98fdc594b60bea1bb4e52\"\n### Minimum balance the forger address needs to start the Coordinator in Wei. If it is set to 0, the Coordinator will not check the balance\n#MinimumForgeAddressBalance = \"0\"\n### Number of confirmation blocks to be sure that the tx has been mined correctly\n#ConfirmBlocks = 5\n### Portion of the range before the L1Batch timeout that will trigger a schedule to forge an L1Batch\n#L1BatchTimeoutPerc = 0.00001\n### Number of delay blocks to wait before starting the pipeline when a slot in which the Coordinator can forge is reached\n#StartSlotBlocksDelay = 0\n### Number of blocks ahead used to decide when to stop scheduling new batches\n#ScheduleBatchBlocksAheadCheck = 0\n### Number of margin blocks used to decide when to stop sending batches to the smart contract\n#SendBatchBlocksMarginCheck = 0\n### Interval between calls to the ProofServer to check the status\n#ProofServerPollInterval = \"1s\"\n### Interval between forge retries after an error\n#ForgeRetryInterval = \"10s\"\n### Interval between calls to the main handler of a synced block after an error\n#SyncRetryInterval = \"1s\"\n#Delay after which a batch is forged if the slot is already committed.  If It is set to \"0s\", the Coordinator will continuously forge at the maximum rate\nForgeDelay = \"0s\"\n### Delay after a forged batch if there are no txs to forge. If It is set to 0s, the Coordinator will continuously forge even if the batches are empty\nForgeNoTxsDelay = \"1s\"\n### Interval between calls to the PurgeByExternalDelete function of the l2db which deletes pending txs externally marked by the column `external_delete`\n#PurgeByExtDelInterval = \"1m\"\n### Enables the Coordinator to forge in slots if the empty slots reach the slot deadline\n#MustForgeAtSlotDeadline = true\n### It will make the Coordinator forge at most one batch per slot, only if there are included txs in that batch, or pending l1UserTxs in the smart contract.  Setting this parameter overrides `ForgeDelay`, `ForgeNoTxsDelay`, `MustForgeAtSlotDeadline` and `IgnoreSlotCommitment`.\n#IgnoreSlotCommitment = true\n### This parameter will make the Coordinator forge at most one batch per slot, only if there are included txs in that batch, or pending l1UserTxs in the smart contract.  Setting this parameter overrides `ForgeDelay`, `ForgeNoTxsDelay`, `MustForgeAtSlotDeadline` and `IgnoreSlotCommitment`.\n#ForgeOncePerSlotIfTxs = false\n\n[Coordinator.FeeAccount]\n## Ethereum address of the account that will receive the fees\nAddress = \"0xCfDe8f47215a147e3876efa0c059771159c4FC70\"\n# PrivateKey = \"0xfdb75ceb9f3e0a6c1721e98b94ae451ecbcb9e8c09f9fc059938cb5ab8cc8a7c\"\n## BJJ is the baby jub jub public key of the account that will receive the fees\nBJJ = \"0x1b176232f78ba0d388ecc5f4896eca2d3b3d4f272092469f559247297f5c0c13\"\n# BJJPrivateKey = \"0xb556862fb60e7cf4c0a8a7f44baf2ab06a4c90ac39decc4eef363b6142d07a34\"\n\n[Coordinator.L2DB]\n### Number of batches after which non-pending L2Txs are deleted from the pool\n#SafetyPeriod = 10\n### Maximum number of pending L2Txs that can be stored in the pool\n#MaxTxs       = 1000000\n### Minimum fee in USD that a tx must pay in order to be accepted into the pool\nMinFeeUSD    = 0.0\n### Maximum fee in USD that a tx must pay in order to be accepted into the pool\n#MaxFeeUSD    = 10.00\n### Time To Live for L2Txs in the pool. L2Txs older than TTL will be deleted.\n#TTL          = \"24h\"\n### Delay between batches to purge outdated transactions. Outdated L2Txs are those that have been forged or marked as invalid for longer than the SafetyPeriod and pending L2Txs that have been in the pool for longer than TTL once there are MaxTxs\n#PurgeBatchDelay = 10\n### Delay between batches to mark invalid transactions due to nonce lower than the account nonce\n#InvalidateBatchDelay = 20\n### Delay between blocks to purge outdated transactions. Outdated L2Txs are those that have been forged or marked as invalid for longer than the SafetyPeriod and pending L2Txs that have been in the pool for longer than TTL once there are MaxTxs.\n#PurgeBlockDelay = 10\n### Delay between blocks to mark invalid transactions due to nonce lower than the account nonce\n#InvalidateBlockDelay = 20\n\n[Coordinator.TxSelector]\n### Path where the TxSelector StateDB is stored\nPath = \"/tmp/hermez/txselector\"\n\n[Coordinator.BatchBuilder]\n### Path where the BatchBuilder StateDB is stored\nPath = \"/tmp/hermez/batchbuilder\"\n\n[Coordinator.ServerProofs]\n## Server proof API URLs\nURLs = [\"http://localhost:3000/api\"]\n\n[Coordinator.Circuit]\n## Maximum number of txs supported by the circuit\nMaxTx = 512\n## Maximum number of merkle tree levels supported by the circuit\nNLevels = 32\n\n#[Coordinator.EthClient]\n### Interval between receipt checks of Ethereum transactions in the TxManager\n#CheckLoopInterval = \"500ms\"\n### Number of attempts to do an Eth client RPC call before giving up\n#Attempts = 4\n### Delay between attempts do do an Eth client RPC call\n#AttemptsDelay = \"500ms\"\n### Timeout after which a non-mined Ethereum transaction will be resent (reusing the nonce) with a newly calculated gas price\n#TxResendTimeout = \"2m\"\n### Disables reusing nonces of pending transactions for new replacement transactions\n#NoReuseNonce = false\n### Maximum gas price allowed for Ethereum transactions in Gwei\n#MaxGasPrice = 500\n### Minimum gas price allowed for Ethereum transactions in Gwei\n#MinGasPrice = 5\n### Percentage increased of gas price set in an Ethereum transaction from the suggested gas price by the Ethereum node\n#GasPriceIncPerc = 5\n\n[Coordinator.EthClient.Keystore]\n### Path where the keystore is stored\nPath = \"/tmp/hermez/ethkeystore\"\n## Password used to decrypt the keys in the keystore\nPassword = \"yourpasswordhere\"\n\n#[Coordinator.EthClient.ForgeBatchGasCost]\n### Gas needed to forge an empty batch\n#Fixed = 900000\n### Gas needed per L1 tx\n#L1UserTx = 15000\n### Gas needed for a Coordinator L1 tx\n#L1CoordTx = 7000\n### Gas needed for an L2 tx\n#L2Tx = 600\n\n#[Coordinator.API]\n### Enables Coordinator API endpoints\n#Coordinator = true\n\n[Coordinator.Debug]\n## If this parameter is set, specifies the path where batchInfo is stored in JSON in every step/update of the pipeline\nBatchPath = \"/tmp/hermez/batchesdebug\"\n## If lightScrypt is set, uses light parameters for the Ethereum keystore encryption algorithm\nLightScrypt = false\n## RollupVerifierIndex is the index of the verifier to use in the Rollup smart contract. The verifier chosen by index must match with the Circuit parameters. Only for debug purposes. It can't be used as env variable\n# RollupVerifierIndex = 0\n\n[Coordinator.Etherscan]\n## If this parameter is set, specifies the Etherscan endpoint to get the gas estimations for that momment\nURL = \"https://api.etherscan.io\"\n## APIKey parameter allows access to Etherscan services\nAPIKey = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n\n#[RecommendedFeePolicy]\n### Strategy used to calculate the recommended fee that the API will expose.\n### Available options:\n### - Static: always return the same value (StaticValue) in USD\n### - AvgLastHour: calculate using the average fee of the forged transactions during the last hour\n### Selects the mode. \"Static\" or \"AvgLastHour\"\n#PolicyType = \"Static\"\n### If PolicyType is \"static\" defines the recommended fee value\n#StaticValue = 0.10\n</code></pre>"},{"location":"Hermez_1.0/developers/coord-files/cfg.testnet.coord/","title":"Cfg.testnet.coord","text":"<pre><code>[API]\n### Url and port where the API will listen\n#Address = \"0.0.0.0:8086\"\n### Enables the Explorer API endpoints\n#Explorer = true\n### Interval between updates of the API metrics\n#UpdateMetricsInterval = \"10s\"\n### Interval between updates of the recommended fees\n#UpdateRecommendedFeeInterval = \"10s\"\n### Maximum concurrent connections allowed between API and SQL\n#MaxSQLConnections = 100\n### Maximum amount of time that an API request can wait to establish a SQL connection\n#SQLConnectionTimeout = \"2s\"\n\n[Debug]\n### If it is set, the debug api will listen in this address and port\nAPIAddress = \"0.0.0.0:12345\"\n### Enables meddler debug mode, where unused columns and struct fields will be logged\nMeddlerLogs = true\n### Sets the web framework Gin-Gonic to run in debug mode\nGinDebugMode = true\n\n[StateDB]\n### Path where the synchronizer StateDB is stored\nPath = \"/tmp/hermez/statedb\"\n### Number of checkpoints to keep\n#Keep = 256\n\n[PostgreSQL]\n# TODO: Add user, pwd and host for pg database\n## Port of the PostgreSQL write server\nPortWrite     = 5432\n## Host of the PostgreSQL write server\nHostWrite     = \"localhost\"\n## User of the PostgreSQL write server\nUserWrite     = \"hermez\"\n## Password of the PostgreSQL write server\nPasswordWrite = \"yourpasswordhere\"\n## Name of the PostgreSQL write server database\nNameWrite     = \"hermez\"\n\n[Web3]\n## Url of the web3 Ethereum-node RPC server. Only geth is officially supported\n# TODO  - Add you Ethereum node URL here\n#URL = \"http://10.48.1.224:8545\"\n\n#[Synchronizer]\n### Interval between attempts to synchronize a new block from an Ethereum node\n#SyncLoopInterval = \"1s\"\n### Threshold of a number of Ethereum blocks left to synchronize, such that if there are more blocks to sync than the defined value synchronizer can aggressively skip calling UpdateEth to save network bandwidth and time. After reaching the threshold UpdateEth is called on each block. This value only affects the reported % of synchronization of blocks and batches, nothing else.\n#StatsUpdateBlockNumDiffThreshold = 100\n### While having more blocks to sync than updateEthBlockNumThreshold, UpdateEth will be called once in a defined number of blocks. This value only affects the reported % of synchronization of blocks and batches, nothing else\n#StatsUpdateFrequencyDivider = 100\n\n[SmartContracts]\n## Smart contract address of the rollup Hermez.sol\n#TODO  - Check that Rollup address matches the one displayed at https://api.testnet.hermez.io/v1/state\nRollup   = \"0x679b11E0229959C1D3D27C9d20529E4C5DF7997c\"\n\n\n[Coordinator]\n## Ethereum address that the Coordinator is using to forge batches\n#TODO - Add your Coordinator's Ethereum Address\n#ForgerAddress = \"0xaFd6e65bdB854732f39e2F577c67Ea6e83a4C2c2\"  # Coordinator\n### Minimum balance the forger address needs to start the Coordinator in Wei. If It is set to 0, the Coordinator will not check the balance\n#MinimumForgeAddressBalance = \"0\"\n### Number of confirmation blocks to be sure that the tx has been mined correctly\n#ConfirmBlocks = 5\n### Portion of the range before the L1Batch timeout that will trigger a schedule to forge an L1Batch\n#L1BatchTimeoutPerc = 0.00001\n### Number of delay blocks to wait before starting the pipeline when a slot in which the Coordinator can forge is reached\n#StartSlotBlocksDelay = 0\n### Number of blocks ahead used to decide when to stop scheduling new batches\n#ScheduleBatchBlocksAheadCheck = 0\n### Number of margin blocks used to decide when to stop sending batches to the smart contract\n#SendBatchBlocksMarginCheck = 0\n### Interval between calls to the ProofServer to check the status\n#ProofServerPollInterval = \"1s\"\n### Interval between forge retries after an error\n#ForgeRetryInterval = \"10s\"\n### Interval between calls to the main handler of a synced block after an error\n#SyncRetryInterval = \"1s\"\n#Delay after which a batch is forged if the slot is already committed.  If It is set to \"0s\", the Coordinator will continuously forge at the maximum rate\nForgeDelay = \"0s\"\n### Delay after a forged batch if there are no txs to forge. If It is set to 0s, the Coordinator will continuously forge even if the batches are empty\nForgeNoTxsDelay = \"1s\"\n### Interval between calls to the PurgeByExternalDelete function of the l2db which deletes pending txs externally marked by the column `external_delete`\n#PurgeByExtDelInterval = \"1m\"\n### Enables the Coordinator to forge in slots if the empty slots reach the slot deadline\n#MustForgeAtSlotDeadline = true\n### It will make the Coordinator forge at most one batch per slot, only if there are included txs in that batch, or pending l1UserTxs in the smart contract.  Setting this parameter overrides `ForgeDelay`, `ForgeNoTxsDelay`, `MustForgeAtSlotDeadline` and `IgnoreSlotCommitment`.\n#IgnoreSlotCommitment = true\n### This parameter will make the Coordinator forge at most one batch per slot, only if there are included txs in that batch, or pending l1UserTxs in the smart contract.  Setting this parameter overrides `ForgeDelay`, `ForgeNoTxsDelay`, `MustForgeAtSlotDeadline` and `IgnoreSlotCommitment`.\n#ForgeOncePerSlotIfTxs = false\n\n[Coordinator.FeeAccount]\n## Ethereum address of the account that will receive the fees\n# TODO - Add Fee account Ethereum address\n#Address = \"0xbDF0C0f0B367Ade948545140788FE2db319B7B61\"\n## BJJ is the baby jub jub public key of the account that will receive the fees\n#BJJ = \"Add Fee account internal address\" TODO\n#BJJ = \"0x8f785561426c4caa16b6b37283e6d68ef7873a2ccd3dc7eb004274189983dd60\"\n[Coordinator.L2DB]\n### Number of batches after which non-pending L2Txs are deleted from the pool\n#SafetyPeriod = 10\n### Maximum number of pending L2Txs that can be stored in the pool\n#MaxTxs       = 1000000\n### Minimum fee in USD that a tx must pay in order to be accepted into the pool\nMinFeeUSD    = 0.0\n### Maximum fee in USD that a tx must pay in order to be accepted into the pool\n#MaxFeeUSD    = 10.00\n### Time To Live for L2Txs in the pool. L2Txs older than TTL will be deleted.\n#TTL          = \"24h\"\n### Delay between batches to purge outdated transactions. Outdated L2Txs are those that have been forged or marked as invalid for longer than the SafetyPeriod and pending L2Txs that have been in the pool for longer than TTL once there are MaxTxs\n#PurgeBatchDelay = 10\n### Delay between batches to mark invalid transactions due to nonce lower than the account nonce\n#InvalidateBatchDelay = 20\n### Delay between blocks to purge outdated transactions. Outdated L2Txs are those that have been forged or marked as invalid for longer than the SafetyPeriod and pending L2Txs that have been in the pool for longer than TTL once there are MaxTxs.\n#PurgeBlockDelay = 10\n### Delay between blocks to mark invalid transactions due to nonce lower than the account nonce\n#InvalidateBlockDelay = 20\n\n[Coordinator.TxSelector]\n### Path where the TxSelector StateDB is stored\nPath = \"/tmp/hermez/txselector\"\n\n[Coordinator.BatchBuilder]\n### Path where the BatchBuilder StateDB is stored\nPath = \"/tmp/hermez/batchbuilder\"\n\n[Coordinator.ServerProofs]\n## Server proof API URLs\n# TODO - Add Prover server URL\n#URLs = [\"http://10.48.11.153:9080\"]\n\n[Coordinator.Circuit]\n## Maximum number of txs supported by the circuit\n# TODO - Check circuit size (2048/400)\nMaxTx = 2048\nNLevels = 32\n\n#[Coordinator.EthClient]\n### Interval between receipt checks of Ethereum transactions in the TxManager\n#CheckLoopInterval = \"500ms\"\n### Number of attempts to do an Eth client RPC call before giving up\n#Attempts = 4\n### Delay between attempts do do an Eth client RPC call\n#AttemptsDelay = \"500ms\"\n### Timeout after which a non-mined Ethereum transaction will be resent (reusing the nonce) with a newly calculated gas price\n#TxResendTimeout = \"2m\"\n### Disables reusing nonces of pending transactions for new replacement transactions\n#NoReuseNonce = false\n### Maximum gas price allowed for Ethereum transactions in Gwei\n#MaxGasPrice = 500\n### Minimum gas price allowed for Ethereum transactions in Gwei\n#MinGasPrice = 5\n### Percentage increased of gas price set in an Ethereum transaction from the suggested gas price by the Ethereum node\n#GasPriceIncPerc = 5\n\n[Coordinator.EthClient.Keystore]\n### Path where the keystore is stored\nPath = \"/home/ubuntu/keystore\"\n## Password used to decrypt the keys in the keystore\nPassword = \"yourpasswordhere\"\n\n#[Coordinator.EthClient.ForgeBatchGasCost]\n### Gas needed to forge an empty batch\n#Fixed = 900000\n### Gas needed per L1 tx\n#L1UserTx = 15000\n### Gas needed for a Coordinator L1 tx\n#L1CoordTx = 7000\n### Gas needed for an L2 tx\n#L2Tx = 600\n\n#[Coordinator.API]\n### Enables Coordinator API endpoints\n#Coordinator = true\n\n[Coordinator.Debug]\n## If this parameter is set, specifies the path where batchInfo is stored in JSON in every step/update of the pipeline\nBatchPath = \"/tmp/hermez/batchesdebug\"\n## If lightScrypt is set, uses light parameters for the Ethereum keystore encryption algorithm\nLightScrypt = false\n## RollupVerifierIndex is the index of the verifier to use in the Rollup smart contract. The verifier chosen by index must match with the Circuit parameters. Only for debug purposes. It can't be used as env variable\n#RollupVerifierIndex = 0\n\n[Coordinator.Etherscan]\n## If this parameter is set, specifies the Etherscan endpoint to get the gas estimations for that momment\nURL = \"https://api.etherscan.io\"\n## APIKey parameter allows access to Etherscan services\n# TODO - Set true API Key\nAPIKey = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n\n#[RecommendedFeePolicy]\n# Strategy used to calculate the recommended fee that the API will expose.\n# Available options:\n# - Static: always return the same value (StaticValue) in USD\n# - AvgLastHour: calculate using the average fee of the forged transactions during the last hour\n### Selects the mode. \"Static\" or \"AvgLastHour\"\n#PolicyType = \"Static\"\n### If PolicyType is \"static\" defines the recommended fee value\n#StaticValue = 0.10\n</code></pre>"},{"location":"Hermez_1.0/developers/coord-files/docker-compose.sandbox/","title":"Docker compose.sandbox","text":"<pre><code>version: \"3.3\"\nservices:\n  hermez-db-test:\n    image: postgres\n    ports:\n      - \"5432:5432\"\n    environment:\n      POSTGRES_USER: \"hermez\"\n      POSTGRES_PASSWORD: \"yourpasswordhere\"\n  privatebc:\n    image:  public.ecr.aws/r7d5k1t8/hermez-geth:latest\n    ports:\n      - \"8545:8545\"\n    environment:\n      - DEV_PERIOD\n    entrypoint: [\"geth\", \"--http\", \"--http.addr\", \"0.0.0.0\",\"--http.corsdomain\",\n      \"*\", \"--http.vhosts\" ,\"*\", \"--ws\", \"--ws.origins\", \"*\", \"--ws.addr\", \"0.0.0.0\",\n      \"--dev\", \"--datadir\", \"/geth_data$DEV_PERIOD\"]\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/","title":"Forging Consensus Protocol","text":"<p>Hermez will run an auction to incentivize the efficiency of coordinators, meaning that they need to be very effective and include as many transactions as they can in the slots in order to compensate for their bidding costs, gas costs and operations costs.</p> <p>The general purpose of this protocol is to describe the rules to coordinate the auction where the bids will be placed only in HEZ utility token.</p>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/#general-goals","title":"General Goals","text":"<ul> <li>Select a single coordinator for a given slot to forge a batch</li> <li>Avoid stops of ZK-Rollup</li> <li>Incentivize coordinators to participate in the ZK-Rollup</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/#scenario","title":"Scenario","text":"<ul> <li>ZK-Rollup is divided into slots of a certain duration:</li> <li>Ethereum Block = ~ 15s</li> <li>Slot = 40 Ethereum Blocks = 40 * 15s = 600s = 10 min</li> <li>Slot deadline = 20</li> </ul> <p>Note: The number of blocks per slot is a parameter that is hardcoded on the smart contracts, so in order to change this parameter we need to make an upgrade on consensus smart contracts</p>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/#auction","title":"Auction","text":"<p>Bids in the Auction will be placed only in HEZ. The auction of future slots will be open up to 1 month (system parameter), the opening is a sliding window that opens a new slot every 40 blocks.</p> <p>Auction will be closed 2 slots (system parameter) before the start time of the forging in the slot.</p> <p>A bid will not pay a premium on top of the previous bid, but a bid placed in the auction should be at least 1.1 times (system parameter) the previous bid or over the minimum bidding price (if it's the first one) to be accepted as valid.</p> <p>Auction will be structured in series of 6 slots <code>slots[5]</code>, with 10 HEZ as initial minimal bidding price for all the slots. The governance can change this value <code>slots[i]</code> independently at any time and affecting open auctions, in such a way that all the slots whose <code>slot % 6 = i</code> will have the same minimum bid. Bids under the new minimal bidding price will not be considered as valid bids anymore and bidders (if no new bids outbid theirs) will be sent back their HEZ in the event that the slot is fully processed (forge).</p> <p>When a slot number in the series gets 0 HEZ value, it will be locked and governance will not be able to modify the minimal bidding price anymore, so it will become decentralized.</p> <p></p> <p></p>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/#hez-token-bidding-allocation","title":"HEZ Token Bidding Allocation","text":"<p>In the moment of placement, all bids in form of HEZ token placed in the auction will be stored in the smart contract, and will pay the gas to send the previous bidder their HEZ back.</p> <p>Once the slot is forged, the tokens are assigned to three different accounts:</p> <ul> <li>A part of the tokens will be burnt. So they will not be at 0x0 address, but reduced from the total token amount.</li> <li>A part will be assigned to the donations account. Governance process will decide how to allocate these funds into different projects.</li> <li>The rest will be allocated as Hermez Network usage incentives, compensating active engagement and network adoption, e.g. rewarding transaction and rewarding the holding of specific tokens in Hermez L2 addresses, instead of on L1 Ethereum addresses.</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/#boot-coordinator","title":"Boot Coordinator","text":"<p>This element has the mission to support the network bootstrap and at some moment will disappear when the network gains traction. Removal of the boot coordinator will be a governance decision.</p> <p>Basically, its role is to forge any slot where there is no winner in the auction without the need to make a bid.</p>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/#free-coordinator-override","title":"Free Coordinator Override","text":"<p>There is a situation where any coordinator can forge batches without bidding.</p> <p>This happens when the coordinator of the current slot doesn't forge any batch in the N first available inside the slot.</p> <p>This mechanism responds to the need of the network for the efficiency of coordinators, and cover from potential technical problems or attacks.</p> <p>It also provides a guarantee to users that all funds will be recoverable from the L2 network because there is a deadline after which a batch MUST include L1 pending transactions, which includes L2 (funds) exit operations.</p>"},{"location":"Hermez_1.0/developers/protocol/consensus/consensus/#system-parameters","title":"System Parameters","text":"<ul> <li>slotDeadline</li> <li>Number of blocks after the beginning of a slot after which any coordinator can forge if the winner has not forged any batch in that slot</li> <li>Default Value: 20</li> <li>closedAuctionSlots</li> <li>Distance (#slots) to the closest slot to which you can bid</li> <li>Default value: 2 (2 Slots = 2 * 40 Blocks = 2 * 40 * 15s = 20 min )</li> <li>openAuctionSlots</li> <li>Distance (#slots) to the farthest slot to which you can bid</li> <li>Default value: 4320 slots (30 days)</li> <li>INITIAL_MINIMAL_BIDDING</li> <li>Minimum bid when no one has bid yet</li> <li>Default value: 10 * (1e18)</li> <li>outbidding</li> <li>Minimum outbid (percentage, two decimal precision) over the previous one to consider it valid</li> <li>Default value: 1000</li> <li>donationAddress</li> <li>Default value: Pending to be defined</li> <li>governanceAddress</li> <li>Default value: Pending to be defined</li> <li>bootCoordinator</li> <li>Default value: Pending to be defined</li> <li>ALLOCATION_RATIO</li> <li>How the HEZ tokens deposited by the slot winner are distributed</li> <li>Default values: Burn: 40.00% - Donation: 40.00% - HGT: 20.00%</li> </ul> <p>Note: All this parameters are managed by the governance, this means that they can change it at any time without any delay</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/fee-table/","title":"Transaction Fee Table","text":"<p>Fees in L2 transaction apply a factor encoded by an index, as shown in the table above and the formula below:</p> <p>\\(0 \\quad \\text{ if } i = 0\\)</p> <p>\\(2^{-60 + i\u00b7(\\frac{-8-(-60)}{32})} \\quad \\text{if} \\quad 1 \\leq i \\leq 31\\)</p> <p>\\(2^{-8 + (i-32)\u00b7(\\frac{0-(-8)}{160})} \\quad \\text{if} \\quad 32 \\leq i \\leq 191\\)</p> <p>\\(2^{(i-192)\u00b7(\\frac{63-0}{63})} \\quad \\text{if} \\quad 192 \\leq i \\leq 255\\)</p> <p>This is the complete table of the fees factors by fee index:</p> feeIndex feeExponent feeFactor 0 0 0,00E+00 1 -58,375 2,68E-18 2 -56,75 8,25E-18 3 -55,125 2,55E-17 4 -53,5 7,85E-17 5 -51,875 2,42E-16 6 -50,25 7,47E-16 7 -48,625 2,30E-15 8 -47 7,11E-15 9 -45,375 2,19E-14 10 -43,75 6,76E-14 11 -42,125 2,09E-13 12 -40,5 6,43E-13 13 -38,875 1,98E-12 14 -37,25 6,12E-12 15 -35,625 1,89E-11 16 -34 5,82E-11 17 -32,375 1,80E-10 18 -30,75 5,54E-10 19 -29,125 1,71E-09 20 -27,5 5,27E-09 21 -25,875 1,62E-08 22 -24,25 5,01E-08 23 -22,625 1,55E-07 24 -21 4,77E-07 25 -19,375 1,47E-06 26 -17,75 4,54E-06 27 -16,125 1,40E-05 28 -14,5 4,32E-05 29 -12,875 1,33E-04 30 -11,25 4,11E-04 31 -9,625 1,27E-03 32 -8 3,91E-03 33 -7,95 4,04E-03 34 -7,9 4,19E-03 35 -7,85 4,33E-03 36 -7,8 4,49E-03 37 -7,75 4,65E-03 38 -7,7 4,81E-03 39 -7,65 4,98E-03 40 -7,6 5,15E-03 41 -7,55 5,34E-03 42 -7,5 5,52E-03 43 -7,45 5,72E-03 44 -7,4 5,92E-03 45 -7,35 6,13E-03 46 -7,3 6,35E-03 47 -7,25 6,57E-03 48 -7,2 6,80E-03 49 -7,15 7,04E-03 50 -7,1 7,29E-03 51 -7,05 7,55E-03 52 -7 7,81E-03 53 -6,95 8,09E-03 54 -6,9 8,37E-03 55 -6,85 8,67E-03 56 -6,8 8,97E-03 57 -6,75 9,29E-03 58 -6,7 9,62E-03 59 -6,65 9,96E-03 60 -6,6 1,03E-02 61 -6,55 1,07E-02 62 -6,5 1,10E-02 63 -6,45 1,14E-02 64 -6,4 1,18E-02 65 -6,35 1,23E-02 66 -6,3 1,27E-02 67 -6,25 1,31E-02 68 -6,2 1,36E-02 69 -6,15 1,41E-02 70 -6,1 1,46E-02 71 -6,05 1,51E-02 72 -6 1,56E-02 73 -5,95 1,62E-02 74 -5,9 1,67E-02 75 -5,85 1,73E-02 76 -5,8 1,79E-02 77 -5,75 1,86E-02 78 -5,7 1,92E-02 79 -5,65 1,99E-02 80 -5,6 2,06E-02 81 -5,55 2,13E-02 82 -5,5 2,21E-02 83 -5,45 2,29E-02 84 -5,4 2,37E-02 85 -5,35 2,45E-02 86 -5,3 2,54E-02 87 -5,25 2,63E-02 88 -5,2 2,72E-02 89 -5,15 2,82E-02 90 -5,1 2,92E-02 91 -5,05 3,02E-02 92 -5 3,13E-02 93 -4,95 3,24E-02 94 -4,9 3,35E-02 95 -4,85 3,47E-02 96 -4,8 3,59E-02 97 -4,75 3,72E-02 98 -4,7 3,85E-02 99 -4,65 3,98E-02 100 -4,6 4,12E-02 101 -4,55 4,27E-02 102 -4,5 4,42E-02 103 -4,45 4,58E-02 104 -4,4 4,74E-02 105 -4,35 4,90E-02 106 -4,3 5,08E-02 107 -4,25 5,26E-02 108 -4,2 5,44E-02 109 -4,15 5,63E-02 110 -4,1 5,83E-02 111 -4,05 6,04E-02 112 -4 6,25E-02 113 -3,95 6,47E-02 114 -3,9 6,70E-02 115 -3,85 6,93E-02 116 -3,8 7,18E-02 117 -3,75 7,43E-02 118 -3,7 7,69E-02 119 -3,65 7,97E-02 120 -3,6 8,25E-02 121 -3,55 8,54E-02 122 -3,5 8,84E-02 123 -3,45 9,15E-02 124 -3,4 9,47E-02 125 -3,35 9,81E-02 126 -3,3 1,02E-01 127 -3,25 1,05E-01 128 -3,2 1,09E-01 129 -3,15 1,13E-01 130 -3,1 1,17E-01 131 -3,05 1,21E-01 132 -3 1,25E-01 133 -2,95 1,29E-01 134 -2,9 1,34E-01 135 -2,85 1,39E-01 136 -2,8 1,44E-01 137 -2,75 1,49E-01 138 -2,7 1,54E-01 139 -2,65 1,59E-01 140 -2,6 1,65E-01 141 -2,55 1,71E-01 142 -2,5 1,77E-01 143 -2,45 1,83E-01 144 -2,4 1,89E-01 145 -2,35 1,96E-01 146 -2,3 2,03E-01 147 -2,25 2,10E-01 148 -2,2 2,18E-01 149 -2,15 2,25E-01 150 -2,1 2,33E-01 151 -2,05 2,41E-01 152 -2 2,50E-01 153 -1,95 2,59E-01 154 -1,9 2,68E-01 155 -1,85 2,77E-01 156 -1,8 2,87E-01 157 -1,75 2,97E-01 158 -1,7 3,08E-01 159 -1,65 3,19E-01 160 -1,6 3,30E-01 161 -1,55 3,42E-01 162 -1,5 3,54E-01 163 -1,45 3,66E-01 164 -1,4 3,79E-01 165 -1,35 3,92E-01 166 -1,3 4,06E-01 167 -1,25 4,20E-01 168 -1,2 4,35E-01 169 -1,15 4,51E-01 170 -1,1 4,67E-01 171 -1,05 4,83E-01 172 -1 5,00E-01 173 -0,95 5,18E-01 174 -0,9 5,36E-01 175 -0,85 5,55E-01 176 -0,8 5,74E-01 177 -0,75 5,95E-01 178 -0,7 6,16E-01 179 -0,65 6,37E-01 180 -0,6 6,60E-01 181 -0,55 6,83E-01 182 -0,5 7,07E-01 183 -0,45 7,32E-01 184 -0,4 7,58E-01 185 -0,35 7,85E-01 186 -0,3 8,12E-01 187 -0,25 8,41E-01 188 -0,2 8,71E-01 189 -0,15 9,01E-01 190 -0,1 9,33E-01 191 -0,05 9,66E-01 192 0 1,00E+00 193 1 2,00E+00 194 2 4,00E+00 195 3 8,00E+00 196 4 1,60E+01 197 5 3,20E+01 198 6 6,40E+01 199 7 1,28E+02 200 8 2,56E+02 201 9 5,12E+02 202 10 1,02E+03 203 11 2,05E+03 204 12 4,10E+03 205 13 8,19E+03 206 14 1,64E+04 207 15 3,28E+04 208 16 6,55E+04 209 17 1,31E+05 210 18 2,62E+05 211 19 5,24E+05 212 20 1,05E+06 213 21 2,10E+06 214 22 4,19E+06 215 23 8,39E+06 216 24 1,68E+07 217 25 3,36E+07 218 26 6,71E+07 219 27 1,34E+08 220 28 2,68E+08 221 29 5,37E+08 222 30 1,07E+09 223 31 2,15E+09 224 32 4,29E+09 225 33 8,59E+09 226 34 1,72E+10 227 35 3,44E+10 228 36 6,87E+10 229 37 1,37E+11 230 38 2,75E+11 231 39 5,50E+11 232 40 1,10E+12 233 41 2,20E+12 234 42 4,40E+12 235 43 8,80E+12 236 44 1,76E+13 237 45 3,52E+13 238 46 7,04E+13 239 47 1,41E+14 240 48 2,81E+14 241 49 5,63E+14 242 50 1,13E+15 243 51 2,25E+15 244 52 4,50E+15 245 53 9,01E+15 246 54 1,80E+16 247 55 3,60E+16 248 56 7,21E+16 249 57 1,44E+17 250 58 2,88E+17 251 59 5,76E+17 252 60 1,15E+18 253 61 2,31E+18 254 62 4,61E+18 255 63 9,22E+18"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/fee-table/#feefactor-left-shifted","title":"FeeFactor left shifted","text":"<p>Fee factor is shifted according:   - \\(\\text{bitsShiftPrecision} = 60\\)   - \\(\\text{feeFactorShifted} = (\\text{feeFactor} &lt;&lt; \\text{bitsShiftPrecison}) \\quad \\text{if} \\quad i &lt; 192\\)   - \\(\\text{feeFactorShifted} = \\text{feeFactor} \\quad \\text{if} \\quad i \\geq 192\\)</p> feeIndex feeFactorShifted 0 0 1 3 2 9 3 29 4 90 5 279 6 861 7 2655 8 8192 9 25267 10 77935 11 240387 12 741455 13 2286960 14 7053950 15 21757357 16 67108864 17 206992033 18 638450708 19 1969251187 20 6074000999 21 18734780191 22 57785961645 23 178236271212 24 549755813888 25 1695678735018 26 5230188203117 27 16132105731538 28 49758216191607 29 153475319327371 30 473382597799226 31 1460111533771401 32 4503599627370496 33 4662418725241772 34 4826838566504035 35 4997056660946426 36 5173277483525749 37 5355712719992597 38 5544581521179432 39 5740110766256133 40 5942535335269230 41 6152098391292193 42 6369051672525772 43 6593655794699191 44 6826180564135515 45 7066905301857248 46 7316119179121470 47 7574121564787630 48 7841222384935199 49 8117742495163242 50 8404014066019092 51 8700380982019120 52 9007199254740992 53 9324837450483544 54 9653677133008070 55 9994113321892852 56 10346554967051498 57 10711425439985194 58 11089163042358864 59 11480221532512266 60 11885070670538460 61 12304196782584386 62 12738103345051544 63 13187311589398382 64 13652361128271030 65 14133810603714496 66 14632238358242940 67 15148243129575260 68 15682444769870398 69 16235484990326484 70 16808028132038184 71 17400761964038240 72 18014398509481984 73 18649674900967100 74 19307354266016140 75 19988226643785704 76 20693109934102996 77 21422850879970388 78 22178326084717744 79 22960443065024532 80 23770141341076920 81 24608393565168772 82 25476206690103088 83 26374623178796784 84 27304722256542060 85 28267621207428992 86 29264476716485880 87 30296486259150520 88 31364889539740816 89 32470969980652968 90 33616056264076368 91 34801523928076480 92 36028797018963968 93 37299349801934200 94 38614708532032280 95 39976453287571408 96 41386219868205992 97 42845701759940776 98 44356652169435488 99 45920886130049064 100 47540282682153840 101 49216787130337544 102 50952413380206176 103 52749246357593568 104 54609444513084120 105 56535242414857984 106 58528953432971760 107 60592972518301040 108 62729779079481632 109 64941939961305936 110 67232112528152736 111 69603047856152960 112 72057594037927936 113 74598699603868352 114 77229417064064608 115 79952906575142816 116 82772439736411984 117 85691403519881552 118 88713304338870912 119 91841772260098192 120 95080565364307680 121 98433574260675088 122 101904826760412352 123 105498492715187056 124 109218889026168304 125 113070484829715968 126 117057906865943520 127 121185945036602080 128 125459558158963264 129 129883879922611968 130 134464225056305472 131 139206095712305920 132 144115188075855872 133 149197399207736800 134 154458834128129216 135 159905813150285632 136 165544879472823968 137 171382807039763104 138 177426608677741952 139 183683544520196384 140 190161130728615360 141 196867148521350176 142 203809653520824704 143 210996985430374272 144 218437778052336608 145 226140969659431936 146 234115813731887040 147 242371890073204160 148 250919116317926528 149 259767759845223936 150 268928450112610944 151 278412191424611840 152 288230376151711744 153 298394798415473600 154 308917668256258432 155 319811626300571264 156 331089758945647936 157 342765614079526208 158 354853217355483904 159 367367089040392768 160 380322261457230720 161 393734297042700352 162 407619307041649408 163 421993970860748544 164 436875556104673216 165 452281939318863872 166 468231627463774080 167 484743780146408320 168 501838232635853056 169 519535519690447872 170 537856900225221888 171 556824382849223680 172 576460752303423488 173 596789596830947200 174 617835336512516864 175 639623252601142528 176 662179517891295872 177 685531228159052416 178 709706434710967808 179 734734178080785536 180 760644522914461440 181 787468594085400704 182 815238614083298816 183 843987941721497088 184 873751112209346432 185 904563878637727744 186 936463254927548160 187 969487560292816640 188 1003676465271706112 189 1039071039380895744 190 1075713800450443776 191 1113648765698447360 192 1 193 2 194 4 195 8 196 16 197 32 198 64 199 128 200 256 201 512 202 1024 203 2048 204 4096 205 8192 206 16384 207 32768 208 65536 209 131072 210 262144 211 524288 212 1048576 213 2097152 214 4194304 215 8388608 216 16777216 217 33554432 218 67108864 219 134217728 220 268435456 221 536870912 222 1073741824 223 2147483648 224 4294967296 225 8589934592 226 17179869184 227 34359738368 228 68719476736 229 137438953472 230 274877906944 231 549755813888 232 1099511627776 233 2199023255552 234 4398046511104 235 8796093022208 236 17592186044416 237 35184372088832 238 70368744177664 239 140737488355328 240 281474976710656 241 562949953421312 242 1125899906842624 243 2251799813685248 244 4503599627370496 245 9007199254740992 246 18014398509481984 247 36028797018963968 248 72057594037927936 249 144115188075855872 250 288230376151711744 251 576460752303423488 252 1152921504606846976 253 2305843009213693952 254 4611686018427387904 255 9223372036854775808"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/","title":"Hermez ZK-Rollup Protocol","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#overview","title":"Overview","text":"<p>The core protocol ensures that state transitions are valid through a validity proof which will assure that certain rules have been fulfilled. This collection of rules are determined by a smart contract which will validate a proof of state transition. This verification will check that each state transitioning is made correctly. This is achieved by using a ZK-SNARK circuit and it will make sure that all rules for state transition are being followed. Any prover must submit a proof in order to demonstrate the correctness of the state transition computation.</p> <p>A prover (aka coordinator) is in charge of computing all state changes and calculating the ZK-SNARK proof. The coordinator will be in charge of submitting the ZK-SNARK to the verifier (smart contract) which will ensure state transition validation.</p> <p></p> <p>A sparse-Merkle-tree is used to keep the state data where all accounts and balances are stored. This information is kept on L2 and users will sign transactions in order to spend their balances between L2 accounts. These L2 transactions are collected together to create a batch. Afterward, batch data is compressed through a ZK-SNARK and it will prove that the state transitions of all those L2 transactions are correct.</p> <p>This collection of transactions are made public on L1 in order to provide data-availability to the protocol, meaning that anyone can re-build the L2 state just depending on L1 data. Hence, there is no need to rely on third parties to provide or store this data.</p> <p>The system is composed of L1 and L2 transactions: - L1 transactions are the ones that are executed through the smart contract and affect the L2 state tree - L2 transactions are the ones that are executed exclusively on L2 and affect the L2 state tree</p> <p></p> <p>L1 transactions are forced to be executed by the coordinator in the protocol. Therefore, these kinds of transactions will be always forged at some time. L2 transactions are generated off-chain by the users and they are sent to the coordinators. Coordinators will be in charge of gathering them.</p> <p>Some of the rollup functionality depends on a consensus mechanism to decide who can be the coordinator of a given batch.  Separate from the rollup smart contract (which mainly handles the queue of L1UserTxs and the forging of batches), there is an external smart contract that implements the consensus mechanism and maintains its own state.  During a forge call in the rollup smart contract, a call is made to the consensus smart contract to validate if the caller coordinator is allowed to forge and also to allow the consensus smart contract to update its own state and perform consensus actions if necessary.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#assumptions","title":"Assumptions","text":"<ul> <li>L1 (Ethereum):</li> <li>integrity and immutability of data</li> <li>Hashes</li> <li><code>Poseidon</code> is unbreakable and collision-resistant</li> <li><code>SHA256</code> is unbreakable and collision-resistant</li> <li>Elliptic curves:</li> <li>L1:<ul> <li><code>secp256k1</code></li> <li>signature scheme is <code>ecdsa</code></li> </ul> </li> <li>L2:<ul> <li><code>BabyJubjub</code></li> <li>signature scheme is <code>eddsa</code></li> </ul> </li> <li>State tree transitions are always valid</li> <li>L1 transactions are forced to be processed</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#notation","title":"Notation","text":"<ul> <li><code>H</code>: is the poseidon hash function</li> <li>elements are always encoded in big endian</li> </ul> <p>Big endian encoding is used since it fits better with EVM encoding</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#field-element","title":"Field Element","text":"<ul> <li>the value encoded in a field element must be smaller than the field order</li> <li>first value corresponds to a less significant part of the field</li> </ul> <pre><code>dataField:  [16 bits] tokenID\n            [16 bits] nonce\n            [1 bit  ] sign\n</code></pre> <p>Example: <code>dataFieldExample: [16 bits] tokenID = 5                   [16 bits] nonce = 4                   [1 bit  ] sign = 1 dataFieldExample (large integer) = 4295229445; dataFieldExample (hexadecimal padded 32 bytes) = 0x0000000000000000000000000000000000000000000000000000000100040005;</code></p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#buffer-bytes","title":"Buffer Bytes","text":"<ul> <li>first value corresponds to the first byte of the array</li> </ul> <pre><code>dataBuffer: [48 bits] fromIdx\n            [32 bits] tokenID\n            [16 bit ] amountFloat\n</code></pre> <p>Example: <code>dataBufferExample:  [48 bits] fromIdx = 5                     [32 bits] tokenID = 4                     [16 bit ] amountFloat = 20 dataBufferExample (hexadecimal) = 0x000000000005000000040014;</code></p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#global-settings","title":"Global Settings","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#circuit","title":"Circuit","text":"<ul> <li><code>MAX_NLEVELS</code>: absolute maximum of Merkle tree depth (48 bits)</li> <li>determines the maximum number of accounts that can exist in the ZK-Rollup: \\(MAX\\_ACCOUNTS=2^{MAX\\_NLEVELS}\\)</li> <li><code>MAX_TX</code>: absolute maximum L1 or L2 transactions allowed to process in one batch</li> <li><code>MAX_L1_TXS</code>: absolute maximum of L1 transactions allowed to process in one batch</li> <li><code>MAX_FEE_TX</code>: maximum number of tokens that the coordinator is able to collect fees from in a batch from the included transactions</li> <li><code>NLevels</code>: Merkle tree depth</li> <li>It should be noted that <code>NLevels</code> is always a multiple of 8</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#contracts","title":"Contracts","text":"<ul> <li><code>MAX_L1_USER_TXS</code>: absolute maximum of L1 user transactions allowed to be queued for a batch</li> <li><code>MAX_AMOUNT_DEPOSIT</code>: maximum amount of tokens that can be added when creating a new account</li> <li><code>INITIAL_IDX</code>: first Merkle tree index to populate if a new account is created</li> <li>Some indexes are reserved in order to specify special transactions<ul> <li><code>IDX 0</code>: null index</li> <li><code>IDX 1</code>: exit</li> <li><code>2 &lt;= IDX &lt; 256</code>: reserved Idx values for future uses</li> <li><code>256 &lt;= IDX &lt; 2^MAX_NLEVELS</code>: available Idx values for rollup accounts</li> </ul> </li> <li><code>MAX_TOKENS</code>: maximum amount of tokens allowed to be registered in the ZK-Rollup</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#data-types","title":"Data Types","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#floating-point-format-float40","title":"Floating Point Format (Float40)","text":"<p>A custom floating point, 40 bits, codification internally called Float40 has been adopted to encode large integers. This is done in order to save bits when L2 transactions are published.</p> <p>Formula is as follows:</p> <p>\\(v = m \\times 10^e\\)</p> <p>where: - <code>v</code>: large integer value to encode - <code>m</code>: mantissa (35 bits) - <code>e</code>: exponent (5 bits)</p> <p>bit position:</p> <pre><code>[   e    |    m   ]\n[ 5 bits | 35 bits]\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#account","title":"Account","text":"<ul> <li><code>idx</code>: integer, path in the sparse Merkle tree (NLevels bits)</li> <li><code>sign</code>: Baby Jubjub sign (1 bit)</li> <li><code>ay</code>: Baby Jubjub public key Y coordinate (253 bits)</li> <li><code>ethAddr</code>: Ethereum address (160 bits)</li> <li><code>tokenID</code>: token identifier (32 bits)</li> <li><code>balance</code>: balance (192 bits)</li> <li><code>nonce</code>: nonce (40 bits)</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#transaction-fields","title":"Transaction Fields","text":"<p>All transactions fields are required to build the ZK-SNARK proof but depending on the transaction type not all of them are used. Detailed transaction types can be seen in transaction type section Below is a summary of each transaction field and its explaination:</p> <ul> <li><code>signature_constant</code>: hardcoded transaction constant that indicates that the user is signing a Hermez rollup transaction. Used to avoid transaction replay in case other rollup are deployed (32 bits)</li> </ul> <pre><code>signature_constant = sha256(\"I authorize this hermez rollup transaction\")[:32/8]\n</code></pre> <ul> <li><code>chainId</code>: Ethereum chain identifier in order to prevent replay attacks in case of hardforks, we use only 2 bytes since Hermez is only expected to be deployed in the Ethereum mainnet or one of its tesnets, so only 2 bytes are needed (16 bits)</li> <li><code>amountFloat40</code>: number of tokens to transfer inside the ZK-Rollup (40 bits)</li> <li><code>tokenID</code>: token identifier (32 bits)</li> <li><code>nonce</code>: nonce (40 bits)</li> <li><code>feeSelector</code>: select %fee to apply (8 bits)</li> <li><code>maxNumBatch</code>: maximum allowed batch number when the transaction can be processed (32 bits)</li> <li><code>onChain</code>: mark transaction as L1 transaction (1 bit)</li> <li><code>newAccount</code>: mark transaction to create new account (1 bit)</li> <li><code>fromIdx</code>: sender account index (NLevels bits)</li> <li><code>fromBjjCompressed</code>: sender Baby Jubjub public key compressed (256 bits)</li> <li><code>fromEthAddr</code>: sender Ethereum address (160 bits)</li> <li><code>toIdx</code>: recipient account index (NLevels bits)</li> <li><code>toEthAddr</code>: recipient Ethereum address (160 bits)</li> <li><code>toBjjSign</code>: recipient Baby Jubjub sign (1 bits)</li> <li><code>toAy</code>: recipient Baby Jubjub public key Y coordinate (253 bits)</li> <li><code>loadAmountFloat40</code>: L1 amount transfered to L2 (40 bits)</li> <li><code>txCompressedData</code>: transaction fields joined together that fit into a single field element (253 bits) See L2Tx specification</li> <li><code>txCompressedDataV2</code>: transaction fields joined together used for other transactions when using atomic transactions feature (193 bits) See L2Tx specification</li> <li><code>rqOffset</code>: relative transaction position to be linked. Used to perform atomic transactions (3 bits)</li> <li><code>rqTxCompressedDataV2</code>: requested <code>txCompressedDataV2</code></li> <li><code>rqToEthAddr</code>: requested <code>toEthAddr</code></li> <li><code>rqToBjjAy</code>: requested <code>toBjj</code></li> </ul> <p>Fields to perform atomic transactions: - <code>rqTxCompressedDataV2</code> - <code>rqToEthAddr</code> - <code>rqToBjjAy</code> - <code>rqOffset</code></p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#trees","title":"Trees","text":"<ul> <li>It is assured by protocol a unique <code>idx</code> for each account. Therefore, a given <code>idx</code> identifies uniquely a ZK-Rollup account</li> <li><code>idx</code> is incremented sequentially and it is assured by protocol</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#state-tree","title":"State tree","text":"<p>Sparse Merkle tree is used to represent the whole ZK-Rollup state which is identified by its root. Each leaf of the state tree (account) contains the following data:</p> <ul> <li>Key: Merkle tree index (<code>idx</code>)</li> <li> <p>Value: <code>Hash(state)</code>     ```     field element notation     State hash = H(e0, e1, e2, e3)</p> <p>e_0: [ 32 bits  ] tokenID      [ 40 bits  ] nonce      [  1 bit   ] sign e_1: [ 192 bits ] balance e_2: [ 253 bits ] ay e_3: [ 160 bits ] ethAddr ```</p> </li> </ul> <p>All data is hashed with Poseidon hash function and inserted into the sparse Merkle tree as a key-value pair.</p> <p>This approach implies a balanced Merkle tree: path is traversed from the root starting with the least significant bit out of the NLevels bits. This allows to have as many accounts as the tree levels:</p> <p>\\(MAX\\_ACCOUNTS\\) = \\(2^{MAX\\_NLEVELS}\\)</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#exit-tree","title":"Exit Tree","text":"<p>Each batch would have an associated exit tree with all the exits performed by the user, either L1 or L2 exit transactions. The exit tree has the same leaf structure as the state tree with some particularities: - nonce is always set to 0 - if several exits are done in the same batch for the same account, the balance is just added on top of the account</p> <p>User will need to prove that it owns a leaf in the exit tree in order to perform its withdraw and get back the tokens from the contract. This verification could be done either by submitting a Merkle tree proof or by submitting a ZK Proof.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#account-types","title":"Account Types","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#regular-rollup-account","title":"Regular Rollup Account","text":"<p>Regular accounts contain an Ethereum address and a Baby Jubjub public key.  Accounts are always indexed by Ethereum address in the UX, so it is a requirement that the Ethereum address authorizes the account keys.  Once the account is created, the Ethereum key is used to authorize L1 txs and the Baby Jubjub key is used to authorize L2 txs. There are two ways to authorize an account creation (that is, an Ethereum address authorizes the creation of an account containing that same Ethereum address and a Baby Jubjub public key): - Via Ethereum transaction, which has an implicit signature of the Ethereum address.  This requires the owner of the Ethereum address to sign the smart contract transaction call - Via an authorization signature (<code>AccountCreationAuthSig</code>) that can be used by any party to create accounts on behalf of the user</p> <p><code>AccountCreationAuthSig</code> specification (follows ethereum eip712):</p> <pre><code>domain: {\n  name: \"Hermez Network\",\n  version: \"1\",\n  chainId: chainID,\n  verifyingContract: rollupContractAddress\n}\n\nstructured typed data: {\n  Authorise: [\n      { name: \"Provider\", type: \"string\" },\n      { name: \"Authorisation\", type: \"string\" },\n      { name: \"BJJKey\", type: \"bytes32\" }\n  ]\n}\n\nstructured data: {\n  Provider: \"Hermez Network\",\n  Authorisation: \"Account creation\",\n  BJJKey: compressed-bjj\n}\n</code></pre> <p>where: - <code>chainID</code>: refers to the ethereum chain identifier - <code>rollupContractAddress</code>: rollup contract ethereum address - <code>compressed-bjj</code>: babyjubjub public key in its compressed format represented as hexadecimal string</p> <p><code>signature = eth_signTypedData(domain, types, value)</code></p> <p>Further details on <code>eth_signTypedData</code> can be found here</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#internal-rollup-account","title":"Internal Rollup Account","text":"<p>An internal rollup account does not use an Ethereum address, and thus can only operate via L2 txs.  Since no Ethereum address is involved, the account creation does not require an authorization and will only specify the Baby Jubjub public key.  Internally, this account will have the <code>ethAddr = 0xffff..</code>.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#transaction-types","title":"Transaction Types","text":"<p>Table of possible combinations of actions in an L1User transaction:</p> CreateAccount Deposit Transfer Exit Valid Name NO X YES ForceExit X YES ForceTransfer X X NO X YES Deposit X X NO X X YES DepositTransfer X X X NO X NO X X NO X X NO X X X NO X X YES CreateAccountDeposit X X X NO X X X YES CreateAccountDepositTransfer X X X X NO <p>Summary:</p> <ul> <li>RollupTx<ul> <li>L1<ul> <li>User<ul> <li>CreateAccountDeposit</li> <li>CreateAccountDepositTransfer</li> <li>Deposit</li> <li>DepositTransfer</li> <li>ForceTransfer</li> <li>ForceExit</li> </ul> </li> <li>Coordinator<ul> <li>CreateAccountEth</li> <li>CreateAccountBjj</li> </ul> </li> </ul> </li> <li>L2<ul> <li>Transfer</li> <li>Exit</li> <li>TransferToEthAddr</li> <li>TransferToBjj</li> </ul> </li> </ul> </li> <li>HermezWithdraw</li> </ul> <p>RollupTx is any transaction that is processed in the rollup state through a ZK-SNARK proof.</p> <p>HermezWithdraw is a transaction performed through the smart contract to get funds back from the smart contract to Ethereum address. This is done by demonstrating the existence of a leaf in the exit tree.</p> <p>NOP transaction is an empty transaction that does not perform any action.  Used in the circuit inputs when the coordinator does not have enough transactions to fill maximum number of transactions in a batch. NULL transaction is a transaction that is forced to use the value 0 for amount or loadAmount.  Used to nullify an <code>L1UserTx</code> that is found to be invalid, so that it does not do any update to the state tree.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#l1-user-transactions","title":"L1 user transactions","text":"<p>All L1 data transactions are concatenated together and hashed in order to force the coordinator to process them. Since the operator is forced to process L1 transactions, those transactions have to accomplish certain rules to be processed by the circuit. If any of those rules are not fulfilled the transaction will be considered as a NULL transaction.</p> <p>If any user tries to flood L1 transactions with invalid transactions, it will have to pay fees associated to L1 transactions</p> <p>Data of the transaction that is concatenated, hashed with sha256 and used as a public input in the circuit:</p> <pre><code>**Buffer bytes notation**\nL1TxFullData: [     160 bits     ] fromEthAddr\n              [     256 bits     ] fromBjj-compressed\n              [ MAX_NLEVELS bits ] fromIdx\n              [      40 bits     ] loadAmountFloat40\n              [      40 bits     ] amountFloat40\n              [      32 bits     ] tokenID\n              [ MAX_NLEVELS bits ] toIdx\n\nL1TxFullData length: 624 bits / 78 bytes\n\nL1TxsFullData = L1TxFullData[0] || L1TxFullData[1] || ... || L1TxFullData[len(L1Txs) - 1] || zero[(len(L1Txs)] || ... || zero[MAX_L1_TX - 1]\n</code></pre> <p>All L1 txs that perform a transfer or exit must be approved by the Ethereum address of the account.  This is indicated by setting the <code>fromEthAddr</code> as the <code>message.sender</code>, which is the address that signs the L1 tx.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#createaccountdeposit","title":"CreateAccountDeposit","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: message.sender</li> <li><code>fromBjj-compressed</code>: user parameter</li> <li><code>fromIdx</code>: 0</li> <li><code>loadAmountFloat40</code>: user parameter</li> <li><code>amountFloat40</code>: 0</li> <li><code>tokenId</code>: user parameter</li> <li><code>toIdx</code>: 0</li> <li>Actions:</li> <li>new account inserted into the state tree with idx = <code>auxFromIdx</code></li> <li>deposit <code>loadAmountFloat40</code> into the sender <code>auxFromIdx</code><ul> <li>new account data:<ul> <li><code>ax</code>: <code>fromBjj-compressed -&gt; ax</code></li> <li><code>ay</code>: <code>fromBjj-compressed -&gt; ay</code></li> <li><code>ethAddr</code>: <code>fromEthAddr</code></li> <li><code>tokenID</code>: <code>tokenId</code></li> <li><code>balance</code>: <code>loadAmount</code></li> <li><code>nonce</code>: 0</li> </ul> </li> </ul> </li> <li>Requirements:</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#createaccountdeposittransfer","title":"CreateAccountDepositTransfer","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: message.sender</li> <li><code>fromBjj-compressed</code>: user parameter</li> <li><code>fromIdx</code>: 0</li> <li><code>loadAmountFloat40</code>: user parameter</li> <li><code>amountFloat40</code>: user parameter</li> <li><code>tokenId</code>: user parameter</li> <li><code>toIdx</code>: user parameter</li> <li>Actions:</li> <li>new account inserted into the state tree with idx = <code>auxFromIdx</code></li> <li>deposit <code>loadAmountFloat40</code> into the sender <code>auxFromIdx</code><ul> <li>new account data:<ul> <li><code>ax</code>: <code>fromBjj-compressed -&gt; ax</code></li> <li><code>ay</code>: <code>fromBjj-compressed -&gt; ay</code></li> <li><code>ethAddr</code>: <code>fromEthAddr</code></li> <li><code>tokenID</code>: <code>tokenId</code></li> <li><code>balance</code>: <code>loadAmount</code></li> <li><code>nonce</code>: 0</li> </ul> </li> </ul> </li> <li>subtract <code>amountFloat40</code> from sender <code>auxFromIdx</code></li> <li>add <code>amountFloat40</code> to recipient <code>toIdx</code></li> <li>Requirements:</li> <li>receiver <code>toIdx</code> account must exist</li> <li>Checks NULL:</li> <li>sender <code>fromIdx</code> and receiver should have the same <code>tokenID</code></li> <li><code>tokenID</code> should match state1 update account</li> <li><code>tokenID</code> should match state2 update account</li> <li>sender <code>fromIdx</code> should have enough balance</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#deposit","title":"Deposit","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: 0</li> <li><code>fromBjj-compressed</code>: 0</li> <li><code>fromIdx</code>: user parameter</li> <li><code>loadAmountFloat40</code>: user parameter</li> <li><code>amountFloat40</code>: 0</li> <li><code>tokenId</code>: user parameter</li> <li><code>toIdx</code>: 0</li> <li>Actions:</li> <li>deposit <code>loadAmountFloat40</code> into the account</li> <li>Requirements:</li> <li>recipient <code>fromIdx</code> account to receive L1 funds must exist</li> <li>Checks NULL:</li> <li><code>tokenID</code> should match state1 update account</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#deposittransfer","title":"DepositTransfer","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: message.sender</li> <li><code>fromBjj-compressed</code>: 0</li> <li><code>fromIdx</code>: user parameter</li> <li><code>loadAmountFloat40</code>: user parameter</li> <li><code>amountFloat40</code>: user parameter</li> <li><code>tokenId</code>: user parameter</li> <li><code>toIdx</code>: user parameter</li> <li>Actions:</li> <li>deposit <code>loadAmountFloat40</code> into the account</li> <li>subtract <code>amountFloat40</code> from sender <code>fromIdx</code></li> <li>add <code>amountFloat40</code> to recipient <code>toIdx</code></li> <li>Requirements:</li> <li>recipient <code>fromIdx</code> account to receive L1 funds must exist</li> <li>receiver <code>toIdx</code> account must exist</li> <li>Checks NULL:</li> <li><code>tokenID</code> should match state1 update account</li> <li><code>tokenID</code> should match state2 update account</li> <li>sender <code>fromIdx</code> should have enough balance</li> <li><code>fromEthAddr</code> should match state1 update account</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#forcetransfer","title":"ForceTransfer","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: message.sender</li> <li><code>fromBjj-compressed</code>: 0</li> <li><code>fromIdx</code>: user parameter</li> <li><code>loadAmountFloat40</code>: 0</li> <li><code>amountFloat40</code>: user parameter</li> <li><code>tokenId</code>: user parameter</li> <li><code>toIdx</code>: user parameter</li> <li>Actions:</li> <li>subtract <code>amountFloat40</code> from sender <code>fromIdx</code></li> <li>add <code>amountFloat40</code> to recipient <code>toIdx</code></li> <li>Requirements:</li> <li>sender <code>fromIdx</code> must exist</li> <li>receiver <code>toIdx</code> account must exist</li> <li>Checks NULL:</li> <li>sender <code>fromIdx</code> and receiver should have the same <code>tokenID</code></li> <li><code>tokenID</code> should match state1 update account</li> <li><code>tokenID</code> should match state2 update account</li> <li>sender <code>fromIdx</code> should have enough balance</li> <li><code>fromEthAddr</code> should match state1 update account</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#forceexit","title":"ForceExit","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: message.sender</li> <li><code>fromBjj-compressed</code>: 0</li> <li><code>fromIdx</code>: user parameter</li> <li><code>loadAmountFloat40</code>: 0</li> <li><code>amountFloat40</code>: user parameter</li> <li><code>tokenId</code>: user parameter</li> <li><code>toIdx</code>: 1</li> <li>Actions:</li> <li>subtract <code>amountFloat40</code> from sender <code>fromIdx</code></li> <li>If it does not exit <code>fromIdx</code> account on the exit tree:<ul> <li>new account <code>fromIdx</code> inserted into the exit tree</li> </ul> </li> <li>add <code>amountFloat40</code> to the exit tree recipient <code>fromIdx</code></li> <li>Requirements:</li> <li>sender <code>fromIdx</code> must exist</li> <li>Checks NULL:</li> <li><code>tokenID</code> should match state1 update account</li> <li>sender should have enough balance</li> <li><code>fromEthAddr</code> should match state1 update account</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#l1-coordinator","title":"L1 Coordinator","text":"<p>Coordinator has the ability to create accounts at the time to forge a batch. These transactions are also included in the <code>L1TxsData</code>. Account could be created for a given: - Ethereum address - Baby Jubjub key pair (regular rollup account) - Baby Jubjub public key (internal rollup account)</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#createaccounteth","title":"CreateAccountEth","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: coordinator parameter</li> <li><code>fromBjj-compressed</code>: coordinator parameter (from ecdsa signed message)</li> <li><code>fromIdx</code>: 0</li> <li><code>loadAmountFloat40</code>: 0</li> <li><code>amountFloat40</code>: 0</li> <li><code>tokenId</code>: coordinator parameter</li> <li><code>toIdx</code>: 0</li> <li>Actions:</li> <li>new account inserted into the state tree<ul> <li>account data:<ul> <li><code>sign</code>: <code>fromBjj-compressed -&gt; sign</code></li> <li><code>ay</code>: <code>fromBjj-compressed -&gt; ay</code></li> <li><code>ethAddr</code>: <code>fromEthAddr</code></li> <li><code>tokenID</code>: <code>tokenId</code></li> <li><code>balance</code>: 0</li> <li><code>nonce</code>: 0</li> </ul> </li> </ul> </li> <li>Requirements:</li> <li>coordinator must submit:<ul> <li><code>ecdsa signature</code>: R,S,V signature of AccountCreationAuthMsg</li> </ul> </li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#createaccountbjj","title":"CreateAccountBjj","text":"<ul> <li>Inputs:</li> <li><code>fromEthAddr</code>: <code>0xffff..</code></li> <li><code>fromBjj-compressed</code>: coordinator parameter</li> <li><code>fromIdx</code>: 0</li> <li><code>loadAmountFloat40</code>: 0</li> <li><code>amountFloat40</code>: 0</li> <li><code>tokenId</code>: coordinator parameter</li> <li><code>toIdx</code>: 0</li> <li>Actions:</li> <li>new account inserted into the state tree<ul> <li>account data:<ul> <li><code>sign</code>: <code>fromBjj-compressed -&gt; sign</code></li> <li><code>ay</code>: <code>fromBjj-compressed -&gt; ay</code></li> <li><code>ethAddr</code>: 0</li> <li><code>tokenID</code>: <code>tokenId</code></li> <li><code>balance</code>: 0</li> <li><code>nonce</code>: 0</li> </ul> </li> </ul> </li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#l2","title":"L2","text":"<p>All L2 transactions are sent to the coordinators by the users. The coordinator collects them into a batch in order to forge it. The coordinator must check that it collects valid transactions that must not perform an invalid transition state. Otherwise, the proof computed by the coordinator will not be valid. The user could submit any transaction data to the coordinator, but it will be rejected if the transaction could not be processed. Therefore, it is in the users' benefit to provide a valid transaction if they want it to be inserted in the ZK-Rollup.</p> <p>Signature used for L2 transactions is <code>eddsa</code> with Baby Jubjub key. L2 transaction data in the signature:</p> <pre><code>**Field element notation**\ntxCompressedData: [      32 bits     ] signatureConstant\n                  [      16 bits     ] chainId\n                  [ MAX_NLEVELS bits ] fromIdx\n                  [ MAX_NLEVELS bits ] toIdx\n                  [      32 bits     ] tokenID\n                  [      40 bits     ] nonce\n                  [       8 bits     ] userFee\n                  [       1 bits     ] toBjjSign\nTotal bits compressed data:  225\n\ntoEthAddr\ntoBjjAy\n\n**Field element notation**\ntxCompressedDataV2: [ MAX_NLEVELS bits ] fromIdx\n                      [ MAX_NLEVELS bits ] toIdx\n                      [      40 bits     ] amountFloat40\n                      [      32 bits     ] tokenID\n                      [      40 bits     ] nonce\n                      [      8 bits      ] userFee\n                      [      1 bits      ] toBjjSign\nTotal bits txCompressedDataV2: 217\n\n**Field element notation**\nelement_1:[      160 bits    ] toEthAddr\n          [      40 bits     ] amountFloat40\n          [      32 bits     ] maxNumBatch\nTotal bits element_1: 232\n\nrqToEthAddr\nrqToBjjAy\n\nmessageToSign = H(e_0, e_1, e_2, e_3, e_4, e_5)\n\ne_0: [ 225 bits ] txCompressedData\ne_1: [ 232 bits ] element_1\ne_2: [ 253 bits ] toBjjAy\ne_3: [ 217 bits ] rqTxCompressedDataV2\ne_4: [ 160 bits ] rqToEthAddr\ne_5: [ 253 bits ] rqToBjjAy\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#transfer","title":"Transfer","text":"<p>Standard transaction of tokens between two accounts inside the rollup, L2 --&gt; L2. It is assumed that this transaction has a recipient <code>toIdx</code> &gt; <code>INITIAL_IDX</code></p> <ul> <li>Actions:</li> <li>subtract <code>amountFloat40</code> from sender <code>fromIdx</code></li> <li>add <code>amountFloat40</code> to recipient <code>toIdx</code></li> <li>Valid transaction:</li> <li>sender <code>fromIdx</code> exist on the state tree</li> <li>recipient <code>toIdx</code> exist on the state tree</li> <li><code>tokenID</code> match with <code>fromIdx</code> and <code>toIdx</code> token</li> <li>sender <code>fromIdx</code> has enough funds</li> <li>sender <code>fromIdx</code> has the correct <code>nonce</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#exit","title":"Exit","text":"<p>Transfer tokens from an account to the exit tree, L2 --&gt; L2</p> <ul> <li>Actions:</li> <li>subtract <code>amountFloat40</code> from sender <code>fromIdx</code></li> <li>If it does not exit <code>fromIdx</code> account on the exit tree:<ul> <li>new account <code>fromIdx</code> inserted into the exit tree</li> </ul> </li> <li>add <code>amountFloat40</code> to the exit tree recipient <code>fromIdx</code></li> <li>Valid transaction:</li> <li>sender <code>fromIdx</code> exist on the state tree</li> <li><code>tokenID</code> match with <code>fromIdx</code> token</li> <li>sender <code>fromIdx</code> has enough funds</li> <li>sender <code>fromIdx</code> has the correct <code>nonce</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#transfertoethaddr","title":"TransferToEthAddr","text":"<p>The sender sends the transaction to an Ethereum address recipient in the state tree. If the recipient does not exist and the coordinator wants to process the transaction, coordinator should create a new account with the recipient's Ethereum address.</p> <p>It is assumed that the <code>toIdx</code> is set to the special index 0. <code>toEthAddr</code> would be used to choose a recipient to transfer the <code>amountFloat40</code>. Hence, coordinator would select the recipient <code>idx</code> to add <code>amountFloat40</code> (called <code>auxToIdx</code>).</p> <p>Note that this transaction encourages the coordinator to create new accounts through the L1 coordinator transaction CreateAccountEth. It is important to mention that this kind of transaction allows for the creation of new accounts in the state tree without needing to have any <code>ether</code> on L1. Hence, users could create new accounts and deposit tokens just through an L2 transaction.</p> <ul> <li>Actions:</li> <li>subtract <code>amountFloat40</code> from sender <code>fromIdx</code></li> <li>add <code>amountFloat40</code> to the recipient <code>auxToIdx</code><ul> <li>it must match with <code>toEthAddr</code> and <code>tokenID</code> signed by sender</li> </ul> </li> <li>Valid transaction:</li> <li>sender <code>fromIdx</code> exist on the state tree</li> <li><code>tokenID</code> match with <code>fromIdx</code> and <code>auxToIdx</code> token</li> <li>sender <code>fromIdx</code> has enough funds</li> <li>sender <code>fromIdx</code> has the correct <code>nonce</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#transfertobjj","title":"TransferToBjj","text":"<p>Sender sends the transaction to a Baby Jubjub address recipient in the state tree. If the recipient does not exist and coordinator wants to process the transaction, coordinator should create a new account with the recipient Baby Jubjub address.</p> <p>It is assumed that the <code>toIdx</code> is set to the special index 0. <code>toBjjAy</code> + <code>toBjjSign</code> would be used to choose the recipient to transfer the <code>amountFloat40</code>. <code>toEthAddr</code> will be set to <code>0xff..fff</code> which is a special case of an Ethereum address that no one can control and it will check that the recipient account has its Ethereum address set to <code>0xff..ff</code>.  This value allows account creation without Ethereum address authorization. Hence, coordinator would select the recipient <code>idx</code> to add <code>amountFloat40</code> (called <code>auxToIdx</code>).</p> <p>Note that this transaction encourages the coordinator to create new accounts through the L1 coordinator transaction CreateAccountBjj. It is important to mention that this kind of transaction allows for the creation of new accounts in the state tree without the needing to have any <code>ether</code> on L1. Hence, users could create new accounts and deposit tokens just through an L2 transaction.</p> <ul> <li>Actions:</li> <li>subtract <code>amountFloat40</code> from sender <code>fromIdx</code></li> <li>add <code>amountFloat40</code> to the recipient <code>auxToIdx</code><ul> <li>it must match with <code>toBjjAy</code> + <code>toBjjSign</code> and <code>tokenID</code> signed by sender</li> <li>it must match <code>ethAddr</code> with <code>0xff..ff</code></li> </ul> </li> <li>Valid transaction:</li> <li>sender <code>fromIdx</code> exist on the state tree</li> <li><code>tokenID</code> match with <code>fromIdx</code> and <code>auxToIdx</code> token</li> <li>sender <code>fromIdx</code> has enough funds</li> <li>sender <code>fromIdx</code> has the correct <code>nonce</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#hermezwithdraw","title":"HermezWithdraw","text":"<p>Funds are held on Hermez contract once the user has perform an exit transaction. The withdrawal data will contain unique data (nullifier) which identifies the withdrawal. Hence, the smart contract will store that data to avoid performing withdrawals multiple times.</p> <p>Each withdrawal could be identified uniquely by:   - Merkle tree index   - number exit root</p> <pre><code>// numExitRoot =&gt; (idx =&gt; true/false)\nmapping(uint64 =&gt; mapping(uint48 =&gt; bool)) public exitNullifierMap;\n</code></pre> <p>In order to perform withdraw with a ZK Proof, all pretended public inputs are hashed with <code>sha256</code> into one single public input in order to optimize number of public inputs and therefore save gas at the time to do the verification in the smart contract. Pretended public inputs are hashed following the next specification:</p> <pre><code>**Buffer bytes notation**\nglobalInputsData: [ 256 bits ] rootExit\n                  [ 160 bits ] ethAddr\n                  [  32 bits ] tokenID\n                  [ 192 bits ] balance\n                  [  48 bits ] idx\nhashGlobalInputs = SHA256(globalInputsData) % rField\n</code></pre> <p>Example:</p> <pre><code>rootExit =  0x1230000000000000000000000000000000000000000000000000000000000456\nethAddr = 0xAB000000000000000000000000000000000000CD\ntokenID = 0x700000007\nbalance = 0xEE00000000000000000000000000000000000000000000EE\nidx = 0xF0000000000F\n\nglobalInputsData = 0x1230000000000000000000000000000000000000000000000000000000000456AB000000000000000000000000000000000000CD700000007EE00000000000000000000000000000000000000000000EEF0000000000F\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#data-availability","title":"Data Availability","text":"<p>ZK-Rollup approach determines that anyone can reconstruct the full tree state by just collecting data from the L1 chain. This is done by not having any dependency of third parties holding essential data to reconstruct the full state. This feature ensures liveness of the system, meaning that no third party needs to be active in order to provide data to rebuild the state tree.</p> <p>Transaction types: - txs     - l1_txs: layer 1 transactions         - l1_user_txs: queued asynchronously by users via smart contract call         - l1_coordinator_txs: added by coordinator in <code>forge</code> smart contract call     - l2_txs: layer 2 transactions</p> <p>\\(len(txs) = len(l1\\_txs) + len(l2\\_txs)\\)</p> <p>\\(len(l1\\_txs) = len(l1\\_user\\_txs) + len(l1\\_coordinator\\_txs)\\)</p> <p>\\(len(txs) \\leq MAX\\_TXS\\)</p> <p>\\(len(l1\\_txs) \\leq MAX\\_L1\\_TXS &lt; MAX\\_TXS\\)</p> <p>\\(len(l1\\_user\\_txs) \\leq MAX\\_L1\\_USER\\_TXS &lt; MAX\\_L1\\_TXS\\)</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#l1-user-transactions_1","title":"L1 User Transactions","text":"<p>All transaction data triggered by a smart contract function can be directly retrieved since it will be stored on the blockchain, but it's harder when this data happens in internal transactions, not all nodes support that functionality. That's why all the L1 user transactions emit an <code>L1UserTx</code> event to facilitate the data retrieval.</p> <p>When a user calls a function that adds an <code>L1UserTx</code>, the following happens: - Storage     - Add the <code>L1UserTx</code> data at the end of the last non-frozen non-full queue of <code>L1UserTxs</code> (<code>L1UserTxs[lastL1UserTxs]</code>).         - Each queue is identified by a toForgeL1TxsNumber that grows incrementally         - The queue in which this data is added is identified by a particular <code>toForgeL1TxsNumber</code> (which is <code>lastL1UserTxs</code> at the moment the <code>L1UserTx</code> is added)         - The <code>L1UserTxs</code> has a position in this queue: <code>L1UserTxs[lastL1UserTxs][position]</code> - Event     - <code>toForgeL1TxsNumber</code>     - <code>L1UserTx</code> data (78 bytes)     - <code>position</code></p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#l1-coordinator-transactions","title":"L1 Coordinator Transactions","text":"<p>Coordinator could perform some special transactions to trigger L1 transactions. These transactions are processed in the <code>forgeBatch</code> smart contract method, and all the necessary data is provided in the method inputs. This means that like L2 transactions, the data availability can be retrieved by inspecting the Ethereum transaction.</p> <p>Data needed to perform these transactions will be encoded as:</p> <pre><code>**Buffer bytes notation**\nL1CoordinatorTx:    [  8   bits  ] V (ecdsa signature)\n                    [ 256  bits  ] S (ecdsa signature)\n                    [ 256  bits  ] R (ecdsa signature)\n                    [ 256  bits  ] Bjj compressed\n                    [ 32   bits  ] tokenID\n\nL1CoordinatorTxs = L1CoordinatorTx[0] || L1CoordinatorTx[1] || ... || L1CoordinatorTx[N - 1] || L1CoordinatorTx[N]\n</code></pre> <p>There two types of L1CoordinatorTx: - CreateAccountEth:   - Ethereum address is recovered from the ecdsa signature   - Coordinator should create an account with an Ethereum address equal to the <code>toEthAddr</code> in the L2 transaction in order to process the L2 transaction   - Contract will have to build the <code>AccountCreationAuthMsg</code>, hash it and retrieve Ethereum account from signed message and the signature (<code>r</code>, <code>s</code> and <code>v</code>). - CreateAccountBjj:   - Coordinator should create an account with a Baby Jubjub key equal to the <code>toAx</code> and <code>toAy</code> in the L2 transaction in order to process the L2 transaction   - ecdsa signature fields are set to 0</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#l1-l2-transactions","title":"L1 - L2 Transactions","text":"<p>All transactions processed in a batch must be posted on L1. This is assured by hashing all data-availability and forces the coordinator to match all his processed transactions with his posted L1 data-availability.</p> <p>L2 transactions data-availability struct <code>L2TxData</code>:</p> <p><code>finalToIdx</code> is equal to <code>toIdx</code> except when <code>toIdx == IDX 0</code> where it will be equal to <code>auxToIdx</code></p> <pre><code>**Buffer bytes notation**\nL2TxData: [ NLevels  bits ] fromIdx\n          [ NLevels  bits ] finalToIdx\n          [    40  bits   ] amountF\n          [     8  bits   ] fee\n</code></pre> <p>note that <code>nopTxData</code> is a <code>L2TxData</code> struct where all the fields are set to 0</p> <p>L1 transactions data-availability struct <code>L1TxData</code>:</p> <p>note that effectiveAmount is the amount that will be transferred on L1 transaction once all the nullifiers are applied</p> <pre><code>**Buffer bytes notation**\nL1TxData: [ NLevels  bits ] fromIdx\n          [ NLevels  bits ] toIdx\n          [    40  bits   ] effectiveAmountF = amounF * (1 - isNullified)\n          [     8  bits   ] fee = 0\n</code></pre> <p>Example: considering <code>NLevels = 32 bits</code>, each L2Tx data-availability is 32 + 32 + 40 + 8 = 112 bits = 14 bytes</p> <p><code>L1L2TxsData</code> is the all the L1-L2 transaction data concatenated:</p> <pre><code>L1L2TxsData = L1TxData[0] || L1TxData[1] || ... || L1TxData[len(L1Txs) - 1] || L2TxData[0] || L2TxData[1] || ... || L2TxData[len(L2Txs) - 1] || nopTxData[len(Txs)] || ... || nopTxData[MAX_TXS - 1]\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#fee-tx","title":"Fee Tx","text":"<p>All indexes that will receive the fees accumulated. Further information can be found in this section.</p> <p><code>feeTxsData</code> is all the indexes that will receive the fees concatenated:</p> <pre><code>feeTxsData = idx[0] || ... || ... || L2Tx[MAX_FEE_TX - 1]\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#forging","title":"Forging","text":"<p>When the coordinator calls the <code>forging</code> function, the L1CoordinatorTxs, L2Txs and feeTxsData data is sent as input to the smart contract function.  This data can be retrieved by querying the arguments of the function call.  To allow this data retrieval from a regular Ethereum node, we must force that the call is not made from a smart contract:</p> <pre><code>assert(msg.sender == tx.origin)\n</code></pre> <p>For every <code>forging</code> call, an event will be sent with the following information: - BatchNum</p> <p>The rollup <code>forging</code> function will be private, and will be called internally in the smart contract by a wrapper that adds a consensus mechanism to decide if the caller is allowed to forge or not at that Ethereum block.</p> <p>Contract will compute the hash of all pretended public inputs of the circuit in order to force these private signals to be processed by the coordinator.</p> <ul> <li>List parameters in <code>hashGlobalData</code>:</li> <li><code>oldLastIdx</code>: old last merkle tree index created</li> <li><code>newLastIdx</code>: new last merkle tree index created</li> <li><code>oldStateRoot</code>: ols state root</li> <li><code>newStateRoot</code>: new state root</li> <li><code>newExitRoot</code>: new exit root</li> <li><code>L1TxsFullData</code>: bits  L2 full data</li> <li><code>L1L2TxsData</code>: bits L1-L2 transaction data-availability</li> <li><code>feeTxsData</code>: all index accounts to receive accumulated fees</li> <li><code>chainId</code>: global chain identifier</li> <li><code>currentNumBatch</code>: current batch number processed</li> </ul> <pre><code>**Buffer bytes notation**\nhashGlobalData: [            MAX_NLEVELS bits          ] oldLastIdx\n                [            MAX_NLEVELS bits          ] newLastIdx\n                [                256 bits              ] oldStRoot\n                [                256 bits              ] newStRoot\n                [                256 bits              ] newExitRoot\n                [ MAX_L1_TX*(2*MAX_NLEVELS + 528) bits ] L1TxsFullData\n                [     MAX_TX*(2*NLevels + 48) bits     ] L1L2TxsData\n                [       NLevels * MAX_TOKENS_FEE       ] feeTxsData\n                [                 16 bits              ] chainID\n                [                 32 bits              ] currentNumBatch\n\nhashGlobalInputs = SHA256(hashGlobalData) % rField\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#fee-model","title":"Fee Model","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#user","title":"User","text":"<p>Fees are paid on L2 transactions in the same token that they are done. So, if the user sends \"Token A\", the fees will be paid in \"Token A\". Fee is represented as a percentage of the total amount sent:</p> <p>\\(Fee_{amount} = amount * Fee_{percentage}\\)</p> <p>\\(TotalTxCost = amount + Fee_{amount}\\)</p> <p>Since there are 8 reserved bits for this field, there will be 256 different fee percentages that the user could choose to perform its transaction. See the table showing the 256 values for each fee index</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#compute-fees","title":"Compute Fees","text":"<p>Procedure to compute fees must remain equal across protocol implementations. The following procedure has been adopted:</p> <ul> <li>given <code>feeUser</code> bits selects feeFactor shifted large integer</li> <li>60 bits has been chosen in order to optimize precision at the time to compute fees. 60 bits is the minimum bits to achieve enough precision among all fee factor values</li> <li> <p>\\(\\text{bitsShiftPrecision} = 60\\)</p> </li> <li> <p>\\(Fee_{amount} = amount * feeFactor_{shifted}\\)</p> </li> <li>\\(Fee_{amount} = Fee_{amount} &gt;&gt; \\text{bitsShiftPrecision} \\quad \\text{if} \\quad i &lt; 192\\)</li> <li>\\(Fee_{amount} = Fee_{amount} \\quad \\text{if} \\quad i \\geq 192\\)</li> <li>\\(assert(Fee_{amount} &lt; 2^{128})\\)</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#coordinator","title":"Coordinator","text":"<p>L2 transactions are collected by the coordinator and it will receive all the fees collected by the L2 transactions. In order to optimize protocol speed, it has been defined a maximum number of tokens that the coordinator can collect fees from <code>MAX_FEE_TX = 64</code>.</p> <p>It does not mean that the coordinator could forge as many transactions with more than 64 <code>tokenID</code>. The coordinator could do so, but it will only be available to collect fees from 64 different <code>tokenID</code>. The rest of <code>tokenID</code> that appear in the forged transactions will be processed but fees would not be collected.</p> <p>In order to ensure that the coordinator receives the correct amount of fees, the ZK-SNARK circuit will compute all the collected fees for all the L2 transactions processed. Then, the coordinator must submit in which leafs it wants to receive the fees collected.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#token-listing","title":"Token Listing","text":"<ul> <li>ERC20 tokens are supported by the rollup and it could be added up to \\(2^{32}\\) different tokens</li> <li>Ether is supported by the rollup and it has an assigned <code>tokenID = 0</code></li> <li>Contracts maintain a list of all tokens registered in the rollup and each token needs to be listed before using it</li> <li><code>tokenID</code> is assigned (sequentially) each time a token is listed in the system and this identifier will be used for any rollup transaction, either L1 or L2, that modifies the state tree</li> <li>TokenInfo:<ul> <li>TokenID</li> <li>Address</li> </ul> </li> <li>Each time a new token is registered:<ul> <li>Storage<ul> <li>The TokenInfo is added to a mapping</li> </ul> </li> <li>Event<ul> <li>TokenInfo</li> </ul> </li> </ul> </li> <li>Constraints:</li> <li>A fee will be applied at the time to register tokens in order to prevent flooding attack<ul> <li>this fee could be modified by the governance and it is paid in HEZ tokens</li> </ul> </li> <li>Two tokens with the same Ethereum address cannot be added twice in the system</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/protocol/#emergency-mechanism","title":"Emergency Mechanism","text":"<p>This logic is implemented in order to mitigate attacks that could potentially steal funds from Hermez Network. The aim of this method is to mitigate funds stolen while preserving decentralization.</p> <p>The core mechanism is to set a withdrawal limit in order to avoid infinite withdrawal in case of stolen funds. Therefore, it is assured that the attacker can only steal a certain amount of tokens.</p> <p>This logic is implemented in a smart contract: <code>WithdrawalDelayer</code>. This contract is for use completely independent of the Hermez Network but it meets the objective we need to mitigate attacks.</p> <p>The purpose of this smart contract is to delay the withdraw. Hence, tokens will be held by the smart contract for a period of <code>D</code> and only afterwards tokens could be really withdrawn.</p> <ul> <li>Hermez emergency mechanism</li> <li>Withdrawal delayer mechanism</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/","title":"Circuits","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#overview","title":"Overview","text":"<p>All of the rules a transaction must follow in order to be valid are designed and coded in the circuits. Those rules could be seen as constraints that a transaction must accomplish in order to be able to modify the state tree or the exit tree.</p> <p>Circuits are built from the bottom up. Hence, small circuits are first introduced and are referenced in advanced ones for the sake of clarity.</p> <p>Circuits would be split into three modules: - library: basic Hermez circuits and structs commonly used across the rest of the circuits - withdraw: specific circuit to allow a user to withdraw funds from Hermez contract - rollup-main: main circuit that contains all the logic described in ZK-Rollup protocol</p> <p>withdraw: user could perform a withdrawal by submitting a ZK Proof or a Merkle tree proof. Both methods are equivalent in terms of functionality.</p> <ul> <li>Global variables:</li> <li><code>nTx</code>: absolute maximum of L1 or L2 transactions allowed</li> <li><code>nLevels</code>: Merkle tree depth</li> <li><code>maxL1Tx</code>: absolute maximum of L1 transaction allowed</li> <li><code>maxFeeTx</code>: absolute maximum of fee transactions allowed</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#circuits-organization","title":"Circuits Organization","text":"<ul> <li>Library:<ul> <li>hash-state</li> <li>decode-float</li> <li>mux256</li> <li>utils-bjj</li> </ul> </li> <li>Source:<ul> <li>decode-tx</li> <li>fee-accumulator</li> <li>rq-tx-verifier</li> <li>hash-inputs</li> <li>fee-tx</li> <li>compute-fee</li> <li>balance-updater</li> <li>rollup-tx-states</li> <li>rollup-tx</li> <li>rollup-main</li> </ul> </li> <li>withdraw</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#dependencies","title":"Dependencies","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#assumptions","title":"Assumptions","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#l1-transactions","title":"L1 Transactions","text":"<p>Some assumptions must be taken into account in L1 transactions. They are performed by users which interact with the smart contract. Hence, the smart contract performs checks and forces some parameters that are assumed in the circuit implementation: - <code>tokenID</code> must exist - <code>loadAmount</code> &lt; 2^128 - <code>amount</code> &lt; 2^192 - if <code>toIdx == 0</code> then <code>amount == 0</code> - if <code>fromIdx == 0</code> then <code>fromBjj-compressed != 0</code> - if <code>fromIdx &gt; INITIAL_IDX</code> then <code>fromBjj-compressed == 0</code></p> <p>A summary is shown in the next table with all the L1 transactions assumptions: - <code>UP</code>: user parameter - <code>ME</code>: must exist</p> Transaction type toIdx tokenID amountF loadAmountF fromIdx fromBjj-compressed fromEthAddr createAccount 0 UP, ME 0 0 0 UP (!=0) msg.sender createAccountDeposit 0 UP, ME 0 UP &lt; 2^128 0 UP (!=0) msg.sender createAccountDepositTransfer UP, ME UP, ME UP &lt; 2^192 UP &lt; 2^128 0 UP (!=0) msg.sender deposit 0 UP, ME 0 UP &lt; 2^128 UP, ME 0 msg.sender depositTransfer UP, ME UP, ME UP &lt; 2^192 UP &lt; 2^128 UP, ME 0 msg.sender forceTransfer UP, ME UP, ME UP &lt; 2^192 0 UP, ME 0 msg.sender forceExit 1 UP, ME UP &lt; 2^192 0 UP, ME 0 msg.sender <p>All L1 transactions are further explained here</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#legend","title":"Legend","text":"<p>It should be note that <code>public</code> and <code>private</code> signals will be highlighted only in top layer circuits: - withdraw - rollup-main</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#library","title":"Library","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#hash-state","title":"hash-state","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description","title":"Description","text":"<p>Gets the inputs of the state and computes its hash as described here</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs","title":"Inputs","text":"Input type Description tokenID uint32 token identifier nonce uint40 nonce sign boolean babyjubjub sign balance uint192 amount available ay field babyjubjub y coordinate ethAddr uint160 ethereum address"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs","title":"Outputs","text":"Output type Description out field state hash"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#decode-float","title":"decode-float","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_1","title":"Description","text":"<p>Gets an input representing a <code>float40</code> format and decode it to a large integer value as described here</p> <ul> <li>Steps:</li> <li>get the 40 less significant bits</li> <li>compute exponent</li> <li>compute mantissa</li> <li>compute final large integer</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_1","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_1","title":"Inputs","text":"Input type Description in uint40 float40 encode"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_1","title":"Outputs","text":"Output type Description out field float40 decode"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#mux256","title":"mux256","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_2","title":"Description","text":"<p>Multiplexer with 256 inputs</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_2","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_2","title":"Inputs","text":"Input type Description s[8] boolean array mux selectors in[256] field array mux inputs"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_2","title":"Outputs","text":"Output type Description out field selected input"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#utils-bjj","title":"utils-bjj","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_3","title":"Description","text":"<p>Implements two functionalities to be used for further circuits:</p> <ul> <li>BitsCompressed2AySign</li> <li>gets the <code>bjjCompressed[256]</code> in bits and retrieve <code>ay</code> and <code>sign</code> to be inserted into the account state</li> <li>AySign2Ax</li> <li>gets the <code>ay</code> and <code>sign</code> and computes de <code>ax</code> coordinate</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_3","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#input","title":"Input","text":"<ul> <li>BitsCompressed2AySign</li> </ul> Input type Description bjjCompressed[256] boolean array babyjubjub point compressed <ul> <li>AySign2Ax</li> </ul> Input type Description ay field babyjubjub y coordinate sign boolean babyjubjub sign"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#ouput","title":"Ouput","text":"<ul> <li>BitsCompressed2AySign</li> </ul> Output type Description ay field babyjubjub y coordinate sign boolean babyjubjub sign <ul> <li>AySign2Ax</li> </ul> Output type Description ax field babyjubjub x coordinate"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#source","title":"Source","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#decode-tx","title":"decode-tx","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_4","title":"Description","text":"<p>Takes the transaction data, decodes it and builds data structures to be used in further circuits. Additionally, it performs checks on transactions fields. Listed below is all the built data and all the checks that this circuit performs.</p> <ul> <li>Decoders/Build</li> <li>decodes <code>txCompressedData</code> as specified here</li> <li>builds <code>txCompressedDataV2</code> as specified here</li> <li>builds L1-L2 data availability <code>L1L2TxData</code> as specificied here</li> <li>builds message to sign by L2 transactions <code>sigL2Hash</code> as specified here</li> <li>build L1 full data <code>L1TxFullData</code> as specified here</li> <li>Checks</li> <li>L1 transactions must be processed before L2 transactions<ul> <li>only switching from L1 to L2 is allowed</li> </ul> </li> <li>checks <code>newAccount</code> is set to true only when it is an L1 transaction and <code>fromIdx</code> is 0</li> <li><code>idx</code> to be assigned to a new account creation is incremented and checked only if the transaction involves an account creation</li> <li>checks <code>chainID</code> transaction field matches <code>globalChainID</code> forced by the smart contract</li> <li>checks <code>signatureConstant</code> transaction field matches the hardcoded value <code>CONST_SIG</code> set in the circuit</li> <li>checks <code>maxNumBatch</code> signed in the transaction is greater or equal to <code>currentNumBatch</code> only if <code>maxNumBatch != 0</code></li> <li>Global variables:</li> <li><code>nLevels</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_4","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_3","title":"Inputs","text":"Input type Description previousOnChain bool determines if previous transaction is L1 txCompressedData uint241 encode transaction fields together maxNumBatch uint32 maximum allowed batch number when the transaction can be processed amountF uint40 amount to transfer from L2 to L2 encoded as float40 toEthAddr uint160 ethereum address receiver toBjjAy field babyjubjub y coordinate receiver rqTxCompressedDataV2 uint193 requested encode transaction fields together version 2 rqToEthAddr uint160 requested ethereum address receiver rqToBjjAy field requested babyjubjub y coordinate fromEthAddr uint160 ethereum address sender fromBjjCompressed[256] boolean array babyjubjub compressed sender loadAmountF uint40 amount to deposit from L1 to L2 encoded as float40 globalChainID uint16 global chain identifier currentNumBatch uint32 current batch number onChain bool determines if the transaction is L1 or L2 newAccount bool determines if transaction creates a new account auxFromIdx uint48 auxiliary index to create accounts auxToIdx uint48 auxiliary index when signed index receiver is set to null inIdx uint48 old last index assigned"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_3","title":"Outputs","text":"Output type Description L1L2TxData array boolean L1-L2 data availability txCompressedDataV2 uint193 encode transaction fields together version 2 L1TxFullData array boolean L1 full data outIdx uint48 old last index assigned fromIdx uint48 index sender toIdx uint48 index receiver amount uint192 amount to transfer from L2 to L2 tokenID uint32 token identifier nonce uint40 nonce userFee uint8 user fee selector toBjjSign boolean babyjubjub sign receiver sigL2Hash field hash L2 data to sign"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#fee-accumulator","title":"fee-accumulator","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_5","title":"Description","text":"<p>Updates the fees accumulated by each transaction given its fee.</p> <ul> <li>Definitions:</li> <li><code>tokenID</code>: token to update</li> <li><code>feePlanTokenID[numTokens]</code>: array of all the tokenID that fees will be accumulated</li> <li><code>accFeeIn[numTokens]</code>: initial array of all fees accumulated</li> <li><code>fee2Charge</code>: effective fee charged in a transaction</li> <li><code>accFeeOut[numTokens]</code>: final array of all fees accumulated</li> <li>Steps:</li> <li>find the position on the array <code>feePlanTokenID[numTokens]</code> where its element matches the current transaction <code>tokenID</code><ul> <li>if no match found, no fee would be accumulated and <code>accFeeIn[0..numTokens] == accFeeOut[0..numTokens]</code></li> </ul> </li> <li>if a match is found:<ul> <li>accumulate the fee <code>fee2Charge</code> inside its position <code>i</code> on <code>accFeeOut[i]</code></li> <li>avoid accumulate fees once the match is found</li> </ul> </li> <li>Global variables:</li> <li><code>maxFeeTx</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_5","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_4","title":"Inputs","text":"Input type Description tokenID uint32 tokenID transaction fee2Charge uint192 fee charged feePlanTokenID[maxFeeTx] uint32 array all tokens eligible to accumulate fees accFeeIn[maxFeeTx] uint192 array initial fees accumulated"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_4","title":"Outputs","text":"Output type Description accFeeOut[maxFeeTx] uint192 array final fees accumulated"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#rq-tx-verifier","title":"rq-tx-verifier","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_6","title":"Description","text":"<p>Required transaction offset <code>rqTxOffset</code> is the relative index of the transaction that would be linked. This implementation adds atomics swaps support since one transaction is linked to another by this relative index meaning that a transaction can only be processed if the linked transaction is processed too.</p> <p>The next circuit aims to check the past and future data transactions to match the required data signed.</p> <p>Data to be signed in order to link transactions can be found here</p> rqTxOffset relativeIndex 0 no linked transaction 1 1 2 2 3 3 4 -4 5 -3 6 -2 7 -1 <p>Note that setting <code>rqTxOffset</code> to 0 means that no transaction is linked</p> <ul> <li>Steps:</li> <li>get data of future/past transactions</li> <li>get relative index and current required data</li> <li>check required data matched the future/past transaction</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_6","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#input_1","title":"Input","text":"Input type Description futureTxCompressedDataV2[3] uint192 array future transactions txCompressedDataV2 pastTxCompressedDataV2[4] uint192 array past transactions txCompressedDataV2 futureToEthAddr[3] uint160 array future transactions toEthAddr pastToEthAddr[4] uint160 array past transactions toEthAddr futureToBjjAy[3] field array future transactions toBjjAy pastToBjjAy[4] field array past transactions toBjjAy rqTxCompressedDataV2 uint192 requested encode transaction fields together version 2 rqToEthAddr uint160 requested ethereum address receiver rqToBjjAy field requested babyjubjub y coordinate rqTxOffset uint3 relative linked transaction"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#output","title":"Output","text":"<p>None</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#hash-inputs","title":"hash-inputs","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_7","title":"Description","text":"<p>Take all the intended public inputs and hash them all together to build a single public input for the circuit. The intended public inputs will turn into private inputs of the circuit.</p> <p>Note that this single input will be built by the smart contract. Therefore, proof must match all the data hashed in the <code>input hash</code> which is built inside the circuit from private signals.</p> <p>checkout here definition of global settings</p> <p>Specification for computing <code>hashInputs</code> can be found here</p> <ul> <li>Global variables:</li> <li><code>nLevels</code></li> <li><code>nTx</code></li> <li><code>maxL1Tx</code></li> <li><code>maxFeeTx</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_7","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_5","title":"Inputs","text":"Input type Description oldLastIdx uint48 old last merkle tree index created newLastIdx uint48 new last merkle tree index created oldStateRoot field old state root newStateRoot field new state root newExitRoot field new exit root L1TxsFullData[maxL1Tx * (2*nLevels + 32 + 40 + 40 + 256 + 160)] boolean array bits L1 full data L1L2TxsData[nTx * (2*nLevels + 40 + 8)] boolean array bits L1-L2 transaction data-availability feeTxsData[maxFeeTx] uint48 array all index accounts to  receive accumulated fees globalChainID uint16 global chain identifier currentNumBatch uint32 current batch number processed"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#ouputs","title":"Ouputs","text":"Output type Description hashInputsOut field sha256 hash of intended public inputs"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#fee-tx","title":"fee-tx","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_8","title":"Description","text":"<p>This circuit handles each fee transaction. Fee transaction takes the accumulate fees for a given <code>tokenID</code> and updates the recipient where the fees are wanted to be paid. It checks account existence with the old state root, process the account update and compute the new state root.</p> <p><code>TokenID</code> must match between fee accumulated and recipient account in order to not update wrong recipients.</p> <p>Besides, if coordinator does not fulfill all the possible recipient to receive fees, fee transaction could be a NOP transaction by setting the recipient to the null index (<code>IDX 0</code>)</p> <ul> <li>Steps:</li> <li>check if <code>idxFee</code> is zero</li> <li><code>NOP</code> transaction if <code>idxFee</code> is zero. Otherwise:<ul> <li>check match <code>planTokenID</code> and <code>tokenID</code> for updating the state</li> <li>compute merkle tree processor function (<code>UPDATE</code> or <code>NOP</code>)</li> <li>compute old state value (old account balance)</li> <li>compute new state value (old account balance + accumulate fee)</li> <li>merkle tree processor to compute account update and get new state root</li> </ul> </li> <li>Global variables:</li> <li><code>nLevels</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_8","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_6","title":"Inputs","text":"Input type Description oldStateRoot field old state root feePlanToken uint32 token identifier of fees accumulated feeIdx uint48 merkle tree index to receive fees accFee uint192 accumulated fees to transfer tokenID uint32 tokenID of leaf feeIdx nonce uint40 nonce of leaf feeIdx sign bool sign of leaf feeIdx balance uint192 balance of leaf feeIdx ay field ay of leaf feeIdx ethAddr uint160 ethAddr of leaf feeIdx siblings[nLevels + 1] field array siblings merkle proof"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_5","title":"Outputs","text":"Output type Description newStateRoot field new state root"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#compute-fee","title":"compute-fee","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_9","title":"Description","text":"<p>Computes the final amount of fee to apply given the fee selector</p> <ul> <li>Steps:</li> <li>selects fee factor, <code>feeOut</code>, to apply given <code>feeSel</code> and <code>applyFee</code></li> <li>compute <code>feeOutNotShifted = amount * feeOut</code> and convert it into bits in <code>feeOutBits[253]</code></li> <li>compute <code>applyShift</code> to decide if shift has to be applied to <code>feeOutNotShifted</code></li> <li>select bits on <code>feeOutBits[253]</code> depending on <code>applyShift</code> flag</li> <li>assert <code>feeOut</code> is \\(&lt; 2^{128}\\)</li> </ul> <p>It should be noted that <code>feeShiftTable[x]</code> are values hardcoded in the circuit that will match the fee factor shifted</p> <p>60 bits has been chosen in order to optimize precision at the time to compute fees. 60 bits is the minimum bits to achieve enough precision according fee table values</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_9","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_7","title":"Inputs","text":"Input type Description feeSel Uint8 fee selector amount Uint128 amount to apply the fee factor applyFee boolean determines if fee needs to be computed or if it is 0"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_6","title":"Outputs","text":"Output type Description feeOut Uint128 amount * feeFactor"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#balance-updater","title":"balance-updater","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_10","title":"Description","text":"<p>This circuit checks if there is enough balance in the sender account to do the transfer to the receiver account.</p> <p>It computes the new balances for the sender and the receiver. Besides, returns the fee that will be charged and if the amount to transfer is 0 (<code>isP2Nop</code> signal). These signals will be used in further circuits.</p> <p>It should be noted that in L1 tx, no errors are allowed but the circuit needs to process them. Hence, in case it is not enough balance on the sender account, it will process the transaction as a 0 amount transfer. Hence, signal <code>isAmountNullified</code> will notify if a L1 transaction has been nullified if it is invalid. This <code>isAmountNullified</code> will be used to compute data-availability where the amount used would not be inserted in <code>L1L2TxsData</code> since L1Tx is not valid or triggers underflow. In case of an L2 tx, the protocol does not allow to do a transaction if there is not enough balance in the sender account.</p> <ul> <li>The following assumptions have been taken:</li> <li>smart contract filters <code>loadAmount</code> above 2^128</li> <li>smart contract filters <code>amount</code> above 2^192</li> <li>circuit reserves 192 bits for the balance of an account</li> <li>overflow applies only if more than 2^64 transactions are done</li> <li>assume overflow is not feasible</li> <li>Steps:</li> <li>compute fee to be applied(<code>fee2Charge</code>)</li> <li>compute effective amount (<code>effectiveAmount1</code> and <code>effectiveAmount2</code>)</li> <li>check underflow (<code>txOk</code>)</li> <li>compute new balances from sender and receiver (<code>newStBalanceSender</code> and <code>newStBalanceReceiver</code>)</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_10","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_8","title":"Inputs","text":"Input type Description oldStBalanceSender field initial sender balance oldStBalanceReceiver field initial receiver balance amount uint192 amount to transfer from L2 to L2 loadAmount uint192 amount to deposit from L1 to L2 feeSelector uint8 user selector fee onChain bool determines if the transaction is L1 or L2 nop bool determines if the transfer amount and fees are considered 0 nullifyLoadAmount bool determines if loadAmount is considered to be 0 nullifyAmount bool determines if amount is considered to be 0"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_7","title":"Outputs","text":"Output type Description newStBalanceSender uint192 final balance sender newStBalanceReceiver uint192 final balance receiver isP2Nop bool determines if processor 2 performs a NOP transaction fee2Charge uint192 effective transaction fee isAmountNullified uint32 determines if the amount is nullified"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#rollup-tx-states","title":"rollup-tx-states","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_11","title":"Description","text":"<p>This circuit is a subset of the <code>rollup-tx</code> circuit. It has been split for clarity.</p> <p>Transaction states are computed depending on transaction's type. All transaction types can be found here</p> <p>Note that L1 coordinator transactions are treated as L1 user <code>createAccountDeposit</code> inside the circuit. Circuit does not differentiate transactions taking into account its source, either launched by user or by coordinator.</p> <p>Sender and receiver accounts have their own Merkle tree processors inside the circuit in order to perform actions on their leaves:   - sender: processor 1   - receiver: processor 2</p> <p>The following table summarizes all the processor actions:</p> func[0] func[1] Function 0 0 NOP 0 1 UPDATE 1 0 INSERT 1 1 DELETE <p>Therefore, given the transaction type, it is needed to specify certain signals that would be used in <code>rollup-tx</code> circuit:   - <code>isP1Insert</code>: determines if processor 1 performs an INSERT function (sender)   - <code>isP2Insert</code>: determines if processor 2 performs an INSERT function (receiver)   - <code>key1</code>: set key to be used in processor 1   - <code>key2</code>: set key to be used in processor 2   - <code>P1_fnc0</code> and <code>P1_fnc1</code>: selectors for processor 1   - <code>P2_fnc0</code> and <code>P2_fnc1</code>: selectors for processor 2   - <code>isExit</code>: determines if the transaction is an exit type   - <code>verifySignEnable</code>: enable babyjubjub signature checker   - <code>nop</code>: transaction is processed as a NOP transaction   - <code>checkToEthAddr</code>: enable <code>toEthAddr</code> check   - <code>checkToBjj</code>: enable <code>toBjjAy</code> and <code>toBjjSign</code> check</p> <p>Following truth table determines how to set the above signals depending on transaction inputs:</p> <p>Note that italics make reference to outputs, regular makes reference to inputs</p> Transaction type fromIdx auxFromIdx toIdx auxToIdx toEthAddr onChain newAccount loadAmount amount newExit isP1Insert isP2Insert processor 1 processor 2 isExit verifySignEnable nop checkToEthAddr checkToBjj createAccount 0 key1 0 0 0 1 1 0 0 0 1 0 INSERT UPDATE 0 0 0 0 0 createAccountDeposit 0 key1 0 0 0 1 1 X 0 0 1 0 INSERT UPDATE 0 0 0 0 0 createAccountDepositTransfer 0 key1 key2 0 0 1 1 X X 0 1 0 INSERT UPDATE 0 0 0 0 0 deposit key1 0 0 0 0 1 0 X 0 0 0 0 UPDATE UPDATE 0 0 0 0 0 depositTransfer key1 0 key2 0 0 1 0 X X 0 0 0 UPDATE UPDATE 0 0 0 0 0 forceTransfer key1 0 key2 0 0 1 0 0 X 0 0 0 UPDATE UPDATE 0 0 0 0 0 forceExit key1 - key2 0 1 0 0 1 0 0 X 0: UPDATE, 1: INSERT 0 X: UPDATE, 0: INSERT UPDATE EXIT INSERT - UPDATE 1 0 0 0 0 transfer key1 0 key2 0 0 0 0 0 X 0 0 0 UPDATE UPDATE 0 1 0 0 0 exit key1 - key2 0 1 0 0 0 0 0 X 0: UPDATE, 1: INSERT 0 X: UPDATE, 0: INSERT UPDATE EXIT INSERT - UPDATE 1 1 0 0 0 transferToEthAddr key1 0 0 key2 ANY_ETH_ADDR != 0xF..F 0 0 0 X 0 0 0 UPDATE UPDATE 0 1 0 1 0 transferToBjj key1 0 0 key2 ANY_ETH_ADDR == 0xF..F 0 0 0 X 0 0 0 UPDATE UPDATE 0 1 0 1 1 nop 0 0 0 0 0 0 0 0 0 0 0 0 NOP NOP 0 0 1 0 0 <p>L1 invalid transactions should not be allowed but the circuit needs to process them even if they are not valid. In order to do so, the circuit performs a zero <code>loadAmount</code> \\ <code>amount</code> update if L1 transaction is not valid. Therefore, circuit nullifies <code>loadAmount</code> \\ <code>amount</code> if L1 invalid transaction is detected.</p> <p>Next table sets when to apply <code>nullifyLoadAmount</code> \\ <code>nullifyAmount</code> depending L1 transaction type:</p> <p>Note that <code>nullifyLoadAmount</code> \\ <code>nullifyAmount</code> fields are set to 1 only if <code>checks</code> are not successful and L1 transfers are only allowed if <code>tokenID == tokenID1 == tokenID2</code> as a sanity check</p> Transaction type newAccount isLoadAmount isAmount checkEthAddr checkTokenID1 checkTokenID2 nullifyLoadAmount nullifyAmount createAccount 1 0 0 0 0 0 0 0 createAccountDeposit 1 1 0 0 0 0 0 0 createAccountDepositTransfer 1 1 1 0 0 1 0 1 deposit 0 1 0 0 1 0 1 0 depositTransfer 0 1 1 1 1 1 1 1 forceTransfer 0 0 1 1 1 1 0 1 forceExit 0 0 1 1 1 1 if newExit = 0 0 1"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_11","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_9","title":"Inputs","text":"Input type Description fromIdx uint48 index sender toIdx uint48 index receiver toEthAddr uint160 ethereum address receiver auxFromIdx uint48 auxiliary index to create accounts auxToIdx uint48 auxiliary index when signed index receiver is set to null amount uint192 amount to transfer from L2 to L2 newExit bool determines if the transaction create a new account in the exit tree loadAmount uint192 amount to deposit from L1 to L2 newAccount bool determines if transaction creates a new account onChain bool determines if the transaction is L1 or L2 fromEthAddr uint160 ethereum address sender ethAddr1 uint160 ethereum address of sender leaf tokenID uint32 tokenID signed in the transaction tokenID1 uint32 tokenID of the sender leaf tokenID2 uint32 tokenID of the receiver leaf"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_8","title":"Outputs","text":"Output type Description isP1Insert bool determines if processor 1 performs an INSERT function (sender) isP2Insert bool determines if processor 2 performs an INSERT function (receiver) key1 uint48 processor 1 key key2 uint48 processor 2 key P1_fnc0 bool processor 1 bit 0 functionality P1_fnc1 bool processor 1 bit 1 functionality P2_fnc0 bool processor 2 bit 0 functionality P2_fnc1 bool processor 2 bit 1 functionality isExit bool determines if the transaction is an exit verifySignEnabled bool determines if the eddsa signature needs to be verified nop bool determines if the transaction should be considered as a NOP transaction checkToEthAddr bool determines if receiver ethereum address needs to be checked checkToBjj bool determines if receiver babyjubjub needs to be checked nullifyLoadAmount bool determines if loadAmount is considered to be 0 nullifyAmount bool determines if amount is considered to be 0"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#rollup-tx","title":"rollup-tx","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_12","title":"Description","text":"<p>This circuit includes all the rules given a transaction. Hence, <code>rollup-tx</code> includes the previous specified circuits: - <code>rollup-tx-states</code> - <code>rq-tx-verifier</code> - <code>balance-updater</code> - <code>fee-accumulator</code></p> <p>For the sake of clarity, this circuit could be split internally into phases: - A: compute transaction states - B: check request transaction - C: checks state fields - D: compute hash old states - E: signal processor selectors - F: verify eddsa signature - G: update balances - H: accumulate fess - I: compute hash new states - J: smt processors - K: select output roots</p> <ul> <li>Global variables:</li> <li><code>nLevels</code></li> <li><code>maxFeeTx</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_12","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_10","title":"Inputs","text":"Input type Description feePlanTokens[maxFeeTx] uint32 array all tokens eligible to accumulate fees accFeeIn[maxFeeTx] uint192 array initial fees accumulated futureTxCompressedDataV2[3] uint193 array future transactions txCompressedDataV2 pastTxCompressedDataV2[4] uint193 array past transactions toEthAddr futureToEthAddr[3] uint160 array future transactions toEthAddr pastToEthAddr[4] uint160 array past transactions toEthAddr futureToBjjAy[3] field array future transactions toBjjAy pastToBjjAy[4] field array past transactions toBjjAy fromIdx uint48 index sender auxFromIdx uint48 auxiliary index to create accounts toIdx uint48 index receiver auxToIdx uint48 auxiliary index when signed index receiver is set to null toBjjAy field babyjubjub y coordinate receiver toBjjSign bool babyjubjub sign receiver toEthAddr uint160 ethereum address receiver amount uint192 amount to transfer from L2 to L2 tokenID uint32 tokenID signed in the transaction nonce uint40 nonce signed in the transaction userFee uint16 user fee selector rqOffset uint3 relative linked transaction onChain bool determines if the transaction is L1 or L2 newAccount bool determines if transaction creates a new account rqTxCompressedDataV2 uint193 requested encode transaction fields together version 2 rqToEthAddr uint160 requested ethereum address receiver rqToBjjAy field requested babyjubjub y coordinate sigL2Hash field hash L2 data to sign s field eddsa signature field r8x field eddsa signature field r8y field eddsa signature field fromEthAddr uint160 ethereum address sender fromBjjCompressed[256] boolean array babyjubjub compressed sender loadAmountF uint40 amount to deposit from L1 to L2 encoded as float40 tokenID1 uint32 tokenID of the sender leaf nonce1 uint40 nonce of the sender leaf sign1 bool sign of the sender leaf balance1 uint192 balance of the sender leaf ay1 field ay of the sender leaf ethAddr1 uint160 ethAddr of the sender leaf siblings1[nLevels + 1] field array siblings merkle proof of the sender leaf isOld0_1 bool flag to require old key - value oldKey1 uint48 old key of the sender leaf oldValue1 field old value of the sender leaf tokenID2 uint32 tokenID of the receiver leaf nonce2 uint40 nonce of the receiver leaf sign2 bool sign of the receiver leaf balance2 uint192 balance of the receiver leaf ay2 field ay of the receiver leaf ethAddr2 uint160 ethAddr of the receiver leaf siblings2[nLevels + 1] field array siblings merkle proof of the receiver leaf isOld0_2 bool flag to require old key - value oldKey2 uint48 old key of the receiver leaf oldValue2 field old value of the receiver leaf oldStateRoot field initial state root oldExitRoot field initial exit root"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#ouputs_1","title":"Ouputs","text":"Output type Description isAmountNullified bool determines if the amount is nullified accFeeOut[maxFeeTx] uint192 array final fees accumulated newStateRoot field final state root newExitRoot field final exit root"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#rollup-main","title":"rollup-main","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_13","title":"Description","text":"<p>Join all transactions and process them. This includes, decode all possible transactions, process them and distribute all the fees through fee transactions.</p> <p>It is important to note that the templates included in this main circuit are intended to be computed in parallel. Meaning that the output of the very first transaction could be computed as it output is not necessary to compute the next transaction. Then, all transactions could be computed in parallel. In order to achieve that, it is needed to supply intermediate signals to allow modules parallelization.</p> <p>All signals prefixed with <code>im</code> are intermediary signals. Note that in circuit phases, there are specific phases to check integrity of intermediary signals. This adds constraints to the circuit, since it is needed to provided transactions output in advance, but it allows high parallelization at the time to compute the witness.</p> <p>Note that there is only one public input, <code>hashGlobalInputs</code>, which is a sha256 hash of all the intended public inputs of the circuit. This is done in order to save gas in the contract by just passing one public input.</p> <ul> <li>Global variables:</li> <li><code>nTx</code></li> <li><code>nLevels</code></li> <li><code>maxL1Tx</code></li> <li><code>maxFeeTx</code></li> </ul> <p>Main circuit could be split in the following phases: - A: decode transactions - B: check binary signals - C: check integrity decode intermediary signals - D: process transactions - E: check integrity transactions intermediary signals - F: process fee transactions - G: check integrity fee transactions intermediary signals - H: compute global hash input</p> <p>In section H, only bits associated to <code>amountF</code> in <code>L1L2TxsData</code> are multiplied by <code>isAmountNullififed</code>. Note that this only applies for invalid L1 transactions.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_13","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_11","title":"Inputs","text":"Input type Description oldLastIdx uint48 old last index assigned oldStateRoot field initial state root globalChainID uint16 global chain identifier currentNumBatch uint32 current batch number processed feeIdxs[maxFeeTx] uint48 array merkle tree indexes to receive fees feePlanTokens[maxFeeTx] uint32 array tokens identifiers of fees accumulated imOnChain[nTx-1] boolean array intermediary signals: decode transaction output onChain flag imOutIdx[nTx-1] uint48 array intermediary signals: decode transaction final index assigned imStateRoot[nTx-1] field array intermediary signals: transaction final state root imExitRoot[nTx-1] field array intermediary signals: transaction final exit root imAccFeeOut[nTx-1][maxFeeTx] uint192 array array intermediary signals: transaction final accumulated fees imStateRootFee[maxFeeTx - 1] field array intermediary signals: transaction fee final state root imInitStateRootFee field intermediary signals: final state root of all rollup transactions imFinalAccFee[maxFeeTx] field array intermediary signals: final fees accumulated of all rollup transactions txCompressedData[nTx] uint241 array encode transaction fields together amountF[nTx] uint40 array amount to transfer from L2 to L2 encoded as float40 txCompressedDataV2[nTx] uint193 array encode transaction fields together version 2 fromIdx[nTx] uint48 array index sender auxFromIdx[nTx] uint48 array auxiliary index to create accounts toIdx[nTx] uint48 array index receiver auxToIdx[nTx] uint48 array auxiliary index when signed index receiver is set to null toBjjAy[nTx] field array babyjubjub y coordinate receiver toEthAddr[nTx] uint160 array ethereum address receiver maxNumBatch[nTx] uint32 array maximum allowed batch number when the transaction can be processed onChain[nTx] bool array determines if the transaction is L1 or L2 newAccount[nTx] bool array determines if transaction creates a new account rqTxCompressedDataV2[nTx] uint193 array requested encode transaction fields together version 2 rqToEthAddr[nTx] uint160 array requested ethereum address receiver rqToBjjAy[nTx] field array requested babyjubjub y coordinate s[nTx] field array eddsa signature field r8x[nTx] field array eddsa signature field r8y[nTx] field array eddsa signature field loadAmountF[nTx] uint40 array amount to deposit from L1 to L2 encoded as float40 fromEthAddr[nTx] uint160 array ethereum address sender fromBjjCompressed[nTx][256] boolean array array babyjubjub compressed sender tokenID1[nTx] uint32 array tokenID of the sender leaf nonce1[nTx] uint40 array nonce of the sender leaf sign1[nTx] bool array sign of the sender leaf balance1[nTx] uint192 array balance of the sender leaf ay1[nTx] field array ay of the sender leaf ethAddr1[nTx] uint160 array ethAddr of the sender leaf siblings1[nTx][nLevels + 1] field array array siblings merkle proof of the sender leaf isOld0_1[nTx] bool array flag to require old key - value oldKey1[nTx] uint48 array old key of the sender leaf oldValue1[nTx] field array old value of the sender leaf tokenID2[nTx] uint32 array tokenID of the receiver leaf nonce2[nTx] uint40 array nonce of the receiver leaf sign2[nTx] bool array sign of the receiver leaf balance2[nTx] uint192 array balance of the receiver leaf ay2[nTx] field array ay of the receiver leaf ethAddr2[nTx] uint160 array ethAddr of the receiver leaf siblings2[nTx][nLevels + 1] field array array siblings merkle proof of the receiver leaf isOld0_2[nTx] bool array flag to require old key - value oldKey2[nTx] uint48 array old key of the sender leaf oldValue2[nTx] field array old value of the sender leaf tokenID3[maxFeeTx] uint32 array tokenID of leafs feeIdxs nonce3[maxFeeTx] uint40 array nonce of leafs feeIdxs sign3[maxFeeTx] bool array sign of leafs feeIdxs balance3[maxFeeTx] uint192 array balance of leafs feeIdxs ay3[maxFeeTx] field array ay of leafs feeIdxs ethAddr3[maxFeeTx] uint160 array ethAddr of leafs feeIdxs siblings3[maxFeeTx][nLevels + 1] field array array siblings merkle proof of leafs Idxs"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_9","title":"Outputs","text":"Output type Description hashGlobalInputs field hash of all intended input signals"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#withdraw","title":"withdraw","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#description_14","title":"Description","text":"<p>This circuit is used to prove that a leaf exist on the exit tree. If its existence is proved, user will be able to withdraw funds from the Hermez contract. All intended public inputs are hashed together as described here.</p> <ul> <li>Steps:</li> <li>compute hash-state</li> <li>verify state exist in the exit tree root given the siblings</li> <li>compute <code>hashGlobalInputs</code></li> </ul> <p>It should be noted that this circuit is heavily attached to the hermez smart contract</p> <ul> <li>Global variables</li> <li><code>nLevels</code></li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#schematic_14","title":"Schematic","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#inputs_12","title":"Inputs","text":"Input type Description root exit field exit tree root ethAddr uint160 ethereum address tokenID uint32 token identifier balance uint192 balance idx uint48 merkle tree index sign boolean babyjubjub sign ay field babyjubjub y coordinate siblingsState[nLevels +  1] field array siblings merkle proof"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/circuits/circuits/#outputs_10","title":"Outputs","text":"Output type Description hashGlobalInputs field hash of all intended input signals"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/","title":"Hermez smart contracts","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#glossary","title":"Glossary","text":"<ul> <li>Batch: Set of transactions that determines a state transition of the accounts and sets an exit tree.</li> <li>L2-Batch: The set of transactions are only L2</li> <li>L1-L2-Batch: The set of transactions are L1 or L2</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#hermez-general-goals","title":"Hermez General Goals","text":"<ul> <li>Handle L1-user transactions</li> <li>Ensure that these transactions are forged</li> <li>Forge batches</li> <li>Ask consensus algorithm for coordinator approval</li> <li>Add L1 Coordinator Transactions</li> <li>Ensures that state transitions are valid through a validity proof which will assure that certain rules have been fulfilled.</li> <li>Set a new state Merkle root and exit Merkle root</li> <li>Utility actions</li> <li>Withdraw funds or add new tokens to the rollup</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#handle-l1-user-transactions","title":"Handle L1 User Transactions","text":"<p>All L1UserTx are encoded and added to a queue, when the queue is full or frozen, a new queue is created. Once a queue is frozen means that L1 transactions can't be added anymore. Each queue is identified by an index that grows incrementally. The queue index of the next L1-L2-batch is always frozen which is identified by <code>nextL1ToForgeQueue</code></p> <p>When a user calls a function that adds an L1UserTx, the following happens:</p> <ul> <li>Storage</li> <li>Add the L1UserTx data at the end of the last non-frozen non-full queue of L1UserTxs (<code>mapL1TxQueue[nextL1FillingQueue]</code>).<ul> <li>The queue index in which this data is added is identified by <code>nextL1FillingQueue</code></li> <li>The L1UserTxs is encoded as a byte array data and appended to the queue</li> <li>Once the <code>nextL1FillingQueue</code> is full, increment the <code>nextL1FillingQueue</code></li> </ul> </li> <li>Event Information</li> <li>nextL1FillingQueue</li> <li>position</li> <li>L1UserTx data (72 bytes)</li> </ul> <p>In the global spec, all L1 user transactions are specified</p> <p>The <code>L1TxQueue</code> has a lenght of <code>MAX_L1_TX</code>, L1UserTx can fulfill till <code>MAX_L1_USER_TX</code>, therefore always are some slots reserved for the L1-coordinator-Tx: <code>MAX_L1_TX - len(L1_USER_TXS)</code></p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#utility-actions","title":"Utility Actions","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#add-tokens","title":"Add Tokens","text":"<p>Hermez has a list of all the tokens that the rollup supports. Tokens must be an ERC20, and everyone can add a new token with this method. A fee in HEZ must be payed to the governance address.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#withdraw","title":"Withdraw","text":"<p>Transaction to get funds back from the smart contract to Ethereum address. This is done by proving the existence of a leaf in the exit tree. Once the withdrawal is done a nullifier is set, so this only can happen once.</p> <p>Remember withdraw is not a L1 transaction, it has no impact in the state or exit trees and it's not processed by the circuit.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#forging","title":"Forging","text":"<p>The <code>forgeBatch</code> functionality depends on a consensus mechanism to decide who can be the coordinator of a given batch. Separate from the rollup smart contract, there is an external smart contract that implements the consensus mechanism and maintains its own state. During a forge call in the rollup smart contract, a call is made to the consensus smart contract to validate if the caller coordinator is allowed to forge and also to allow the consensus smart contract to update its own state and perform consensus actions if necessary.</p> <p>Then, the coordinator will add his L1-coordinator-transactions and will verify the circuit proof against the verifier smart contract as we can see in the previous diagram</p> <p>There are 2 kind of <code>forgeBatch</code>, a flag in the function will distinguish between them</p> <ul> <li>L2-batch</li> <li>Forge L2 and L1 coordinator transactions, L1 User transactions are not mined.</li> <li>L1-L2-batch</li> <li>Forge L1 user, L1 coordinator and L2 transactions. The coordinator must forge all the L1 transactions in the first frozen queue</li> <li>Optionally coordinator can add L1-coordinator-transactions</li> <li>Set a new state and exit root</li> <li>Delete the current frozen queue and freeze the next one</li> </ul> <p>In order to force the coordinator to forge the L1 transactions, but also allow him to parallelize his proof computation, the contract establishes a deadline for the L1-L2-batches. All L1-L2-batches reset the deadline, so, as shown in the diagram, the coordinator is free to choose to forge L2-batches or L1-L2-batches until the deadline, when only L1-L2-batches are accepted.</p> <p></p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#l1-coordinator-transactions","title":"L1 Coordinator Transactions","text":"<p>In the global spec all of the L1 coordinator transactions  are specified</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#data-availability","title":"Data availability","text":"<ul> <li>L1-User-Tx --&gt; Events</li> <li>L1-Coordinator-Tx --&gt; <code>forgeBatch</code> ethereum Tx Input</li> <li>L2-Tx --&gt; <code>forgeBatch</code> ethereum Tx Input</li> </ul> <p>In order to provide data availability the <code>forgeBatch</code> transaction inputs must be recovered. To allow this data retrieval from a regular Ethereum node, Hermez must force that the call is not made from another smart contract:</p> <pre><code>assert(msg.sender == tx.origin)\n\n</code></pre>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#governance","title":"Governance","text":"<p>The governance will be able to set the following parameters:</p> <ul> <li>forgeL1L2BatchTimeout</li> <li>Number of Ethereum blocks after the last L1-L2-batch after which only an L1-L2-batch can be forged</li> <li>feeAddToken</li> <li>Fee in HEZ tokens that must be payed to the governance to add a new token into the rollup</li> <li>tokenExchange</li> <li>Update the tokenUSD value for the instant Withdraw purposes</li> <li>withdrawalDelay</li> <li>Delay in seconds of the delayed withdraw</li> <li>buckets</li> <li>Update buckets parameters for the instant Withdraw purposes</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#emergency-mechanism","title":"Emergency Mechanism","text":""},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#goal","title":"Goal","text":"<p>This logic is implemented during the bootstrapping phase of the network as an additional security measure to mitigate attacks that could potentially provide illegitimate access to user funds from Hermez Network. The objective is to temporarily enable this last-resort measure while preserving decentralization.</p> <p>The core mechanism is to set a withdrawal limit in order to avoid infinite withdrawal in case of illegitimate funds access. Therefore, it is assured that the attacker can only withdraw a certain amount of tokens.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#hermez-withdraw-limit","title":"Hermez Withdraw Limit","text":"<p>There will be a histogram of maximum amount of withdrawals in a value range: - Limits the maximum amount to withdraw - Value range is set in USD - Buckets are filled in a blockRatio - If a withdraw reaches the histogram limit, an instant withdraw cannot be performed</p> <p>Every time a user tries to perform an instant withdraw: - Updates the counter of the histogram - If the counter is above the capacity of that range, instant withdraw is reverted</p> <p></p> <p>Note that <code>withdraw limit</code> would be the maximum amount of tokens that an attacker can withdraw since the contract will return <code>revert</code> when the instant withdraw is called again and there are no tokens left to send. The histogram is understood as buckets.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#mechanism","title":"Mechanism","text":"<p>The number of withdraws above the <code>withdraw limit</code> can not be withdrawn instantly, there will be a delay. Tokens will be sent to the <code>WithdrawalDelayer</code> smart contract.</p> <p>Users will be able to perform instant withdrawals as long as <code>Hermez Contract</code> does not reach the <code>withdrawal limit</code>, that is, it runs out of withdraws available in the bucket (in the bucket with that price range).</p> <p>Actions that will be taken if the <code>withdrawal limit</code> is reached are the following ones: - If a user does an <code>instantWithdraw</code>, <code>Hermez Contract</code> will return <code>revert</code>. - If a user does a <code>delayWithdraw</code>, it will be accepted and the tokens will be sent to <code>WithdrawalDelayer</code>. The user can withdraw their tokens but with a delay.</p> <p>There will be a delay time <code>withdrawalDelay</code> (parameter of the <code>WithdrawalDelayer</code> contract) during which the Hermez Foundation can decide if there has been an attack or not: - Not attack:   - When enough blocks have passed for the bucket to refill, <code>Hermez Contract</code> will accept <code>instantWithdraw</code> again, while withdrawals are available in the bucket. - Attack:   - The histogram values will all be set to 0 (change to <code>safe mode</code>) so that all tokens are sent to <code>WithdrawalDelayer</code> until the histogram values are changed again. - If a decision is not made in the defined period:   - When enough blocks have passed for the bucket to refill, <code>Hermez Contract</code> will accept <code>instantWithdraw</code> again.</p> <p></p> <p>During the bootstrapping phase, Hermez devs team will be monitoring constantly the system in order to detect possible anomalies and to be able to decide as soon as possible if the network is under an attack.</p>"},{"location":"Hermez_1.0/developers/protocol/hermez-protocol/contracts/contracts/#parameters","title":"Parameters","text":"<ul> <li>Bucket (part of histogram):</li> <li><code>ceilUSD</code>: maximum amount to allow instant withdrawals (bucket range)</li> <li><code>blockStamp</code>: last time a withdrawal was added ( or removed if the bucket was full)</li> <li><code>withdrawals</code>: available withdrawals of the bucket</li> <li><code>blockWithdrawalRate</code>: every x blocks add 1 withdrawal</li> <li><code>maxWithdrawals</code>: max withdrawals the bucket can hold</li> <li><code>NUM_BUCKETS</code>: number of buckets in histogram</li> <li><code>tokenExchange</code>: mapping <code>tokenAddress --&gt; USD value</code> (default 0, means that no limit applies)</li> </ul>"},{"location":"Hermez_1.0/developers/protocol/withdrawal-delayer/withdrawal-delayer/","title":"Withdrawal Delayer Protocol","text":""},{"location":"Hermez_1.0/developers/protocol/withdrawal-delayer/withdrawal-delayer/#goal","title":"Goal","text":"<p>As announced in the project whitepaper as well as the documentation, Hermez will be covering an initial phase of network bootstrapping where some additional security measures are deployed as a good practice for risk management.</p> <p>An automated limitation on withdrawals will be implemented as an additional checkpoint to identify anomalous behavior of the network. In such conditions, some time for the developers team to verify the system is required and to identify if the behavior has evolved and a change of security parameters is needed.</p> <p>The purpose of this smart contract is to delay the withdraw in case of anomalous behavior of the network. Users will be prompted to try again after some time or they can decide to use this delayed withdraw alternative with a guaranteed delay time. Hence, tokens will be held by the smart contract for a period of <code>D</code> and only afterward tokens could be really withdrawn.</p>"},{"location":"Hermez_1.0/developers/protocol/withdrawal-delayer/withdrawal-delayer/#actors","title":"Actors","text":"<ul> <li><code>hermezRollup</code>: Smart contract responsible for making deposits and it's able to change the delay</li> <li><code>hermezKeeperAddress</code>: can enable emergency mode and modify the delay to make a withdrawal</li> <li><code>hermezGovernanceDAOAddress</code>: can claim the funds in an emergency mode</li> <li><code>whiteHackGroupAddress</code>: can claim the funds in an emergency when <code>MAX_EMERGENCY_MODE_TIME</code> is exceeded</li> </ul> <p>These addresses can only be updated if the sender of the transaction that changes them is the current address.</p>"},{"location":"Hermez_1.0/developers/protocol/withdrawal-delayer/withdrawal-delayer/#mechanism","title":"Mechanism","text":"<p>When a certain state has been reached in <code>Hermez Contract</code>, the tokens will be sent to the <code>WithdrawalDelayer</code> contract.</p> <p>So, the tokens will be in the contract during period <code>D</code>. In that period it will be decided whether it was an attack or a normal process.</p> <p>That period <code>D</code> can only be changed by <code>hermezKeeperAddress</code> or by <code>hermezRollup</code>.</p> <p>Actions that will be taken if an attack is detected are the following ones:</p> <ul> <li>The <code>WithdrawalDelayer</code> contract will stay in <code>NORMAL_MODE</code> until it is decided that there has been an attack. Then, if there was an attack, it would go to <code>EMERGENCY_MODE</code> and the decision can not be reversed.</li> <li>Only <code>hermezKeeperAddress</code> will be able to put the system in <code>EMERGENCY_MODE</code>.</li> </ul> <p></p> <p>There will be a delay time <code>D</code> to decide if there has been an attack or not:</p> <ul> <li>No attack:<ul> <li><code>WithdrawalDelayer</code> remains in <code>NORMAL_MODE</code>, and users will be able to withdraw their tokens normally but with a delay</li> </ul> </li> <li>Attack:<ul> <li><code>WithdrawalDelayer</code> change to <code>EMERGENCY_MODE</code>, then only <code>GovernanceDAO</code> will be able to withdraw the funds</li> <li>Aragon court will have the option to reject proposals on how the <code>GovernanceDAO</code> will distribute the funds</li> <li>If after <code>MAX_EMERGENCY_MODE_TIME</code> the funds are still stopped, the <code>whiteHackGroupAddress</code> can withdraw the funds if they think it's necessary to avoid a permanent block</li> </ul> </li> </ul> <p></p>"},{"location":"Hermez_1.0/developers/protocol/withdrawal-delayer/withdrawal-delayer/#parameters","title":"Parameters","text":"<ul> <li><code>D</code>: delay to withdraw from <code>WithdrawalDelayer</code> measured in seconds</li> <li><code>MAX_WITHDRAWAL_DELAY</code>: maximum delay time to decide if it was an attack or not, measured in weeks --&gt; 2 weeks</li> <li><code>MAX_EMERGENCY_MODE_TIME</code>: maximum time that funds can stay in the contract, measured in weeks --&gt; 6 months (~ 26 weeks)</li> </ul>"},{"location":"Hermez_1.0/faq/coordinators/","title":"Coordinators","text":""},{"location":"Hermez_1.0/faq/coordinators/#overview","title":"Overview","text":""},{"location":"Hermez_1.0/faq/coordinators/#what-is-a-hermez-coordinator","title":"What is a Hermez Coordinator?","text":"<p>A Coordinator is our term for rollup block producer. At any one time, there is one Coordinator responsible for creating blocks on the rollup chain selected among a number of registered nodes via an auction process.</p>"},{"location":"Hermez_1.0/faq/coordinators/#how-many-coordinators-are-there","title":"How many Coordinators are there?","text":"<p>There is no limit to the number of registered Coordinators. Becoming a Coordinator is entirely permissionless via an auction process and it will be enabled shortly after launch.</p> <p>Although the first Coordinator will be the Hermez Boot Coordinator which will forge blocks when there are no alternative bids in the auction, it\u2019s important for us that the market for coordinators becomes open over time.</p>"},{"location":"Hermez_1.0/faq/coordinators/#how-is-the-coordinator-node-selected","title":"How is the Coordinator Node selected?","text":"<p>The Coordinator Node is selected using an auction process, where registered nodes bid for the right to forge batches during a time slot. The highest bidder in a given slot will become the Coordinator</p>"},{"location":"Hermez_1.0/faq/coordinators/#will-there-be-a-competitive-market-for-coordinators","title":"Will there be a competitive market for Coordinators?","text":"<p>We are committed to creating a competitive market for Coordinators and we will open-source software to allow anyone to run a Coordinator node.</p>"},{"location":"Hermez_1.0/faq/coordinators/#auction-process","title":"Auction Process","text":""},{"location":"Hermez_1.0/faq/coordinators/#how-do-i-become-a-coordinator","title":"How do I become a Coordinator?","text":"<p>To become a Coordinator you need to prepare the system infrastructure, take part in the auction, and win a bid for a time slot.</p>"},{"location":"Hermez_1.0/faq/coordinators/#how-are-bids-placed-in-the-auction","title":"How are bids placed in the auction?","text":"<p>Coordinators will participate in the auction by sending an on-chain transaction to the auction smart contract. Bids are always paid in HEZ.</p>"},{"location":"Hermez_1.0/faq/coordinators/#where-do-i-get-hez","title":"Where do I get HEZ?","text":"<p>HEZ can be easily obtained in Uniswap</p>"},{"location":"Hermez_1.0/faq/coordinators/#is-there-a-minimum-amount-of-hez-tokens-you-have-to-hold-to-be-a-coordinator","title":"Is there a minimum amount of HEZ tokens you have to hold to be a Coordinator?","text":"<p>You need to have at least as many tokens as your bid ammount.</p>"},{"location":"Hermez_1.0/faq/coordinators/#the-coordinator-i-am-running-has-lost-a-bid-where-does-the-bid-go","title":"The Coordinator I am running has lost a bid. Where does the bid go?","text":"<p>In case your bid didn't win the slot, the amount bid is transferred to the Auction smart contract under your account. You can use this amount for future bids, or withdraw it to the Coordinator account.</p>"},{"location":"Hermez_1.0/faq/coordinators/#how-long-are-coordinator-time-slots","title":"How long are Coordinator time slots?","text":"<p>Slots will be 40 Ethereum blocks long (10 minutes). During this time, a Coordinator can forge as many batches as possible.</p>"},{"location":"Hermez_1.0/faq/coordinators/#what-happens-if-the-coordinator-goes-offline","title":"What happens if the Coordinator goes offline?","text":"<p>If the Coordinator has not done anything in the first part a slot, then anyone can jump in and replace it by forging blocks (first come first served).</p>"},{"location":"Hermez_1.0/faq/coordinators/#how-do-coordinators-make-money","title":"How do Coordinators make money?","text":"<p>Coordinators set and collect the transaction fees. They can expect a revenue per transaction and each coordinator will select to forge the more profitable transactions from the transaction pool.</p> <p>They profit from these fees minus the operational costs and the bid price for the slot.</p>"},{"location":"Hermez_1.0/faq/coordinators/#running-a-coordinator","title":"Running a Coordinator","text":""},{"location":"Hermez_1.0/faq/coordinators/#what-are-the-infrastructure-requirements-to-run-a-coordinator","title":"What are the infrastructure requirements to run a Coordinator?","text":"<p>To run a Coordinator you need the following: - PostgreSQL database - Ethereum Node - Coordinator Server running the hermez-node repository. A reasonable server spec is AWS instance c5ad.2xlarge with 8 vCPU and 16GB RAM - Proof Server running the rapidsnark repository. A server spec able to run the ~2000 transaction circuit is AWS instance c5ad.24xlarge with 96 vCPU and 192GB RAM. </p>"},{"location":"Hermez_1.0/faq/coordinators/#is-there-a-step-by-step-guide-to-configure-a-coordinator-node","title":"Is there a step by step guide to configure a Coordinator node?","text":"<p>Yes. You can find this guide here.</p>"},{"location":"Hermez_1.0/faq/coordinators/#how-do-you-register-as-a-coordinator","title":"How do you register as a Coordinator?","text":"<p>You can use a JavaScript tool, cli-bidding to register your node as a Coordinator.</p>"},{"location":"Hermez_1.0/faq/coordinators/#how-many-transactions-can-be-processed-per-batch","title":"How many transactions can be processed per batch?","text":"<p>The number of transactions per batch depends on the circuit used. Hermez accepts two different circuit sizes: 400 transactions and 2048 transactions. </p>"},{"location":"Hermez_1.0/faq/coordinators/#i-am-having-technical-issues-running-a-coordinator-node-who-can-i-contact-for-support","title":"I am having technical issues running a Coordinator node. Who can I contact for support?","text":"<p>We recommend to go over this FAQ first, and if you still have issues, please send an email to hello@hello@hermez.network, or send a message to our Discord. You can also find more information in the Hermez documentation page</p>"},{"location":"Hermez_1.0/faq/end-users/","title":"End User FAQ","text":""},{"location":"Hermez_1.0/faq/end-users/#overview-getting-started","title":"Overview &amp; Getting Started","text":""},{"location":"Hermez_1.0/faq/end-users/#what-exactly-is-hermez","title":"What exactly is Hermez?","text":"<p>Hermez is a Layer 2 solution to scale payments on top of Ethereum.  It works by grouping transactions together to create SNARKs - succinct non-interactive arguments of knowledge.  These SNARKs then get settled on the Ethereum base layer, Layer 1, as one transaction. The transactions are executed by Coordinators (our version of block producers).  This means they are effectively running the network by computing the zero-knowledge proof-of-validity for the transactions made by users.  The result is low-cost token transfers, with all the security of Ethereum.  </p>"},{"location":"Hermez_1.0/faq/end-users/#how-do-i-set-up-my-hermez-wallet","title":"How do I set up my Hermez Wallet?","text":"<p>From a desktop computer, please visit the  Hermez Wallet  landing page and follow the instructions for setup.  </p> <p>Note : To withdraw funds, first select the token you want to withdraw from, and the next screen will show a Withdraw button.</p> <p> </p>"},{"location":"Hermez_1.0/faq/end-users/#transactions","title":"Transactions","text":""},{"location":"Hermez_1.0/faq/end-users/#how-long-do-transfers-take-on-hermez-network-from-start-to-finish","title":"How long do transfers take on Hermez Network from start to finish?","text":"<p>We expect that transaction time should be between 45 seconds and 30 minutes. There are several factors that can effect the transaction time, including; coordinator configuration, backlogged transactions and the transaction type. Deposits and Withdrawals take place on both L2 (Hermez) and L1 (Ethereum), which can cause an increase in transaction time depending on L1 volume.  </p>"},{"location":"Hermez_1.0/faq/end-users/#who-can-i-transact-with-on-hermez-network","title":"Who can I transact with on Hermez Network?","text":"<p>For transfers on Hermez, both the sender and receiver must be on L2. However, the sender may transfer funds to a receiver who has not yet created an account on Hermez L2 as long as the receiver has opened the Hermez Wallet app with their Metamask account.  </p>"},{"location":"Hermez_1.0/faq/end-users/#when-i-send-my-funds-to-hermez-on-layer-2-how-secure-is-it","title":"When I send my funds to Hermez on Layer 2, how secure is it?","text":"<p>It is as secure as it would be on the Layer 1, Ethereum blockchain. Hermez has completed two security audits before launching the mainnet to ensure network security.  For more information on Hermez security please visit, https://docs.hermez.io/#/about/security</p>"},{"location":"Hermez_1.0/faq/end-users/#im-getting-an-error-message-when-i-try-to-finalise-my-withdrawal-whats-going-on","title":"I'm getting an error message when I try to finalise my withdrawal, what's going on?","text":"<p>The most common reason for this error message is that there are not enough funds in your Ethereum L1 account to complete the withdrawal.  </p> <p>Withdrawals take place first on the Hermez L2, where the fee is paid in the same token as the transaction.  Next, it needs to move back to L1 which requires \"gas\" to cover the L1 transaction fee (this amount is determined by current prices on Ethereum Network. Hermez has no control over this fee).  If your L1 Ethereum account does not have enough funds to cover the gas charge, then the withdrawal cannot be completed and will produce the error message.  </p> <p>To remedy this, please make sure you have enough funds in your L1 Ethereum account to cover the gas to complete the withdrawal.</p>"},{"location":"Hermez_1.0/faq/end-users/#my-withdrawal-is-stuck-in-the-last-step","title":"My withdrawal is stuck in the last step","text":"<p>The last step of the withdrawal transfers the funds from the smart contract to the user's account. If the gas price suddenly increases, the recommended gas price from Metamask will be too low and the transaction will be stuck in Ethereum transaction pool. You can go to Metamask and speed up the transaction by setting a higher gas price.</p>"},{"location":"Hermez_1.0/faq/end-users/#why-is-my-deposit-taking-so-long-to-process","title":"Why is my Deposit taking so long to process?","text":"<p>Deposits move funds from Ethereum  L1 to L2 (Hermez) and must be forged by the Coordinator.  Depending on where the Coordinator is in the forging process, deposits may be as fast as 45 seconds or could take up to 15 minutes maximum. </p>"},{"location":"Hermez_1.0/faq/end-users/#can-i-use-my-ledgertrezor-hardware-with-my-hermez-wallet","title":"Can I use my Ledger/Trezor hardware with my Hermez Wallet?","text":"<p>Currently, hardware wallets are not supported on Hermez but should be supported in the near future. </p>"},{"location":"Hermez_1.0/faq/end-users/#can-coordinators-take-my-money","title":"Can Coordinators take my money?","text":"<p>In short, no.  Coordinators are the Hermez batch producer, they are responsible for running the network. In exchange for their work, they collect all transaction fees in the batch. </p>"},{"location":"Hermez_1.0/faq/end-users/#can-coordinators-censor-transactions","title":"Can coordinators censor transactions?","text":"<p>Coordinators can decide which transactions they select to include in the batch to forge. In the case that a Coordinator censures a transaction, users have the option to force Coordinators to include their transaction.</p> <p> </p>"},{"location":"Hermez_1.0/faq/end-users/#fees-and-tokens","title":"Fees and Tokens","text":""},{"location":"Hermez_1.0/faq/end-users/#what-is-the-hez-token","title":"What is the HEZ token?","text":"<p>HEZ is an ERC-20 utility token used to place bids in the Coordinator auction.</p>"},{"location":"Hermez_1.0/faq/end-users/#who-makes-money-from-the-transaction-fees","title":"Who makes money from the transaction fees?","text":"<p>Transaction fees are collected by the Coordinator who placed the highest bid in the Coordinator auction.</p>"},{"location":"Hermez_1.0/faq/end-users/#how-much-will-transactions-cost-on-hermez","title":"How much will transactions cost on Hermez?","text":"<p>Fees are used to pay for the infrastructure required to maintain the Hermez Coordinator plus the L1 costs involved in forging a new batch of transactions. The cost of the transaction will be split among the hundreds (or even thousands) of transactions in the batch, resulting in a lower cost compared to L1.</p>"},{"location":"Hermez_1.0/faq/end-users/#how-are-transaction-fees-paid-by-users","title":"How are transaction fees paid by users?","text":"<p>Transaction fees are paid in the same token of the transaction.</p>"},{"location":"Hermez_1.0/faq/end-users/#how-much-will-a-new-hermez-account-cost","title":"How much will a new Hermez account cost?","text":"<p>Creating a new Hermez account involves an L1 transaction or an L2 transaction. L1 transactions need to pay for gas, and L2 transactions need to pay the Coordinator fees.</p>"},{"location":"Hermez_1.0/faq/end-users/#which-tokens-can-i-use-on-hermez-network","title":"Which tokens can I use on Hermez Network?","text":"<p>For the current list of tokens registered in Hermez Network please visit: https://explorer.hermez.io/tokens</p>"},{"location":"Hermez_1.0/faq/end-users/#why-is-the-gas-fee-so-high-i-thought-hermez-was-supposed-to-lower-the-cost-of-transactions","title":"Why is the gas fee so high? I thought Hermez was supposed to lower the cost of transactions.","text":"<p>The \"gas\" fee is charged to move funds from L2 back to Ethereum mainnet (L1). It is determined by current prices on the Ethereum Network and Hermez has no control over this fee.</p>"},{"location":"Hermez_1.0/faq/end-users/#do-i-need-hez-tokens-to-use-the-hermez-network","title":"Do I need HEZ tokens to use the Hermez Network?","text":"<p>There's no need for HEZ tokens on the user side to send transactions as fees are paid in the same token of the transaction. For a list of the current tokens registered in Hermez please visit: https://explorer.hermez.io/tokens</p> <p> </p>"},{"location":"Hermez_1.0/faq/end-users/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Hermez_1.0/faq/end-users/#where-can-i-submit-a-bug-report-or-contact-hermez-for-additional-help","title":"Where can I submit a bug report or contact Hermez for additional help?","text":"<p>First, look over these FAQs to see if your question has been properly addressed already. In addition, you can always report bugs to hello@hermez.network or contact us in Discord. Another source of information is the Hermez documentation page</p>"},{"location":"Hermez_1.0/faq/integrators/","title":"Integrators","text":"<p>This FAQ is addressed to developers integrating Hermez Network into their service, such as exchanges.</p>"},{"location":"Hermez_1.0/faq/integrators/#overview-getting-started","title":"Overview &amp; Getting Started","text":""},{"location":"Hermez_1.0/faq/integrators/#where-do-i-start","title":"Where do I start?","text":"<p>The first place to start is the Developer Guide that provides an introduction to Hermez and the protocol. Additionally, there are some  code examples in the SDK section and in the Exchanges section that may be useful to get a deeper understanding of Hermez.</p>"},{"location":"Hermez_1.0/faq/integrators/#is-there-an-sdk-available","title":"Is there an SDK available?","text":"<p>HermezJS is an open-source SDK to interact with Hermez Rollup network.  It can be downloaded as an npm package, or via github.  Additionally, there are some examples of how to interact with Hermez written in Golang. You can find these examples here</p>"},{"location":"Hermez_1.0/faq/integrators/#what-are-the-different-account-types-in-hermez","title":"What are the different account types in Hermez?","text":"<p>An account in Hermez is represented by a leaf in the Merkle tree. Each account can only store one token type. There are two account types: - Normal accounts include a hezEthereum and a Baby Jubjub address. These accounts can be used to do deposits from L1, transfers within L2 and withdrawals to L1. - Internal accounts include only a Baby Jubjub address. These accounts can be only be used to do transfers within L2.</p>"},{"location":"Hermez_1.0/faq/integrators/#is-it-possible-to-send-a-transfer-to-a-non-existing-hermez-account","title":"Is it possible to send a transfer to a non-existing Hermez account?","text":"<p>Yes, it is. The receiver of the transfer needs to have previously authorized the Coordinator to create the account at the moment of the transfer. This authorization is done by opening the account with the Hermez wallet.</p>"},{"location":"Hermez_1.0/faq/integrators/#do-i-need-to-run-a-coordinator-node","title":"Do I need to run a Coordinator node?","text":"<p>You don't unless you want to. However, as an integrator offering some service on top of Hermez Network, you may want to spin a Hermez node in synchronizer mode to directly access the Hermez data directly without an intermediary. </p>"},{"location":"Hermez_1.0/faq/integrators/#how-do-i-check-the-status-of-a-transaction","title":"How do I check the status of a transaction?","text":"<p>Whenever you send an L2 transaction to Hermez, it will be added to a transaction-pool queue. This transaction will remain there until it has been processed or expires. The possible states of a transaction in the  transaction pool include <code>forged</code>, <code>forging</code>, <code>pending</code> and <code>invalid</code>.To check the status of a transaction, you can query the API using the returned transaction id by sending a GET /transactions-pool/{transaction-id}. </p>"},{"location":"Hermez_1.0/faq/integrators/#what-happens-if-a-transaction-is-not-processed","title":"What happens if a transaction is not processed?","text":"<p>Coordinators select the transactions to process according to some internal rules configured by the Coordinator. If the transaction is not processed, it will expire and be removed from the transaction pool.</p>"},{"location":"Hermez_1.0/faq/integrators/#what-is-the-timeout-for-a-transaction-in-the-transaction-pool","title":"What is the timeout for a transaction in the transaction pool?","text":"<p>Currently, this timeout is set to 24 hours.</p>"},{"location":"Hermez_1.0/faq/integrators/#what-are-the-reasons-a-transaction-may-not-be-processed","title":"What are the reasons a transaction may not be processed?","text":"<p>A valid transaction should always be processed within 15 minutes. There are several reasons why a transaction may be invalid and therefore not processed by any Coordinator; insufficient balance in the sender account, nonexistent sender account, destination account hasn't given permission to create an account, fees lower than suggested Coordinator fees,... Checking the transaction status will provide some feedback on the reason why the transaction wasn't forged.</p>"},{"location":"Hermez_1.0/faq/integrators/#can-i-cancel-a-transaction-in-the-pool","title":"Can I cancel a transaction in the pool?","text":"<p>Transactions cannot be cancelled once submitted. </p>"},{"location":"Hermez_1.0/faq/integrators/#how-do-i-set-the-fee-when-sending-a-transaction","title":"How do I set the fee when sending a transaction?","text":"<p>Coordinators select the recommended fee depending on the different transaction types. These fees can be queried in the <code>/state</code> endpoint and are in USD. There are three types of fees: - existingAccount used for transfers to existing Hermez accounts - createAccount used for deposits or transfers to nonexistent normal accounts (<code>transferToEthAddress</code> transaction) - creteAccountInternal used for transfers to nonexistent internal accounts (<code>transfertoBJJ</code> transaction)</p> <p>These USD fees need to be converted to the equivalent fee in the token used for the transaction.</p>"},{"location":"Hermez_1.0/faq/integrators/#how-do-i-set-the-nonce-when-sending-a-transaction","title":"How do I set the nonce when sending a transaction?","text":"<p>Each Hermez transaction includes a nonce value that prevents replay attacks. The Coordinator will forge transactions with the expected nonce (that is, the nonce of the transaction to be processed needs to be one more than the nonce of the last transaction processed from the same sender account). These nonces are computed by the SDK automatically unless specifically initialized. Recommended practice is to let the SDK compute these nonces.</p>"},{"location":"Hermez_1.0/faq/integrators/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Hermez_1.0/faq/integrators/#where-can-i-submit-a-bug-report-or-contact-hermez-for-additional-help","title":"Where can I submit a bug report or contact Hermez for additional help?","text":"<p>As always, please report bugs to hello@hermez.network. Additionally, you can always contact us in Discord. You can also find more information in the Hermez documentation page</p>"},{"location":"Hermez_1.0/faq/other/","title":"Other","text":""},{"location":"Hermez_1.0/faq/other/#where-can-i-find-the-smart-contracts","title":"Where can I find the Smart Contracts?","text":"<p>Smart Contracts can be downloaded from <code>here</code></p>"},{"location":"Hermez_1.0/faq/pod/","title":"Proof-of-donation","text":"<p>Hermez is currently under development. Some of the details in the answers can be modified before network launch.</p>"},{"location":"Hermez_1.0/faq/pod/#how-exactly-does-proof-of-donation-work","title":"How exactly does proof-of-donation work?","text":"<p>We have an auction where everyone bids the amount of Hermez network tokens (HEZ) they're willing to donate in order to obtain the right to create the next block.</p> <p>The winning bid is the highest amount of HEZ. And this address is assigned the right to create the next block.</p> <p>We refer to this mechanism as proof-of-donation because 40% of this bid goes back to be reinvested in the protocols and services that run on top of Ethereum.</p> <p>For more on the details how it works, see this ethresearch post (though you should replace all instances of burn with donation when reading).</p>"},{"location":"Hermez_1.0/faq/pod/#where-are-the-funds-from-the-proof-of-donation-sent","title":"Where are the funds from the proof-of-donation sent?","text":"<p>They will be sent initially to the Gitcoin quadratic funding pool, but with future governance, other funding pools might be enabled as they become available.</p>"},{"location":"Hermez_1.0/users/exchanges/","title":"Exchanges","text":"<p>This example shows a possible flow of how an exchange would use Hermez. This example requires npm version <code>1.0.0-beta.15</code> or later of <code>@hermeznetwork/hermezjs</code> SDK. To get a complete tutorial on other functionalities, check out the SDK documentation</p>"},{"location":"Hermez_1.0/users/exchanges/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Exchange already has some Hermez accounts for each trading token (<code>HEZEx-ETH</code>, <code>HEZEx-DAI</code>,...). </li> <li>User has a Hermez account (<code>HEZUser-ETH</code>) </li> </ul> <p>Both exchange and user pre-existing accounts are regular Hermez accounts, consisting of an L2 account linked to an Ethereum account where funds can be withdrawn. The following is an example of code used to initialize hermezjs with <code>Hermez testnet</code> deployment and create both user and exchange accounts. You need to supply your own WEB3_URL (Ethereum Node URL) and two Rinkeby Ethereum Private Keys.</p> <p>Note that the latest smart contract addresses can always be found here</p> <pre><code>const hermez = require(\"@hermeznetwork/hermezjs\");\n\nconst EXAMPLES_HERMEZ_API_URL = \"https://api.testnet.hermez.io/v1\";\nconst EXAMPLES_HERMEZ_ROLLUP_ADDRESS = \"0x679b11E0229959C1D3D27C9d20529E4C5DF7997c\";\nconst EXAMPLES_HERMEZ_WDELAYER_ADDRESS = \"0xeFD96CFBaF1B0Dd24d3882B0D6b8D95F85634724\";\n\n// Provide your own values\nconst EXAMPLES_WEB3_URL = \"http://----\";\nconst EXAMPLES_PRIVATE_KEY1 = \"0x----\";\nconst EXAMPLES_PRIVATE_KEY2 = \"0x----\";\n\nasync function sleep (timeout) {\n  await new Promise(resolve =&gt; setTimeout(resolve, timeout));\n}\n\nfunction configureEnvironment () {\n  // Initializes Tx Pool\n  hermez.TxPool.initializeTransactionPool()\n  // load ethereum network provider\n  hermez.Providers.setProvider(EXAMPLES_WEB3_URL)\n\n  // set environment\n  hermez.Environment.setEnvironment({\n    baseApiUrl: EXAMPLES_HERMEZ_API_URL,\n    contractAddresses: {\n      [hermez.Constants.ContractNames.Hermez]: EXAMPLES_HERMEZ_ROLLUP_ADDRESS,\n      [hermez.Constants.ContractNames.WithdrawalDelayer]: EXAMPLES_HERMEZ_WDELAYER_ADDRESS\n    }\n  })\n}\n\nasync function main(){\n  // INITIALIZATION\n  // initialize hermezjs and prepare two Hermez accounts with some ETH (user and exchange accounts)\n  configureEnvironment()\n\n  const exchangePrivKey = EXAMPLES_PRIVATE_KEY1;\n  const userPrivKey = EXAMPLES_PRIVATE_KEY2;\n\n  // load token to deposit information\n  const tokenEthIndex = 0;\n  const token = await hermez.CoordinatorAPI.getTokens();\n  const tokenETH = token.tokens[tokenEthIndex];\n\n  // load first account\n  const wallet = await hermez.HermezWallet.createWalletFromEtherAccount(EXAMPLES_WEB3_URL, { type: \"WALLET\", privateKey: exchangePrivKey });\n  const hermezExchangeWallet = wallet.hermezWallet;\n  const hermezExchangeEthereumAddress = wallet.hermezEthereumAddress;\n\n  // load second account\n  const wallet2 = await hermez.HermezWallet.createWalletFromEtherAccount(EXAMPLES_WEB3_URL, { type: \"WALLET\", privateKey: userPrivKey });\n  const hermezUserWallet = wallet2.hermezWallet;\n  const hermezUserEthereumAddress = wallet2.hermezEthereumAddress;\n  console.log(\"W2\", wallet2)\n\n  // set amount to deposit\n  const amountDeposit = hermez.Utils.getTokenAmountBigInt(\"0.1\", 18);\n  const compressedDepositAmount = hermez.HermezCompressedAmount.compressAmount(amountDeposit);\n\n  // perform deposit hermezExchangeAccount\n  await hermez.Tx.deposit(\n    compressedDepositAmount,\n    hermezExchangeEthereumAddress,\n    tokenETH,\n    hermezExchangeWallet.publicKeyCompressedHex,\n    { type: \"WALLET\", privateKey: exchangePrivKey }\n  );\n\n  // perform deposit hermezUserAccount\n  await hermez.Tx.deposit(\n    compressedDepositAmount,\n    hermezUserEthereumAddress,\n    tokenETH,\n    hermezUserWallet.publicKeyCompressedHex,\n    { type: \"WALLET\", privateKey: userPrivKey }\n  );\n\n  // WAIT until accounts are created\n  const pollingAccountCreate = true;\n  while (pollingAccountCreate){\n    const accountExchangeInfo = await hermez.CoordinatorAPI.getAccounts(hermezExchangeEthereumAddress, [tokenETH.id]);\n    if (accountExchangeInfo.accounts.length === 0){\n      console.log(\"Waiting for deposits to be forged...\");\n      await sleep(10000);\n    } else {\n      console.log(\"Accounts created\", accountExchangeInfo)\n      break;\n    }\n  }\n\n  const infoAccountExchange = (await hermez.CoordinatorAPI.getAccounts(hermezExchangeWallet.hermezEthereumAddress, [tokenETH.id]))\n    .accounts[0];\n  console.log(infoAccountExchange);\n\n}\n\nmain();\n</code></pre>"},{"location":"Hermez_1.0/users/exchanges/#deposit-to-exchange","title":"Deposit to Exchange","text":"<p>A User wants to transfer 10 ETH from his Hermez account to the exchange for the first time. To do so, the user requests to transfer some funds via some sort of front end provided by the exchange. After the request is done, the exchange provides the address of an internal Hermez account where the user can deposit his tokens. This account doesn't have an Ethereum counterpart account,  and thus the creation is very inexpensive. Once the user has received the L2 account address, he can perform the transfer normally. In the meantime, the exchange is monitoring the status of this account, and once the user transfer is completed, the exchange can transfer the funds to its main account. This process is depicted in the diagram below.</p> <p>The creation of this user account by the exchange needs to only done once per user and token.</p> <p></p>"},{"location":"Hermez_1.0/users/exchanges/#flow","title":"Flow","text":"<ol> <li>User requests to do a transfer to the exchange from his Hermez account using some front-end.</li> <li>Exchange creates an L2 (internal) account on behalf of the user (<code>L2ExUser-ETH</code>) and provides the address via front-end. This account is controlled by the exchange. </li> </ol> <pre><code>  // create rollup internal account from bjj private key\n  const resExchangeWallet = await hermez.HermezWallet.createWalletFromBjjPvtKey();\n  const hermezExchangeUserWallet = resExchangeWallet.hermezWallet;\n\n  // share public bjj key with the user\n  console.log(`Transfer funds to this hermez address:\\n   ${hermezExchangeUserWallet.publicKeyBase64}\\n\\n`); \n</code></pre> <ol> <li>User does a L2 transfer from his account to the destination account using the web wallet</li> </ol> <pre><code>  const infoAccountUser = (await hermez.CoordinatorAPI.getAccounts(hermezUserWallet.hermezEthereumAddress, [tokenETH.id]))\n    .accounts[0];\n\n  const state = await hermez.CoordinatorAPI.getState();\n  const usdTokenExchangeRate = tokenETH.USD;\n  const fee = usdTokenExchangeRate ? state.recommendedFee.createAccountInternal / usdTokenExchangeRate : 0;\n\n  // user creates transaction to deposit 10 ether into exchange account\n  // deposit 10 ether\n  const userDepositToExchange = hermez.Utils.getTokenAmountBigInt(\"10.0\", 18);\n  const compressedUserDepositToExchange = hermez.HermezCompressedAmount.compressAmount(userDepositToExchange);\n  // the following transaction would:\n  // - create an account for the exchange in hermez network\n  // - transfer to exchange account 0.1 eth\n  const transferToExchange = {\n    from: infoAccountUser.accountIndex,\n    to: hermezExchangeUserWallet.publicKeyBase64,\n    amount: compressedUserDepositToExchange,\n    fee : fee\n  };\n  console.log(\"transferToExchange: \", transferToExchange, fee);\n  // send tx to hermez network\n  await hermez.Tx.generateAndSendL2Tx(transferToExchange, hermezUserWallet, tokenETH);\n</code></pre> <ol> <li>Exchange monitors balance of the account <code>L2ExUser-ETH</code>, and once transfer is complete, exchange performs transfer from <code>L2ExUser-ETH</code> to <code>L2Ex-ETH</code> for 10 ETH.</li> </ol> <pre><code>  const pollingExchangeAddr = true;\n  while (pollingExchangeAddr){\n    const accountExchangeInfo = await hermez.CoordinatorAPI.getAccounts(hermezExchangeUserWallet.publicKeyBase64, [tokenETH.id]);\n    if (accountExchangeInfo.accounts.length === 0){\n      console.log(\"Waiting for user deposit to be forged...\");\n      await sleep(10000);\n    } else {\n      console.log(\"&lt;=== Received deposit from user ===&gt;\");\n      console.log(`accountExchangeInfo:\\n ${accountExchangeInfo.accounts[0]}`);\n      break;\n    }\n  }\n\n  const infoAccountExchangeUser = (await hermez.CoordinatorAPI.getAccounts(hermezExchangeUserWallet.publicKeyBase64, [tokenETH.id]))\n   .accounts[0];\n\n  // Transfer funds to main exchange account\n  // generate L2 transaction\n  const l2TxTransfer = {\n    from: infoAccountExchangeUser.accountIndex,\n    to:  infoAccountExchange.accountIndex,\n    amount: compressedUserDepositToExchange,\n    fee: fee\n  };\n\n  const transferResponse = await hermez.Tx.generateAndSendL2Tx(l2TxTransfer, hermezExchangeUserWallet, tokenETH).catch(console.log);\n  console.log(\"transferResponse: \", transferResponse);\n</code></pre>"},{"location":"Hermez_1.0/users/exchanges/#full-example","title":"Full Example","text":"<pre><code>const hermez = require(\"@hermeznetwork/hermezjs\");\n\nconst EXAMPLES_HERMEZ_API_URL = \"https://api.testnet.hermez.io/v1\";\nconst EXAMPLES_HERMEZ_ROLLUP_ADDRESS = \"0x14a3b6f3328766c7421034e14472f5c14c5ba090\";\nconst EXAMPLES_HERMEZ_WDELAYER_ADDRESS = \"0x6ea0abf3ef52d24427043cad3ec26aa4f2c8e8fd\";\n\n// Provide your own values\nconst EXAMPLES_WEB3_URL = \"http://----\";\nconst EXAMPLES_PRIVATE_KEY1 = \"0x----\";\nconst EXAMPLES_PRIVATE_KEY2 = \"0x----\";\n\nasync function sleep (timeout) {\n  await new Promise(resolve =&gt; setTimeout(resolve, timeout));\n}\n\nfunction configureEnvironment () {\n  // Initializes Tx Pool\n  hermez.TxPool.initializeTransactionPool()\n  // load ethereum network provider\n  hermez.Providers.setProvider(EXAMPLES_WEB3_URL)\n\n  // set environment\n  hermez.Environment.setEnvironment({\n    baseApiUrl: EXAMPLES_HERMEZ_API_URL,\n    contractAddresses: {\n      [hermez.Constants.ContractNames.Hermez]: EXAMPLES_HERMEZ_ROLLUP_ADDRESS,\n      [hermez.Constants.ContractNames.WithdrawalDelayer]: EXAMPLES_HERMEZ_WDELAYER_ADDRESS\n    }\n  })\n}\n\nasync function main(){\n  // INITIALIZATION\n  // initialize hermezjs and prepare two Hermez accounts with some ETH (user and exchange accounts)\n\n  configureEnvironment()\n\n  const exchangePrivKey = EXAMPLES_PRIVATE_KEY1;\n  const userPrivKey = EXAMPLES_PRIVATE_KEY2;\n\n  // load token to deposit information\n  const tokenEthIndex = 0;\n  const token = await hermez.CoordinatorAPI.getTokens();\n  const tokenETH = token.tokens[tokenEthIndex];\n\n  // load first account\n  const wallet = await hermez.HermezWallet.createWalletFromEtherAccount(EXAMPLES_WEB3_URL, { type: \"WALLET\", privateKey: exchangePrivKey });\n  const hermezExchangeWallet = wallet.hermezWallet;\n  const hermezExchangeEthereumAddress = wallet.hermezEthereumAddress;\n\n  // load second account\n  const wallet2 = await hermez.HermezWallet.createWalletFromEtherAccount(EXAMPLES_WEB3_URL, { type: \"WALLET\", privateKey: userPrivKey });\n  const hermezUserWallet = wallet2.hermezWallet;\n  const hermezUserEthereumAddress = wallet2.hermezEthereumAddress;\n\n  // set amount to deposit\n  const amountDeposit = hermez.Utils.getTokenAmountBigInt(\"0.1\", 18);\n  const compressedDepositAmount = hermez.HermezCompressedAmount.compressAmount(amountDeposit);\n\n  // perform deposit hermezExchangeAccount\n  await hermez.Tx.deposit(\n    compressedDepositAmount,\n    hermezExchangeEthereumAddress,\n    tokenETH,\n    hermezExchangeWallet.publicKeyCompressedHex,\n    { type: \"WALLET\", privateKey: exchangePrivKey }\n  );\n\n  // perform deposit hermezUserAccount\n  await hermez.Tx.deposit(\n    compressedDepositAmount,\n    hermezUserEthereumAddress,\n    tokenETH,\n    hermezUserWallet.publicKeyCompressedHex,\n    { type: \"WALLET\", privateKey: userPrivKey }\n  );\n\n  console.log(\"Deposits\")\n  // WAIT until accounts are created\n  const pollingAccountCreate = true;\n  while (pollingAccountCreate){\n    const accountExchangeInfo = await hermez.CoordinatorAPI.getAccounts(hermezExchangeEthereumAddress, [tokenETH.id]);\n    if (accountExchangeInfo.accounts.length === 0){\n      console.log(\"Waiting for deposits to be forged...\");\n      await sleep(10000);\n    } else {\n      console.log(\"Accounts created\", accountExchangeInfo)\n      break;\n    }\n  }\n\n  const infoAccountExchange = (await hermez.CoordinatorAPI.getAccounts(hermezExchangeWallet.hermezEthereumAddress, [tokenETH.id]))\n    .accounts[0];\n\n  // EXCHANGE ACTION\n  // create rollup internal account from bjj private key\n  const resExchangeWallet = await hermez.HermezWallet.createWalletFromBjjPvtKey();\n  const hermezExchangeUserWallet = resExchangeWallet.hermezWallet;\n\n  // share public bjj key with the user\n  console.log(`Transfer funds to this hermez address:\\n   ${hermezExchangeUserWallet.publicKeyBase64}\\n\\n`);\n\n  // USER ACTION\n  // - the following code could be done through the web wallet provided by hermez network\n  // - it is assumed that the user has already Ether in Hermez Network\n\n  const infoAccountUser = (await hermez.CoordinatorAPI.getAccounts(hermezUserWallet.hermezEthereumAddress, [tokenETH.id]))\n    .accounts[0];\n\n  const state = await hermez.CoordinatorAPI.getState();\n  const usdTokenExchangeRate = tokenETH.USD;\n  const fee = usdTokenExchangeRate ? state.recommendedFee.createAccountInternal / usdTokenExchangeRate : 0;\n\n  // user creates transaction to deposit some ether into exchange account\n  const userDepositToExchange = hermez.Utils.getTokenAmountBigInt(\"0.0001\", 18);\n  const compressedUserDepositToExchange = hermez.HermezCompressedAmount.compressAmount(userDepositToExchange);\n  // the following transaction would:\n  // - create an account for the exchange in hermez network\n  const transferToExchange = {\n    from: infoAccountUser.accountIndex,\n    to: hermezExchangeUserWallet.publicKeyBase64,\n    amount: compressedUserDepositToExchange,\n    fee : fee\n  };\n  console.log(\"transferToExchange: \", transferToExchange, fee);\n  // send tx to hermez network\n  await hermez.Tx.generateAndSendL2Tx(transferToExchange, hermezUserWallet, tokenETH);\n\n  // EXCHANGE ACTION\n  // polling exchange account to check deposit from user is received\n  const pollingExchangeAddr = true;\n  while (pollingExchangeAddr){\n    const accountExchangeInfo = await hermez.CoordinatorAPI.getAccounts(hermezExchangeUserWallet.publicKeyBase64, [tokenETH.id]);\n    if (accountExchangeInfo.accounts.length === 0){\n      console.log(\"Waiting for user deposit to be forged...\");\n      await sleep(10000);\n    } else {\n      console.log(\"&lt;=== Received deposit from user ===&gt;\");\n      console.log(\"accountExchangeInfo:\\n\", accountExchangeInfo.accounts[0]);\n      break;\n    }\n  }\n  const infoAccountExchangeUser = (await hermez.CoordinatorAPI.getAccounts(hermezExchangeUserWallet.publicKeyBase64, [tokenETH.id]))\n   .accounts[0];\n\n  // Transfer funds to main exchange account\n  // generate L2 transaction\n  const l2TxTransfer = {\n    from: infoAccountExchangeUser.accountIndex,\n    to:  infoAccountExchange.accountIndex,\n    amount: compressedUserDepositToExchange,\n    fee: fee\n  };\n\n  const transferResponse = await hermez.Tx.generateAndSendL2Tx(l2TxTransfer, hermezExchangeUserWallet, tokenETH).catch(console.log);\n  console.log(\"transferResponse: \", transferResponse);\n}\n\nmain();\n</code></pre>"},{"location":"Hermez_1.0/users/hermez-wallet/","title":"Hermez Wallet Guide","text":""},{"location":"Hermez_1.0/users/hermez-wallet/#welcome-to-the-hermez-wallet","title":"Welcome to the Hermez Wallet","text":"<p>Hermez Wallet provides a simple user interface to get started with the Hermez Network. It supports depositing, transferring, and withdrawing ETH and ERC-20 tokens on Hermez Network. </p>"},{"location":"Hermez_1.0/users/hermez-wallet/#getting-started","title":"Getting Started","text":"<p>When opening the wallet, there's a button to log in with Metamask. This will automatically derive a Hermez account from the Ethereum account.</p> <p></p> <p>This will then lead to an empty wallet:</p> <p></p> <p>The next step is to make a deposit</p>"},{"location":"Hermez_1.0/users/hermez-wallet/#transactions","title":"Transactions","text":"<p>There are 3 kinds of transactions:</p> <ul> <li>Deposits. Sends ETH or an ERC-20 token (must be registered in Hermez) from your Ethereum account to your Hermez account.</li> <li>Transfers. Sends ETH or an ERC-20 token from a Hermez account to another Hermez account.</li> <li>Withdrawals. Sends ETH or an ERC-20 token from a Hermez account to its corresponding Ethereum account.</li> </ul> <p>They all follow a similar flow. First, we select a token. If it's a <code>Deposit</code>, the token must be in the Ethereum account. Otherwise, it must be in the Hermez account.</p> <p></p> <p>Then there's a form to select the amount:</p> <p></p> <p>In the case of a <code>Transfer</code>, there will also be a receiver input. This input also supports scanning a QR code or pasting the Receiver's address directly.</p> <p></p> <p>If everything is valid, the next step is the confirmation with a look at all of the transaction parameters. With a <code>Deposit</code>, as it is a Layer 1 transaction, it will require signing with your Ethereum Wallet (e.g. Metamask).</p> <p>This leads to the confirmation screen if everything went well:</p> <p></p>"},{"location":"Hermez_1.0/users/hermez-wallet/#accounts","title":"Accounts","text":"<p>Making <code>Deposits</code> creates accounts that now appear on the home screen.</p> <p></p> <p>Opening an account shows all the transactions related to that account.</p> <p></p> <p>Opening a transaction shows information related to that transaction. There's also a button to open the Batch Explorer with all the information.</p> <p></p>"},{"location":"Hermez_1.0/users/hermez-wallet/#withdrawals","title":"Withdrawals","text":"<p>Withdrawals are a two-part process. The first part requires you to select the Token account you want to withdraw from (for example HEZ) and on the next screen click on the <code>Withdraw</code> button, enter the amount to withdraw, and click on <code>Continue</code>.</p> <p>After completing the first part explained above, a card with the withdrawal details appears on the Home screen or on the respective account page. When ready, it will show a button to finalize the withdrawal.</p> <p>*Withdrawals require paying an Ether gas fee on L1, insufficient gas in your L1 account will cause the withdrawal to stall. </p> <p>*Withdrawals are final and cannot be stopped, reversed, or altered in any way after initiated.  </p> <p></p> <p>Alternatively, you can transfer your funds to a different account in Hermez and perform the withdrawal from that account. This may be helpful in situations where you don't have enough Ether in the original L1 account but do in a different account.</p>"},{"location":"Hermez_1.0/users/hermez-wallet/#my-account","title":"My Account","text":"<p>There's a My Account page. Current options are:</p> <ul> <li>Copying your Hermez Address or displaying it as a QR code.</li> <li>Changing the default FIAT currency between EUR and USD.</li> <li>Making a <code>Force Withdrawal</code>. This is a L1 equivalent of the first step of the withdrawal as explained above. This uses more Gas but forces the Coordinator to pick the transaction up. It's only a security measure and shouldn't be needed.</li> <li>View the Hermez account in the Batch Explorer.</li> <li>Logging out.</li> </ul> <p></p>"},{"location":"Hermez_1.0/users/mainnet/","title":"Hermez Mainnet","text":"<p>Hermez is now live on Ethereum. </p>"},{"location":"Hermez_1.0/users/mainnet/#tools","title":"Tools","text":"<ul> <li>Web wallet to interact with Hermez ZK-Rollup user accounts</li> <li>Hermez L2 batch explorer</li> <li>Hermez SDK</li> <li>Hermez API</li> </ul>"},{"location":"Hermez_1.0/users/mainnet/#useful-links","title":"Useful Links","text":"<ul> <li>To interact with the Hermez, you'll need a Metamask wallet.</li> </ul>"},{"location":"Hermez_1.0/users/mainnet/#contract-addresses","title":"Contract Addresses","text":"<p>Hermez uses 4 main smart contracts: - HermezAuctionProtocol: 0x15468b45ed46c8383f5c0b1b6cf2ecf403c2aec2 - HermezAddress: 0xa68d85df56e733a06443306a095646317b5fa633 - HermezWithdrawalDelayerAddress: 0x392361427ef5e17b69cfdd1294f31ab555c86124 - HEZTokenAddress: 0xeef9f339514298c6a857efcfc1a762af84438dee</p> <p>To get the latest smart contracts configuration, you can consult the API</p>"},{"location":"Hermez_1.0/users/testnet/","title":"Testnet","text":"<p>Hermez testnet is now live on the Ethereum Rinkeby network. Checkout our blogpost announcing the launch of Hermez Testnet for additional information.</p>"},{"location":"Hermez_1.0/users/testnet/#tools","title":"Tools","text":"<ul> <li>Web wallet to interact with Hermez ZK-Rollup user accounts</li> <li>Hermez L2 batch explorer</li> <li>Hermez SDK</li> <li>Hermez API</li> </ul>"},{"location":"Hermez_1.0/users/testnet/#useful-links","title":"Useful Links","text":"<ul> <li>To interact with the Testnet, you'll need a Metamask wallet and some Rinkeby tokens.</li> <li>Get Rinkeby ETH using this faucet.</li> <li>If you want to swap some of your Rinkeby ETH for Rinkeby HEZ, you can use Rinkeby Uniswap pair.</li> </ul>"},{"location":"Hermez_1.0/users/testnet/#contract-addresses","title":"Contract Addresses","text":"<p>Hermez uses 4 main smart contracts: - HermezAuctionProtocol: 0x0a8a6D65Ad9046c2a57a5Ca8Bab2ae9c3345316d - HermezAddress: 0x679b11E0229959C1D3D27C9d20529E4C5DF7997c - HermezWithdrawalDelayerAddress: 0xeFD96CFBaF1B0Dd24d3882B0D6b8D95F85634724 - HEZTokenAddress: 0x2521Bc90B4f5Fb9a8D61278197e5FF5cDbc4FBF2</p> <p>To get the latest smart contracts configuration, you can consult the API</p>"},{"location":"zkEVM/Building-on-Polygon-zkEVM-H_io/","title":"Building on Polygon zkEVM","text":""},{"location":"zkEVM/Building-on-Polygon-zkEVM-H_io/#introduction","title":"Introduction","text":"<p>Polygon zkEVM is a zero-knowledge scaling solution aiming at being fully equivalent to the EVM, and thus working seamlessly with existing smart contracts, developer toolings and wallets. It is therefore designed to provide a complete EVM-like experience for Users and Developers alike.</p> <p>You don't need any special toolings or Wallets to build or interact with Polygon zkEVM.</p> <p>Developers are able to deploy their existing contracts to the zkEVM, and Users can deposit assets from Ethereum and transact off-chain. These transactions are grouped into batches and backed by zero-knowledge proofs attesting to the validity of each transaction.</p>"},{"location":"zkEVM/Building-on-Polygon-zkEVM-H_io/#how-to-connect-your-wallet-to-zkevm-testnet","title":"How To Connect Your Wallet To zkEVM Testnet","text":"<p>In order to add the Polygon zkEVM network to your wallet, you will need to enter the following details:</p> <ul> <li>Network Name: Polygon zkEVM Testnet</li> <li>RPC URL: https://rpc.public.zkevm-test.net</li> <li>Chain ID: 1422</li> <li>Currency Symbol: ETH</li> <li>Block Explorer URL: https://explorer.public.zkevm-test.net</li> </ul> <p>Also, for moving assets across chains, you will need to use the zkEVM Bridge. The bridge interface is available on https://public.zkevm-test.net/. </p> <p>For developers, the Bridge API is available at https://bridge-api.public.zkevm-test.net/.</p>"},{"location":"zkEVM/Building-on-Polygon-zkEVM-H_io/#adding-zkevm-testnet-to-metamask","title":"Adding zkEVM Testnet To MetaMask","text":"<p>Check out this video tutorial on how to add Polygon zkEVM Testnet to Metamask and deploy smart contracts:</p>"},{"location":"zkEVM/Building-on-Polygon-zkEVM-H_io/#zkevm-support","title":"zkEVM Support","text":"<p>If you need help with anything related to the Polygon zkEVM, you can raise a ticket on the Polygon Support portal. </p> <p>Check out the Knowledge base to view the most common queries about the zkEVM. </p> <p>Additionally, you can reach out to the support team available on the #zkevm-support channel on the Polygon Discord server. </p> <p>Instructions for raising a zkEVM testnet support ticket are as follows:</p> <ol> <li>Join the Polygon Discord server here.</li> <li>Accept the invite sent via DM.</li> <li>Take the Member role under #roles.</li> <li>Navigate to the #zkevm-support channel.</li> </ol> <p>You can now contact the zkEVM support staff with your questions and concerns. We will actively monitor for issues and work to resolve them as soon as possible.</p>"},{"location":"zkEVM/How-To-Run-A-zkNode/","title":"How To Run A Local zkNode","text":"<p>This document is a guide to creating a local single-node zkEVM blockchain with no connections to external peers. It will only exist on your local machine.</p>"},{"location":"zkEVM/How-To-Run-A-zkNode/#zknodes-brief-overview","title":"zkNode's Brief Overview","text":"<p>zkNode is the software needed to run a zkEVM node. It is a client that the network requires to implement the synchronization and govern the roles of the participants (Sequencers or Aggregators). </p> <p>Polygon zkEVM participants can choose how they participate:</p> <ul> <li>As a node to know the state of the network, or</li> <li>As a participant in the process of batch production in any of the two roles: Sequencer or Aggregator</li> </ul> <p>The zkNode Architecture modular in nature. See the diagram below for a highlevel view of the zkNode.</p> <p></p> <p>Note that for Testnet purposes, a centralised Sequencer is implemented. </p> <p>Further details on the zkNode and its components are covered here. </p>"},{"location":"zkEVM/How-To-Run-A-zkNode/#before-setting-up-a-local-zknode","title":"Before Setting Up A Local zkNode","text":"<p>In order to participate in the Polygon zkEVM, whether it is for testnet or mainnet, one needs to set up a zkNode. This will allow users to test their smart contracts, experiment with new code, and play around with the network on their local machines.</p> <pre><code>CAUTION!\n\nCurrently the zkProver does not run on ARM-powered Macs.\nFor Windows users, using WSL/WSL2 is not recommended.\n\nUnfortunately, Apple M1 chips are not supported for now \n- since some optimizations on the zkProver require \nspecific Intel instructions. \nThis means some non-M1 computers won't work regardless of \nthe OS, for example: AMD.\n\n</code></pre>"},{"location":"zkEVM/How-To-Run-A-zkNode/#prerequisites","title":"Prerequisites","text":"<p>The current zkEVM version requires <code>go</code>, <code>docker</code> and <code>docker-compose</code> to have been installed on your machine. If you don\u2019t have them installed, check out the links provided below.</p> <ul> <li>https://go.dev/doc/install</li> <li>https://www.docker.com/get-started</li> <li>https://docs.docker.com/compose/install/</li> </ul>"},{"location":"zkEVM/How-To-Run-A-zkNode/#system-requirements","title":"System Requirements","text":"<ul> <li>zkEVM Node: 16GB RAM with 4-core CPU</li> <li>zkProver: 1TB RAM with 128-core CPU</li> </ul> <p>If you want to run a full-fledged zkProver on your own, you'll need at least 1TB of RAM. If you are unable to meet the Prover requirements, you can still run the zkNode.</p> <p>After completing this tutorial, the following components will be running in your local machine;</p> <ul> <li>zkEVM Node Databases</li> <li>Explorer Databases</li> <li>L1 Network</li> <li>Prover</li> <li>zkEVM Node components</li> <li>Explorers</li> </ul>"},{"location":"zkEVM/How-To-Run-A-zkNode/#setting-up-a-local-zknode","title":"Setting Up A Local zkNode","text":"<p>Before starting the zkEVM node setup, you need to clone the official zkNode repository from Polygon zkEVM Github.</p> <pre><code>git clone https://github.com/0xPolygonHermez/zkevm-node.git \n</code></pre> <p>The <code>zkevm-node</code> docker image must be built at least once and whenever the code is changed. If you haven't already built the <code>zkevm-node</code> image, you must run:</p> <pre><code>make build-docker\n</code></pre> <p>Certain commands on the <code>zkevm-node</code> can interact with smart contracts, run specific components, create encryption files, and print debug information.</p> <p>To interact with the binary program, we provide <code>docker-compose</code> files and a <code>Makefile</code> to spin up/down the various services and components, ensuring smooth local deployment and a better command line interface for developers.</p> <pre><code>DANGER!\nAll the data is stored inside of each docker container. \nThis means once you remove the container, the data will be lost.\n</code></pre> <p>The <code>test/</code> directory contains scripts and files for developing and debugging. Change the working directory to <code>test/</code> on your local machine.</p> <pre><code>cd test/\n</code></pre> <p>Now, run the zkNode environment:</p> <pre><code>make run\n</code></pre> <p>To stop the zkNode:</p> <pre><code>make stop\n</code></pre> <p>To restart the whole zkNode environment:</p> <pre><code>make restart\n</code></pre>"},{"location":"zkEVM/How-To-Run-A-zkNode/#configuration-parameters","title":"Configuration Parameters","text":"<p>The synchroniser has to keep up to date and therefore regularly pulls for changes in the network, especially from Ethereum but also from the \u201ctrusted\u201d sequencer\u2019s broadcasting mechanism. The default syncing rate for the synchroniser is every 2 seconds, unless stipulated otherwise in the configuration.  </p> <p>The keystore file, used to store private keys, is normally required for running the sequencer and the aggregator but not for a synchronizer/rpc-setup. And now we have this inconvenient situation that this is required to run the node when it shouldn\u2019t, for instance, if there are no transactions sent to L1. Since the mango testnet uses trusted sequencer and aggregator, keystore is not required. This will however be reviewed when a decentralised zkEVM network is rolled out. </p>"},{"location":"zkEVM/How-To-Run-A-zkNode/#sample-data","title":"Sample Data","text":"<p>It's important to populate your local zkEVM node with some data before you start testing out the network. The <code>make run</code> command will execute the containers required to run the environment, but it will not execute anything else. Your local L2 network will be essentially empty.</p> <p>The following scripts are available if you require sample data that has already been deployed to the network.</p> <pre><code># To add some examples of transactions and smart contracts:\nmake deploy-sc\n\n# To deploy a full Uniswap environment:\nmake deploy-uniswap\n\n# To grant the MATIC smart contract a set amount of tokens:\nmake run-approve-matic\n</code></pre>"},{"location":"zkEVM/How-To-Run-A-zkNode/#connecting-to-metamask","title":"Connecting to Metamask","text":"<p>INFO Metamask requires the network to be running while configuring it, so make sure your network is up.</p> <p>To configure your Metamask to use your local zkEVM environment, follow these steps:</p> <ol> <li>Log in to your Metamask wallet</li> <li>Click on your account picture and then on Settings</li> <li>On the left menu, click on Networks</li> <li>Click on Add Network button</li> <li> <p>Fill up the L2 network information     Network Name: Polygon zkEVM - Local     New RPC URL: http://localhost:8123     ChainID: 1001     Currency Symbol: ETH     Block Explorer URL: http://localhost:4000</p> </li> <li> <p>Click on Save</p> </li> <li>Click on Add Network button</li> <li>Fill up the L1 network information     Network Name: Geth - Local     New RPC URL: http://localhost:8545     ChainID: 1337     Currency Symbol: ETH</li> <li>Click on Save</li> </ol> <p>You can now interact with your local zkEVM network and sign transactions from your Metamask wallet.</p>"},{"location":"zkEVM/Polygon-zkEVM-Source-Code/","title":"Polygon zkEVM Source Code","text":"<p>This document provides the complete list of all available source code repositories related to Polygon zkEVM and its components including the zkProver. Feel free to check out the Polygon zkEVM organization on Github.</p>"},{"location":"zkEVM/Polygon-zkEVM-Source-Code/#core-repositories","title":"Core repositories","text":"<ul> <li>zkevm-prover</li> <li>zkevm-proverjs</li> <li>zkevm-rom</li> <li>zkevm-node</li> <li>zkevm-contracts</li> <li>zkevm-bridge-service</li> <li>zkevm-bridge-ui</li> </ul>"},{"location":"zkEVM/Polygon-zkEVM-Source-Code/#specific-tools-and-libraries","title":"Specific tools and libraries","text":"<ul> <li>Javascript library implementing common utilities for zkevm: zkevm-commonjs</li> <li>zkevm-testvectors</li> </ul>"},{"location":"zkEVM/Polygon-zkEVM-Source-Code/#repositories-for-zkasm","title":"Repositories for zkASM","text":"<ul> <li>A compiler that compiles a zkASM program into a JSON file readable to the executor can be found at this repository.</li> <li>A zkasm compiler for the storage state machine: zkevm-storage-rom</li> </ul>"},{"location":"zkEVM/Polygon-zkEVM-Source-Code/#repositories-for-pil","title":"Repositories for PIL","text":"<ul> <li>A compiler that compiles the PIL description into a JSON file readable to the zkExecutor and the zkProver can be found at this repository.</li> <li>Tool that generates a STARK proof from a State Machine written in PIL Language can be found here.</li> </ul>"},{"location":"zkEVM/Setting-Up-Production-zkNode/","title":"Setting Up Production zkNode","text":"<p>In this tutorial we extend the developer's exploration of the Polygon zkEVM on their local machines to launching their own node on the zkEVM Public Testnet.</p> <p>First note that this document assumes familiarity with Docker and CLI. </p> <p>After setting up your zkNode instance, you will be able to run the Synchronizer.</p> <p>Although the Sequencer and Aggregator functions are still centralized at this stage of development, anyone can run a Synchronizer that allows accessing a trustless RPC node.</p> <pre><code>CAUTION!\n\nCurrently the zkProver does not run on ARM-powered Macs. \nFor Windows users, using WSL/WSL2 is not recommended.\n\nUnfortunately, Apple M1 chips are not supported for now \n- since some optimizations on the zkProver require specific Intel instructions. \nThis means some non-M1 computers won't work regardless of the OS, for example: AMD.\n\n</code></pre>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#prerequisites","title":"Prerequisites","text":"<p>This tutorial assumes that you have <code>docker-compose</code> already installed. If you need any help with the installation, please check the official docker-compose installation guide.</p>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#minimum-system-requirements","title":"Minimum System Requirements","text":"<ul> <li>16GB RAM</li> <li>4-core CPU</li> </ul> <p>It is highly recommeneded that you create a separate folder for installing and working around the zkNode. We won't be cloning any repository (unlike local zkNode setup) so it's better to create a folder before starting the zkNode setup: <code>mkdir -p /$HOME/zkevm-node</code></p>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#network-components","title":"Network Components","text":"<p>Here is a list of crucial components that are required before you can run the zkNode:</p> <ul> <li> <p>Ethereum Node - L1 Network</p> </li> <li> <p>zkEVM-Node (or zkNode) - L2 Network</p> </li> <li> <p>JSON RPC Server - Interface to L2 network</p> </li> <li>Synchronizer - Responsible for synchronizing data between L1 and L2</li> <li>Sequencer - Responsible for selecting transactions from the pool and propose new batches</li> <li> <p>Aggregator - Responsible for consolidating the changes in the state proposed by the Sequencers</p> </li> <li> <p>zkProver - Zero knowledge proof generator</p> </li> </ul> <p>Optional components:</p> <ul> <li>Metamask - Wallet to manage blockchain accounts</li> <li>Block Scout Explorer - Web UI to interact with the network information</li> </ul> <p>Next we set up each of the above components.</p>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#ethereum-node-setup","title":"Ethereum Node Setup","text":"<p>The Ethereum Node will be the first component to set up. It is the first because synchronizing the Ethereum network will take a long time, so we will keep it synchronized while we set up the other components to take advantage of this required time.</p> <pre><code>BEFORE WE START\n\nThere are numerous ways to set up an Ethereum L1 environment; \nwe will use Geth for this. We recommend Geth, but any Goerli node should do.\n\nIf you plan to have more than one zkNode in your infrastructure, \nwe advise using a machine that is specifically dedicated to this component.\n</code></pre> <p>First of all, we need to create a folder to store the Ethereum node data outside of the Docker container, in order to not lose all the data if the container is restarted.</p> <pre><code>mkdir -p /$HOME/zkevm-node/.ethereum\n</code></pre> <p>In order to configure the Ethereum node instance, create a file called <code>docker-compose.yml</code> inside the <code>zkevm-node</code> folder:</p> <pre><code>docker-compose.yml\n</code></pre> <pre><code>version: '3'\n\nservices:\n\n  eth-node:\n    container_name: eth-node\n    image: ethereum/client-go:stable\n    ports:\n        - 8545:8545\n        - 8546:8546\n        - 30303:30303\n    volumes:\n        - /$HOME/zkevm-node/.ethereum:/$HOME/geth/.ethereum\n    command: [\n        \"--goerli\",\n        \"--http\",\n        \"--http.addr=0.0.0.0\",\n        \"--http.corsdomain=*\",\n        \"--http.vhosts=*\",\n        \"--http.api=admin,eth,debug,miner,net,txpool,personal,web3\",\n        \"--ws\",\n        \"--ws.addr=0.0.0.0\",\n        \"--ws.origins=*\", \n        \"--graphql\", \n        \"--graphql.corsdomain=*\", \n        \"--graphql.vhosts=*\", \n        \"--vmdebug\", \n        \"--metrics\",\n        \"--datadir=/$HOME/geth/.ethereum\"\n    ]\n</code></pre> <p>To run the Ethereum node instance, go to the <code>zkevm-node</code> folder in your terminal and run the following command:</p> <pre><code>docker-compose up -d\n</code></pre> <p>If you want to follow the logs of the synchronization, run the following command:</p> <pre><code>docker logs -f eth-node\n</code></pre>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#postgres-setup","title":"Postgres Setup","text":"<pre><code>INFO\n\nRunning Postgres instances in a Docker container is an option \nbut we recommend you to use a specialized infrastructure for \nthe database, such as AWS RDS, an on-site server, or any other \nPostgres DB dedicated infrastructure.\n\nIt is not necessary to have a backup because all data is available \non L1 and can be resynchronized if it is lost. \nHowever, having a backup is strongly advised in order to avoid \nresynchronizing the entire network in the event of a DB problem.\n</code></pre> <p>In order to set up the databases for zkNode, we must set up several Postgres instances to be shared between the Node and the Prover/Executor.</p> <ul> <li>Node requires a root access to run the migrations and control the data.</li> <li>Prover only needs a read-only user access to the Merkle tree data and compute the proofs. Executor will need read/write access. Migration file <code>init_prover_db.sql</code> will create the Merkle tree table in State DB.</li> </ul> <p>To achieve that, we need to create several directories for storing the Postgres data outside of the Docker container (so that we don't lose all the data if the container is restarted).</p> <pre><code>mkdir -p /$HOME/zkevm-node/.postgres-state\nmkdir -p /$HOME/zkevm-node/.postgres-pool\nmkdir -p /$HOME/zkevm-node/.postgres-rpc\n</code></pre> <p>Next, download init schema for the Prover DB from Github and store this file in the <code>zkevm-node</code> folder.</p> <p>In order to configure the Postgres instance, create a file called <code>docker-compose.yml</code> inside <code>zkevm-node</code>.</p> <pre><code>docker-compose.yml\n</code></pre> <pre><code># We recommend that you customize the ENVIRONMENT variables values to your preference\n\nversion: '3'\n\nservices:\n  zkevm-state-db:\n    container_name: zkevm-state-db\n    image: postgres\n    deploy:\n      resources:\n        limits:\n          memory: 2G\n        reservations:\n          memory: 1G\n    ports:\n      - 5432:5432\n    volumes:\n      - ./init_prover_db.sql:/docker-entrypoint-initdb.d/init.sql\n      - /$HOME/zkevm-node/.postgres-state:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=state_user\n      - POSTGRES_PASSWORD=state_password\n      - POSTGRES_DB=state_db\n    command: [\"postgres\", \"-N\", \"500\"]\n\n  zkevm-pool-db:\n    container_name: zkevm-pool-db\n    image: postgres\n    deploy:\n      resources:\n        limits:\n          memory: 2G\n        reservations:\n          memory: 1G\n    ports:\n      - 5433:5432\n    volumes:\n      - /$HOME/zkevm-node/.postgres-pool:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=pool_user\n      - POSTGRES_PASSWORD=pool_password\n      - POSTGRES_DB=pool_db\n    command: [\"postgres\", \"-N\", \"500\"]\n\n  zkevm-rpc-db:\n    container_name: zkevm-rpc-db\n    image: postgres\n    deploy:\n      resources:\n        limits:\n          memory: 2G\n        reservations:\n          memory: 1G\n    ports:\n      - 5434:5432\n    volumes:\n      - /$HOME/zkevm-node/.postgres-rpc:/var/lib/postgresql/data\n    environment:\n      - POSTGRES_USER=rpc_user\n      - POSTGRES_PASSWORD=rpc_password\n      - POSTGRES_DB=rpc_db\n    command: [\"postgres\", \"-N\", \"500\"]\n</code></pre> <p>To run the Postgres instance, go to the <code>zkevm-node</code> folder in your terminal and run the following command:</p> <pre><code>docker-compose up -d\n</code></pre> <p>Tags to be used for the different docker images available for the node components can be found here.</p>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#executor-statedb-setup","title":"Executor &amp; StateDB Setup","text":"<p>The zkEVM Prover is available on Docker registry. You can simply start by pulling the image:</p> <pre><code>docker pull hermeznetwork/zkevm-prover\n</code></pre> <p>Download the sample Prover config file and store it as <code>prover-config.json</code> inside the <code>zkevm-node</code> folder.</p> <p>Finally, add the following to the <code>docker-compose.yml</code> file:</p> <pre><code>docker-compose.yml\n</code></pre> <pre><code>  zkevm-prover:\n    container_name: zkevm-prover\n    image: hermeznetwork/zkevm-prover:develop\n    ports:\n      - 50061:50061 # StateDB or Merkle Tree\n      - 50071:50071 # Executor\n    volumes:\n      - ./prover-config.json:/usr/src/app/config.json\n    command: &gt;\n      zkProver -c /usr/src/app/config.json\n</code></pre> <p>This will spin up the Executor and StateDB (or Merkle Tree). For more information, check out the zkProver repository on Github.</p>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#zknode-setup","title":"zkNode Setup","text":"<p>After completing the above steps, we have the Postgres DBs, Prover and Ethereum Node instances running. Now is the perfect time to setup the zkNode.</p> <pre><code>INFO\n\nThe zkNode depends on Postgres, Prover and Ethereum Node instances. \nMake sure it has network access to them. \nIt's advised to setup a dedicated machine for the zkNode.\n</code></pre> <p>Before we start, the zkNode requires an Ethereum account with:</p> <ul> <li>Funds on L1 in order to propose new batches and consolidate the state</li> <li>Tokens to pay the collateral for batch proposal</li> <li>Approval of these tokens to be used by the Rollup Smart Contract on behalf of the Ethereum account owner</li> <li>Register this account as a Sequencer</li> </ul> <p>We have to start with creating a config file to provide the configurations to the node. To do that,</p> <ul> <li>Create a file called <code>config.toml</code> inside the <code>zkevm-node</code> folder.</li> <li>Go to the example config file available on Github and copy its content and paste into the <code>config.toml</code> that we just created inside <code>zkevm-node</code>.</li> </ul> <p>Similarly, create a <code>genesis.json</code> file inside the <code>zkevm-node</code> folder and copy the contents of the sample genesis file available on Github.</p> <p> <pre><code>REMEMBER TO\n\n\n- Replace the DB information if you set it differently while setting up the Postgres instance\n- Set the `Database Host` with the Postgres instance IP\n- Set the `Etherman URL` with the JSON RPC URL of the Ethereum node that you created \n  earlier or use any L1 Goerli service\n- Set the `Etherman Password` (`config.json` =&gt; `PrivateKeyPassword` field, defaults \n  to `testonly`) to allow the node to decrypt the keystore file\n- Set the `MT/Executor URIs` and the `IP and Port` of the MT/Executor Instances and \n  change the array of Provers if a prover was spun up\n</code></pre> </p> <p>Now, we are going to put everything together in order to run the Polygon zkEVM node instance on the public testnet. Simply add the following entries to the <code>docker-compose.yml</code> file:</p> <pre><code>docker-compose.yml\n</code></pre> <pre><code>  zkevm-rpc:\n    container_name: zkevm-rpc\n    image: zkevm-node\n    ports:\n      - 8545:8545\n    environment:\n      - ZKEVM_NODE_STATEDB_HOST=zkevm-state-db\n      - ZKEVM_NODE_POOL_HOST=zkevm-pool-db\n      - ZKEVM_NODE_RPC_DB_HOST=zkevm-rpc-db\n      - ZKEVM_NODE_RPC_BROADCASTURI=public-grpc.zkevm-test.net:61090\n    volumes:\n      - ./config.toml:/app/config.toml\n      - ./genesis.json:/app/genesis.json\n    command:\n      - \"/bin/sh\"\n      - \"-c\"\n      - \"/app/zkevm-node run --genesis /app/genesis.json --cfg /app/config.toml --components rpc\"\n\n  zkevm-sync:\n    container_name: zkevm-sync\n    image: zkevm-node\n    environment:\n      - ZKEVM_NODE_STATEDB_HOST=zkevm-state-db\n    volumes:\n      - ./acc.keystore:/pk/keystore\n      - ./config.toml:/app/config.toml\n      - ./genesis.json:/app/genesis.json\n    command:\n      - \"/bin/sh\"\n      - \"-c\"\n      - \"/app/zkevm-node run --genesis /app/genesis.json --cfg /app/config.toml --components synchronizer\"\n</code></pre> <p>To run the <code>zkNode</code> instance, go to the <code>zkevm-node</code> folder in your terminal and run the following command:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#set-up-block-explorer","title":"Set up Block Explorer","text":"<p>To get a visual access to the network and stats, we need to set up a Blockscout instance. For more details about Blockscout, check out their documentation.</p> <p>Blockscout requires access to its own <code>zkNode</code> RPC-only instance to access the network via JSON RPC Server, and a dedicated Postgres instance in order to save its data.</p> <p>Feel free to customize the environment variables to set the user, password and database for the Explore Postgres instance. Make sure to update the URL to connect to the DB in the Explorer environment variable: <code>DATABASE_URL</code>.</p> <pre><code>docker-compose.yml\n</code></pre> <pre><code>version: '3'\n\nservices:\n\n    zkevm-explorer-db:\n        container_name: zkevm-explorer-db\n        image: postgres\n        ports:\n            - 5432:5432\n        environment:\n            - POSTGRES_USER=test_user\n            - POSTGRES_PASSWORD=test_password\n            - POSTGRES_DB=explorer\n\n    zkevm-explorer:\n        container_name: zkevm-explorer\n        image: hermeznetwork/hermez-node-blockscout:latest\n        ports:\n            - 4000:4000\n        environment:\n            - NETWORK=POE\n            - SUBNETWORK=Polygon Hermez\n            - COIN=ETH\n            - ETHEREUM_JSONRPC_VARIANT=geth\n            - ETHEREUM_JSONRPC_HTTP_URL=http://zkevm-explorer-zknode:8124\n            - DATABASE_URL=postgres://test_user:test_password@zkevm-explorer-db:5432/explorer\n            - ECTO_USE_SSL=false\n            - MIX_ENV=prod\n            - LOGO=/images/blockscout_logo.svg\n            - LOGO_FOOTER=/images/blockscout_logo.svg\n        command: [\"/bin/sh\", \"-c\", \"mix do ecto.create, ecto.migrate; mix phx.server\"]\n\n    zkevm-explorer-zknode:\n      container_name: zkevm-explorer-zknode\n      image: zkevm-node\n      ports:\n        - 8124:8124\n      environment:\n        - ZKEVM_NODE_STATEDB_HOST=zkevm-state-db\n        - ZKEVM_NODE_POOL_HOST=zkevm-pool-db\n        - ZKEVM_NODE_RPC_DB_HOST=zkevm-rpc-db\n        - ZKEVM_NODE_RPC_PORT=8124\n      volumes:\n        - ./config/test.node.config.toml:/app/config.toml\n        - ./config/test.genesis.config.json:/app/genesis.json\n      command:\n        - \"/bin/sh\"\n        - \"-c\"\n        - \"/app/zkevm-node run --genesis /app/genesis.json --cfg /app/config.toml --components rpc --http.api eth,net,debug,zkevm,txpool,web3\"\n</code></pre> <p>To run the Block Explorer, execute the following command:</p> <pre><code>docker-compose up -d zkevm-explorer-db\nsleep 5\ndocker-compose up -d zkevm-explorer\nsleep 5\ndocker-compose up -d zkevm-explorer-zknode\n</code></pre>"},{"location":"zkEVM/Setting-Up-Production-zkNode/#connecting-to-metamask","title":"Connecting to Metamask","text":"<pre><code>INFO\n\nMetamask requires the network to be running while configuring it, so make sure \nyour network is up.\n</code></pre> <p>To configure your Metamask to use your custom zkEVM network, follow these steps:</p> <ol> <li>Log in to your Metamask wallet</li> <li>Click on your account picture and then on Settings</li> <li>On the left menu, click on Networks</li> <li>Click on Add Network button</li> <li>Fill up the L2 network information</li> <li>Network Name: Polygon zkEVM - Goerli</li> <li>New RPC URL: http://IP-and-Port-of-zkEVM-Node-Instance</li> <li>Chain ID: 1422</li> <li>Currency Symbol: ETH</li> <li>Block Explorer URL: http://IP-and-Port-of-Explorer-Instance</li> <li>Click on Save and close the Settings</li> <li>Click on the list of networks in the top right corner</li> <li>Select Polygon zkEVM - Goerli</li> </ol>"},{"location":"zkEVM/references/","title":"References","text":""},{"location":"zkEVM/references/#resources-list","title":"Resources List","text":"<p>A curated list of cryptographic protocols used in this project.</p> <ul> <li> <p>Groth16 protocol</p> </li> <li> <p>The STARK paper</p> </li> <li> <p>PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</p> </li> <li> <p>Plookup: A simplified polynomial protocol for lookup tables</p> </li> </ul>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/","title":"A Generic State Machine","text":"<p>Unlike the mFibonacci state machine, which is an implementation of one specific computation, we now describe a generic state machine that can be instantiated with various computations of the user's choice.</p> <p>The idea here is to create a state machine that behaves like a processor of sorts. In as much as a processor has registries and a clock, so is our generic state machine. It receives instructions in the form of programs written in Assembly, and makes state transitions at each clock in accordance with these instructions.</p> <p>See Figure below, for such a state machine, with registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\), and a state \\(\\big(\\texttt{A}^{\\texttt{i}},\\texttt{B}^{\\texttt{i}}\\big)\\) that changes to another state \\(\\big(\\texttt{A}^{\\texttt{i+2}},\\texttt{B}^{\\texttt{i+2}}\\big)\\) in accordance with two instructions, \\(\\texttt{Instruction}_{\\texttt{i}}\\) and \\(\\texttt{Instruction}_{\\texttt{i+1}}\\).</p> <p></p>  Figure 1: A typical generic state machine  <p>The aim with this document is to explain how the machinery used in the mFibonacci SM; to execute computations, produce proofs of correctness of execution, and verify these proofs; can extend to a generic state machine.</p> <p>Think of our state machine as being composed of two parts; the part that has to do with generating the execution trace, while the other part is focused on verifying that the executions were correctly executed. </p> <ul> <li>The former part is more like the \"software\" of the state machine, as it is concerned with interpreting program instructions and correctly generating the execution trace. A novel language dubbed the Zero-knowledge Assembly Language (zkASM) is used in this part.</li> <li>But the latter part is more like the \"hardware\" as it consists of a set of arithmetic constraints (or their equivalent, polynomial identities) that every correctly generated execution trace must satisfy. Since these arithmetic constraints are transformed into polynomial identities (via an interpolation process), they are described in a novel language called the Polynomial Identity Language (PIL).</li> </ul>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#generic-state-machine-executor","title":"Generic State Machine Executor","text":"<p>As seen with the mFibonacci SM, the SM executor takes certain inputs together with the description of the SM, in order to produce the execution trace specifically corresponding to these inputs. </p> <p></p>  Figure 2: mFibonacci State Machine producing input-specific execution trace  <p>The main difference in the Generic State Machine case, is the inclusion of a program which stipulates computations to be carried out by the SM executor. These computations could range from a simple addition of two registry values, or moving the value in registry \\(\\texttt{A}\\) to registry \\(\\texttt{B}\\), to computing some linear combination of several registry values.</p> <p></p>  Figure 3: A Generic State Machine producing input- and program-specific execution trace   <p>So then, instead of programming the SM executor ourselves with a specific set of instructions as we did with the mFibonacci SM, the Generic SM executor is programmed to read arbitrary instructions encapsulated in some program (depending on the capacity of the SM or the SM's context of application). As mentioned above, each of these programs is initially written, not in a language like Javascript, but in the zkASM language.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#an-example-of-state-machine-instructions","title":"An Example of State Machine Instructions","text":"<p>We continue with the state machine model shown in Figure 1 above; a state machine with two registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\), which executes computations as per instruction(s) specified in a program.</p> <p>Here is an example of a program containing four (4) instructions, expressed in zkASM,</p>  Table 1: A Program with four instructions in Assembly Code    \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline  \\bf{Instructions } \\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline \\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\text{ }\\\\ \\hline \\mathtt{3 =&gt; B} \\qquad\\qquad\\qquad\\qquad\\quad \\\\ \\hline \\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ } \\\\ \\hline  \\end{array} \\end{aligned} \\] <p>Suppose the state machine starts with the initial state \\(\\big(\\texttt{A},\\texttt{B}\\big) = \\big(\\texttt{0},\\texttt{0} \\big)\\). The SM executor sequentially executes each instruction as follows;  </p> <ul> <li>Firstly, \"\\(\\mathtt{\\$\\{getAFreeInput()\\} =&gt; A}\\)\" is a request to execute the function \\(\\texttt{getAFreeInput()}\\). That is, the executor must get a free input value and move it into register \\(\\texttt{A}\\). Note that \"free input\" simply means the input can be any value.</li> <li>Secondly, \"\\(\\mathtt{3 =&gt; B}\\)\" means the executor must move the constant value \\(\\mathtt{3}\\) into register \\(\\mathtt{B}\\). Since the value \\(\\texttt{3}\\) is part of an instruction, it is referred to as the constant of the execution. Also, it is called a constant because, for a given program, it cannot be freely chosen.</li> <li>Thirdly, \"\\(\\mathtt{:ADD }\\)\" instructs the executor to compute the sum of registry values in \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\), and save the output into register \\(\\mathtt{A}\\).</li> <li>Lastly, \"\\(\\mathtt{:END }\\)\" tells the executor to reset the registers \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\) to their initial values in the next state, and thus achieving the cyclic behaviour.</li> </ul>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#execution-trace-example-continued","title":"Execution Trace (Example continued)","text":"<p>In addition to carrying out computations as per instructions in programs, the executor must also generate an execution trace of all state transitions, called the Execution Trace.</p> <p>Consider, as an example, the execution trace the executor produces for the above program of four instructions. Suppose the free input value used is \\(7\\). The generated execution trace can be depicted in tabular form as shown below.</p>  Table 2: Execution Trace of the SM as per four instructions   \\[ \\begin{aligned}\\begin{array}{|l|c|c|c|c|c|c|c|}\\hline  \\bf{Instructions } \\text{ }\\text{ }\\text{ }\\text{ } &amp; \\texttt{FREE} &amp; \\texttt{CONST}&amp; \\texttt{A}&amp; \\mathtt{A'}&amp; \\texttt{B}&amp; \\mathtt{B'} \\\\ \\hline  \\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\text{ } &amp; \\texttt{7} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{7} &amp; \\texttt{0} &amp; \\texttt{0}\\\\ \\hline \\mathtt{3 =&gt; B} \\qquad\\qquad\\qquad\\qquad\\quad &amp; \\texttt{0} &amp; \\texttt{3} &amp; \\texttt{7} &amp; \\texttt{7} &amp; \\texttt{0} &amp; \\texttt{3} \\\\ \\hline \\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{7} &amp; \\texttt{10} &amp; \\texttt{3} &amp; \\texttt{3} \\\\ \\hline \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ } &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{10} &amp; \\texttt{0} &amp; \\texttt{3} &amp; \\texttt{0} \\\\ \\hline \\end{array} \\end{aligned} \\] <p>This execution trace utilises a total of six (6) columns. Perhaps the use of the columns corresponding to the two registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\), as well as the columns for the constant \\(\\texttt{CONST}\\) and the free input \\(\\texttt{FREE}\\), are a bit obvious. But the reason for having the other two columns, \\(\\mathtt{A'}\\) and \\(\\mathtt{B'}\\), may not be so apparent. </p> <p>The reason there are two extra columns, instead of only four, is the need to capture each state transition in full, and per instruction. The column labelled \\(\\mathtt{A'}\\) therefore denotes the next state of the registry \\(\\mathtt{A}\\), and similarly, \\(\\mathtt{B'}\\) denotes the next state of the registry \\(\\mathtt{B}\\). This ensures that each row of the execution trace reflects the entire state transition pertaining to each specific instruction.</p> <p>The execution trace is therefore read row-by-row as follows,</p> <ul> <li>The first row, which is per instruction \"\\(\\mathtt{\\$\\{getAFreeInput()\\} =&gt; A}\\)\", reads thus: The function \\(\\texttt{getAFreeInput()}\\) was executed, by getting the free input value of \\(7\\), which is to be moved into the registry \\(\\texttt{A}\\) as the next registry value.</li> <li>The second row, which is per instruction \"\\(\\mathtt{3 =&gt; B}\\)\", reads as follows: A constant value \\(\\texttt{3}\\) is to be moved into the registry \\(\\texttt{B}\\) as the next registry value, and the registry \\(\\texttt{A}\\) now reflects the value \\(\\texttt{7}\\) as expected per previous instruction.</li> <li>The third row, which is per instruction \"\\(\\mathtt{:ADD }\\)\", indicates that: The executor executed the sum of registry values in \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\) \\(\\big( \\text{i.e.},\\ \\mathtt{7 + 3 = 10}\\big)\\) and the output \\(\\mathtt{10}\\) is to be moved into register \\(\\mathtt{A}\\), as \\(\\mathtt{A}\\)'s next registry value.</li> <li>The last row, which is per instruction \"\\(\\mathtt{:END }\\)\", tells us that: The executor has updated the registry value in \\(\\mathtt{A}\\) according to the previous instruction, and will reset the registries \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\) to zeros (their initial values) as their next registry values.</li> </ul> <p>Note that, for this specific program, a change in the free input from \\(7\\) to another number would obviously yield a different execution trace, yet without violating the first instruction.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#assuring-correctness-of-the-execution-trace","title":"Assuring Correctness Of The Execution Trace","text":"<p>Next, we build a mechanism for verifying correctness of the execution trace. This requires creating a set of arithmetic constraints that only hold true when the execution trace is correct. These arithmetic constraints are equations that registry values in any two consecutive rows of the correct execution trace, must satisfy.</p> <p>Similar to the mFibonacci SM, where each state had to conform to polynomial identities, the arithmetic constraints of the generic state machine will be translated into polynomial identities and ultimately be expressed in PIL.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#creating-the-arithmetic-constraints","title":"Creating The Arithmetic Constraints","text":"<p>Since these arithmetic constraints govern state transitions, they express the next state \\(\\big(\\mathtt{A'} ,\\mathtt{B'}\\big)\\) in terms of current state \\(\\big(\\texttt{A},\\texttt{B}\\big)\\). That is, in terms of the execution trace, the new registry values are linear combinations of previous registry values, together with constants and free inputs.</p> <p>We therefore need auxiliary columns called selectors. Like switches that can either be ON or OFF, selectors too can either have a value \\(\\mathtt{1}\\) or \\(\\mathtt{0}\\), depending on the instruction being executed.</p> <p>In continuing with our example of a four-instruction state machine, </p> <ul> <li> <p>We use selectors; \\(\\texttt{inFREE}\\), \\(\\texttt{inA}\\), \\(\\texttt{inB}\\), \\(\\texttt{setA}\\) and \\(\\texttt{setB}\\); corresponding to the columns; \\(\\texttt{FREE}\\), \\(\\texttt{A}\\), \\(\\texttt{B}\\), \\(\\mathtt{A'}\\) and \\(\\mathtt{B'}\\), respectively.</p> </li> <li> <p>If the instruction being executed involves a column \\(\\texttt{X}\\), then the corresponding selector \\(\\texttt{inX}\\) must have the value \\(\\mathtt{1}\\), otherwise \\(\\texttt{inX}\\) must be \\(\\mathtt{0}\\).</p> </li> <li>If the instruction being executed moves the result of the computation into column \\(\\mathtt{X'}\\), then the corresponding selector \\(\\texttt{setX}\\) must have the value \\(\\mathtt{1}\\), otherwise \\(\\texttt{setX}\\) must be \\(\\mathtt{0}\\).</li> <li>Notice that \\(\\texttt{CONST}\\) does not need a selector. If a computation constant is not needed in an instruction, the corresponding value in the \\(\\texttt{CONST}\\) column is simply set to \\(\\texttt{0}\\).</li> </ul> <p>The arithmetic constraints are therefore defined by the following linear combinations;</p> \\[ \\mathtt{A\u2032 = A + setA \\cdot \\big( inA \\cdot A + inB \\cdot B + inFREE \\cdot FREE + CONST - A \\big)}\\\\ \\tag{Eqn 1(a)} \\] \\[ \\mathtt{B\u2032 = B + setB \\cdot \\big( inA \\cdot A + inB \\cdot B + inFREE \\cdot FREE + CONST - B \\big)} \\\\ \\tag{Eqn 1(b)} \\] <p>The figure below, depicts the linear combinations of the our state machine as an algebraic processor of sorts.</p> <p></p>  Figure 4: The Generic State Machine as an Algebraic Processor  <p>The vertical gray box (with the \"+\" sign) in the above figure, denotes addition. It expresses forming linear combinations of some of the columns; \\(\\texttt{FREE}\\), \\(\\texttt{A}\\), \\(\\texttt{B}\\), or \\(\\texttt{CONST}\\). Each is either included or excluded from the linear combination depending on whether their corresponding selectors have the value \\(\\mathtt{1}\\) or \\(\\mathtt{0}\\). </p> <p>See next subsection for an illustration of how this processor enables testing the constraints.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#testing-arithmetic-constraints-against-instructions","title":"Testing Arithmetic Constraints Against Instructions","text":"<p>We now test if the arithmetic constraints tally with each of the four instructions of our program.</p> <p>(a) The first instruction: \"\\(\\mathtt{\\$\\{getAFreeInput()\\} =&gt; A}\\)\".</p> <p>The first instruction involves a free input \\(7\\) and this free input is moved into registry \\(\\texttt{A}\\), as its the next value. Therefore, by definition of the selectors, \\(\\mathtt{inFREE = 1}\\) and \\(\\mathtt{setA = 1}\\). Also, the value of the other selectors is \\(\\texttt{0}\\). Substituting these values in the above arithmetic constraints yields; $$ \\mathtt{A\u2032 = A + 1 \\cdot \\big( 0 \\cdot A + 0 \\cdot B + 1 \\cdot 7 + 0 - A \\big) = A + (7 - A) = 7}\\text{} $$</p> <p>$$ \\mathtt{B\u2032 = B + 0 \\cdot \\big( 0 \\cdot A + 0 \\cdot B + 1 \\cdot 7 + 0 - B \\big) = B}\\qquad\\qquad\\quad \\ $$ This illustrates that the value of the free input was moved into \\(\\texttt{A}\\), while \\(\\texttt{B}\\) remains unaltered. Hence, the first instruction was correctly executed.</p> <p>(b) The second instruction: \"\\(\\mathtt{3 =&gt; B}\\)\".</p> <p>The second instruction involves the \\(\\mathtt{CONST}\\) column, and the constant value \\(\\texttt{3}\\) is moved into registry \\(\\texttt{B}\\), as its next value. Consequently, \\(\\mathtt{CONST = 3}\\) and \\(\\mathtt{setB = 1}\\). All other selectors have the value \\(\\texttt{0}\\). Again, substituting these values in the arithmetic constraints yields; $$ \\mathtt{A\u2032 = A + 0 \\cdot \\big( 0 \\cdot A + 0 \\cdot B + 0 \\cdot FREE + 3 - A \\big) = A}\\qquad\\qquad\\qquad \\ $$</p> <p>$$ \\mathtt{B\u2032 = B + 1 \\cdot \\big( 0 \\cdot A + 0 \\cdot B + 0 \\cdot FREE + 3 - B \\big) = B + (3 - B) = 3} \\ $$ This shows that the value of \\(\\texttt{A}\\) was not changed, but the constant value \\(\\mathtt{3}\\)  was moved into \\(\\texttt{B}\\). And thus, the second instruction was correctly executed.</p> <p>(c) The third instruction, \"\\(\\mathtt{:ADD }\\)\".</p> <p>This instruction involves the registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\), and the result is moved into registry \\(\\texttt{A}\\), as its the next value. This means, the values of the corresponding selectors are as follows; \\(\\mathtt{inA = 1}\\), \\(\\mathtt{inB = 1}\\) and \\(\\mathtt{setA = 1}\\). The arithmetic constraints become; $$ \\mathtt{A\u2032 = A + 1 \\cdot \\big( 1 \\cdot A + 1 \\cdot B + 0 \\cdot FREE + 0 - A \\big) = A + (A + B - A) = A + B}\\text{ } \\ $$</p> <p>$$ \\mathtt{B\u2032 = B + 0 \\cdot \\big( 1 \\cdot A + 1 \\cdot B + 0 \\cdot FREE + 0 - B \\big) = B}\\qquad\\qquad\\qquad\\qquad\\quad  \\ $$ The sum of the registry values in \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\) was moved into \\(\\texttt{A}\\), while \\(\\texttt{B}\\) remains unmodified, proving that the third instruction was correctly executed.</p> <p>(d) The fourth instruction, \"\\(\\mathtt{:END }\\)\".</p> <p>The fourth instruction moves the initial registry values (i.e., \\(\\mathtt{A = 0}\\) and \\(\\mathtt{B_0 = 0}\\)) into registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\), as their next values, respectively. As a result, values of the corresponding selectors are; \\(\\mathtt{setA = 1}\\) and \\(\\mathtt{setB = 1}\\). Substitutions into the arithmetic constraints give us the following; $$ \\mathtt{A\u2032 = A + 1 \\cdot \\big( 0 \\cdot A + 0 \\cdot B + 0 \\cdot FREE + 0 - A \\big) = A - A = 0} \\ $$</p> <p>$$ \\mathtt{B\u2032 = B + 1 \\cdot \\big( 0 \\cdot A + 0 \\cdot B + 0 \\cdot FREE + 0 - B \\big) = B - B = 0} \\ $$ Clearly, the next registry values of both \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\) are reset to zeros as per the fourth instruction.</p> <p>The execution trace can now be updated to reflect the selector columns, as shown below.</p>  Table 3: Execution Trace of the four instruction SM with Auxiliary columns   \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline \\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ } \\bf{Instructions }\\\\ \\hline \\texttt{ } \\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\\\\\hline \\texttt{ } \\mathtt{3 =&gt; B} \\qquad\\qquad\\qquad\\qquad\\quad\\\\\\hline \\texttt{ } \\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline   \\texttt{FREE} &amp; \\texttt{CONST}&amp; \\texttt{setB}&amp; \\mathtt{setA}&amp; \\texttt{inFREE}&amp; \\mathtt{inB} &amp; \\mathtt{inA} \\\\ \\hline   \\texttt{7} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{3} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline  \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} \\\\ \\hline   \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'}\\\\\\hline \\mathtt{0} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\mathtt{7} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{3}\\\\\\hline \\mathtt{7} &amp; \\mathtt{10} &amp; \\mathtt{3} &amp; \\mathtt{3}\\\\\\hline \\mathtt{10} &amp; \\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0}\\\\\\hline \\end{array} \\end{aligned} \\] <p>Remarks: </p> <p>(a) The \\(\\texttt{CONST}\\) column stores the constants of the computation. It should however, not be mistaken for a constant polynomial. The term 'constant' refers to the fact that the column contains constants of the computations.</p> <p>(b) It shall be seen later, in our implementation of a state machine with jumps, that \\(\\texttt{CONST}\\) is in fact a committed polynomial rather than a constant polynomial.</p> <p>(c) All the operations in the constraints are carried out \\(\\mathtt{\\ modulo }\\) the order \\(p\\) of the prime field. The so-called Goldilocks-like Field, with \\(p = 2^{64} \u2212 2^{32} +1\\), is mainly used where 64-bit numbers suffice (see Plonky2). Otherwise, the BN128 field is deployed.</p> <p>In order to match the type of commitment scheme used in the zkEVM, these arithmetic constraints must first be expressed as polynomial identities, which are in turn compiled with PILCOM.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#a-deeper-context-for-the-executor","title":"A Deeper Context For The Executor","text":"<p>Up to this stage, we have only mentioned that the SM executor reads instructions in a program written in zkASM, and it may take some free inputs in order to produce an execution trace. There is however a lot more detail that goes into this process.</p> <p>For example, the executor does not really read the zkASM program as is. But rather, the zkASM program (which we name here, \\(\\texttt{program.zkasm}\\)), is first compiled with a tool called \\(\\bf{zkasmcom}\\), into a JSON file (call the JSON file, \\(\\texttt{program.json}\\)).</p> <p>Also, the free inputs may come in the form of another JSON file, let's name it \\(\\texttt{input.json}\\). In addition, the executor can read information in databases and receive relevant input such as the \\(\\texttt{PIL.json}\\). (As was seen in the case of the mFibonacci SM).</p> <p>See Figure below for an concise description of what the executor does.</p> <p></p>  Figure 5: SM Executor within a deeper context  <p>Although the execution trace is composed of the evaluations of the committed polynomials and the evaluations of the constant polynomials, the two evaluations do not happen simultaneously. </p> <p>Instead, the constant polynomials are preprocessed only once, because they do not change and are specific for a particular state machine. </p> <p>The committed polynomials, on the other hand, can vary. And are therefore only processed as and when their corresponding verifiable proof is required.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#polynomial-identities","title":"Polynomial Identities","text":"<p>For verification purposes, the execution trace need to be interpolated into polynomial identities.</p> <p>The general theory on interpolation of polynomials involves technical terms such as; Lagrange's interpolation, roots of of unity and Fast Fourier Transforms. However, these concepts are not prerequisites because the way we construct the execution trace, makes sure the polynomial identities follow readily from the arithmetic constraints.</p> <p>In the above example of a zkASM program with four instructions, we can use the fourth-roots of unity \\(\\mathcal{H} = \\{ 1 = \\omega^4, \\omega, \\omega^2, \\omega^3 \\} \\subset \\mathbb{F}_p\\)  to interpolate, such that the columns, $$ \\mathtt{ A, inA, setA, B, inB, setB, FREE, inFREE, CONST } $$ correspond to polynomials in \\(\\texttt{x}\\) , where \\(\\mathtt{x = \\omega^i}\\), written (without changing symbols) as, $$ \\mathtt{ A(x), inA(x), setA(x), B(x), inB(x), setB(x), FREE(x), inFREE(x), CONST(x)}. $$ That is, according to the execution trace in Table 3 above, these polynomials are equivalent to the column-arrays, as follows, $$ \\mathtt{A = [0,7,7,10]}\\text{ } \\iff\\text{ } \\mathtt{ A(x) = A(\\omega^i) = A[i]}\\qquad\\quad\\qquad\\qquad\\qquad\\text{ } \\ $$</p> \\[ \\mathtt{B = [0,0,3,3] }\\text{ } \\iff\\text{ } \\mathtt{ B(x) = B(\\omega^i) = B[i]}\\qquad\\qquad\\qquad\\qquad\\qquad\\text{}\\text{ } \\\\ \\] \\[ \\mathtt{inA = [0,0,1,1]\\text{ } \\iff\\text{ } \\mathtt{ inA(x) = inA(\\omega^i) = inA[i]}}\\qquad\\qquad\\quad\\quad\\text{}\\text{} \\\\ \\] \\[ \\mathtt{inB = [0,0,1,0]}\\text{ } \\iff\\text{ } \\mathtt{inB(x) = inB(\\omega^i) = inB[i]}\\qquad\\qquad\\quad\\quad\\text{}\\text{ } \\\\ \\] \\[ \\mathtt{setA = [1,0,1,1]\\text{ } \\iff\\text{ } \\mathtt{ setA(x) = setA(\\omega^i) = setA[i]}}\\qquad\\quad\\quad\\text{}\\text{} \\\\ \\] \\[ \\mathtt{setB = [0,1,0,1] }\\text{ } \\iff\\text{ } \\mathtt{setB(x) = setB(\\omega^i) = setB[i]}\\qquad\\quad\\quad\\text{}\\text{ } \\\\ \\] \\[ \\mathtt{FREE = [7,0,0,0]}\\text{ } \\iff\\text{ } \\mathtt{FREE(x) =  FREE(\\omega^i) = FREE[i]}\\qquad\\quad\\quad\\text{}\\text{ } \\\\ \\] \\[ \\mathtt{CONST = [1,0,0,0]}\\text{ } \\iff\\text{ } \\mathtt{CONST(x) = CONST(\\omega^i) = CONST[i]}\\quad\\quad\\text{}\\text{ } \\\\ \\] \\[ \\mathtt{inFREE = [1,0,0,0] } \\text{ }\\text{ } \\iff\\text{ } \\ \\mathtt{inFREE(x) = inFREE(\\omega^i) = inFREE[i]} \\] <p>The arithmetic constraints seen above as \\(\\bf{Eqn\\ 1(a)}\\) and \\(\\bf{1(b)}\\), are easily written as polynomial identities, as follows, $$ \\mathtt{A(x\\omega) - \\big(A(x) + setA(x) \\cdot \\big( op(x) - A(x) \\big) \\big) = 0} \\ $$</p> \\[ \\mathtt{B(x\\omega) - \\big( B(x) + setB(x) \\cdot \\big(  op(x) - B(x) \\big) \\big) = 0} \\\\ \\] <p>where</p> \\[ \\mathtt{op(x) = inA(x) \\cdot A(x) + inB(x) \\cdot B(x) + inFREE(x) \\cdot FREE(x) + CONST(x)}.\\\\ \\] <p>As far as boundary constraints are concerned, we can, for instance,</p> <ul> <li> <p>make both the free input and the last registry value of \\(\\mathtt{A}\\) public,</p> </li> <li> <p>create public 'variables'; \\(\\texttt{input}\\) and \\(\\texttt{output}\\),</p> </li> <li> <p>set boundary constraints,   $$   \\mathtt{L1(x) \\cdot \\big(FREE(\\omega^0) - input\\big) = 0} \\   \\mathtt{L2(x) \\cdot \\big(A(\\omega^{3}) - output\\big) = 0}\\quad \\   $$   where \\(\\mathtt{L1(x)}\\) and \\(\\mathtt{L2(x)}\\) are precomputed constant polynomials. In fact, \\(\\mathtt{L1(x) = [1,0,0,0]}\\) and  \\(\\mathtt{L2(x) = [0,0,0,1]}\\). </p> </li> </ul> <p>In the big scheme of things, these are Lagrange polynomials emanating from the interpolation.</p> <p>Verification relies on the fact that: These polynomial identities, including the boundary constraints, hold true if, and only if the execution trace is correct and faithful to the instructions in the zkASM program.</p> <p>The PIL description of the SM executor, reading instructions from the zkASM program with four instructions, is depicted in the Figure below.</p> <p></p>  Figure 6: The PIL description for the 4-instruction program"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#dealing-with-negative-numbers","title":"Dealing With Negative Numbers","text":"<p>In this subsection we make a few remarks on how to handle negative numbers. </p> <p>Recall that all values of the execution trace belong to a field \\(\\mathbb{F}_p\\) where \\(p=2^{64} \u22122^{32} +1\\). Since, for all \\(\\mathtt{x \\in \\mathbb{F}_p }\\),  $$ \\mathtt{(p-x) + x \\equiv p \\texttt{ modulo } p} $$ and  \\(\\mathtt{p \\equiv 0 \\texttt{ modulo } p}\\), it follows that \\(\\mathtt{-x \\equiv p-x \\texttt{ modulo } p}\\). Therefore, any negative number \\(\\mathtt{-a}\\) is interpreted as \\(\\mathtt{p \u2212 a}\\).</p> <p>We consider a zkASM program with four instructions as before, except that it now moves a negative constant into registry \\(\\mathtt{B}\\). The execution trace with free input \\(\\mathtt{7}\\) is as a follows,</p>  Table 4: How to handle an instruction with a negative number  \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline \\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ } \\bf{Instructions }\\\\ \\hline \\texttt{ } \\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\\\\\hline \\texttt{ } \\mathtt{-3 =&gt; B} \\qquad\\qquad\\qquad\\qquad\\quad\\\\\\hline \\texttt{ } \\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline   \\texttt{FREE} &amp; \\texttt{CONST}&amp; \\texttt{setB}&amp; \\mathtt{setA}&amp; \\texttt{inFREE}&amp; \\mathtt{inB} &amp; \\mathtt{inA} \\\\ \\hline  \\texttt{7} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{p-3} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'}\\\\\\hline \\mathtt{0} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\mathtt{7} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{p-3}\\\\\\hline \\mathtt{7} &amp; \\mathtt{4} &amp; \\mathtt{p-3} &amp; \\mathtt{p-3}\\\\\\hline \\mathtt{4} &amp; \\mathtt{0} &amp; \\mathtt{p-3} &amp; \\mathtt{0}\\\\\\hline \\end{array} \\end{aligned} \\]"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#using-conditional-jumps","title":"Using Conditional Jumps","text":"<p>The FFTs are most efficient for polynomials of degree \\(\\mathtt{T + 1 = 2^N}\\). This causes descrepancies when the program being executed has fewer instructions than an appropriate power of \\(2\\).</p> <p>Consider the following program with five (5) instructions, and its corresponding execution trace:</p>  Table 5: Execution Trace of the SM executing the 5-instruction program   \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline \\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ } \\bf{Instructions }\\\\ \\hline \\texttt{ } \\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\\\\\hline \\texttt{ } \\mathtt{3 =&gt; B} \\qquad\\qquad\\qquad\\qquad\\quad\\\\\\hline \\texttt{ } \\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline   \\texttt{FREE} &amp; \\texttt{CONST}&amp; \\texttt{setB}&amp; \\mathtt{setA}&amp; \\texttt{inFREE}&amp; \\mathtt{inB} &amp; \\mathtt{inA} \\\\ \\hline  \\texttt{7} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{3} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} \\\\ \\hline   \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'}\\\\\\hline \\mathtt{0} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\mathtt{7} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{3}\\\\\\hline \\mathtt{7} &amp; \\mathtt{10} &amp; \\mathtt{3} &amp; \\mathtt{3}\\\\\\hline \\mathtt{10} &amp; \\mathtt{13} &amp; \\mathtt{3} &amp; \\mathtt{3}\\\\\\hline \\mathtt{13} &amp; \\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0}\\\\\\hline \\end{array} \\end{aligned} \\] <p>The question is: How (or when) to end the program when the trace has size \\(\\mathtt{5}\\) and the polynomials have \\(\\mathtt{8}\\) evaluations?</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#naive-way-to-end-the-program","title":"Na\u00efve Way To End The Program","text":"<p>A simple fix could be: Repeating the \"\\(\\texttt{:END}\\)\" instruction in order to fill the execution trace up to the eighth row. But, for the sake of preserving the cyclicity of the state machine, the last instruction must ensure that the next values of registries revert back to their initial values.</p>  Table 6: Execution Trace of the 5-instruction SM with a repeated \":END\" instruction   \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline \\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ }\\texttt{ } \\bf{Instructions }\\\\ \\hline \\texttt{ } \\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\\\\\hline \\texttt{ } \\mathtt{3 =&gt; B} \\qquad\\qquad\\qquad\\qquad\\quad\\\\\\hline \\texttt{ } \\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\texttt{ } \\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ }\\\\\\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline   \\texttt{FREE} &amp; \\texttt{CONST}&amp; \\texttt{setB}&amp; \\mathtt{setA}&amp; \\texttt{inFREE}&amp; \\mathtt{inB} &amp; \\mathtt{inA} \\\\ \\hline  \\texttt{7} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{3} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} \\\\ \\hline   \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{1} &amp; \\texttt{1} &amp; \\texttt{0} &amp; \\texttt{0} &amp; \\texttt{0} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'}\\\\\\hline \\mathtt{0} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\mathtt{7} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{3}\\\\\\hline \\mathtt{7} &amp; \\mathtt{10} &amp; \\mathtt{3} &amp; \\mathtt{3}\\\\\\hline \\mathtt{10} &amp; \\mathtt{13} &amp; \\mathtt{3} &amp; \\mathtt{3}\\\\\\hline \\mathtt{13} &amp; \\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0}\\\\\\hline \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\end{array} \\end{aligned} \\] <p>Note that, since there are no restrictions placed on the next values of \\(\\mathtt{A'}\\) and \\(\\mathtt{B'}\\), we can set these to any values. In the above case, both \\(\\mathtt{A'}\\) and \\(\\mathtt{B'}\\) are set to zeros.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#conditional-jumps-examples","title":"Conditional Jumps Examples","text":"<p>We now add to the zkASM program, the instruction \"\\(\\text{jump to a particular address if ... }\\)\", denoted by \\(\\mathtt{JMPZ(addr)}\\). Which means the executor must jump to the specified position in the program on condition that the preceding operation, denoted by \\(\\texttt{op}\\), is zero.</p> <p>Since this instruction needs to specify the destination of the jump, we need to add the line at which each instruction is placed in the program. This is shown in the table below.</p>  Table 7: The 5-instruction program with auxiliary columns   \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline  \\texttt{ line } &amp; \\bf{Instructions } \\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 0 } &amp; \\text{ }\\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\text{ }\\\\ \\hline \\quad\\texttt{ 1 } &amp; \\text{ }\\mathtt{-3 =&gt; B} \\qquad\\qquad\\qquad\\quad\\quad \\\\ \\hline \\quad\\texttt{ 2 } &amp; \\text{ }\\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 3 } &amp; \\text{ }\\mathtt{A : JMPZ(5) } \\quad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 4 } &amp; \\text{ }\\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 5 } &amp; \\text{ }\\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ } \\\\ \\hline  \\end{array} \\end{aligned} \\] <p>With regards to the instruction \"\\(\\texttt{A:JMPZ(5)}\\)\" in \\(\\texttt{line}\\) \\(\\texttt{3}\\) of the zkASM program,</p> <p>(a) The \\(\\texttt{A}\\) registry, preceding the colon, means that \\(\\texttt{op}\\) is set to the value of \\(\\texttt{A}\\).</p> <p>(b) If \\(\\texttt{op = 0}\\), the program jumps to $\\texttt{line} $ \\(\\texttt{5}\\).</p> <p>(c) If \\(\\mathtt{op \\not= 0}\\),  the program continues sequentially with the instruction at $\\texttt{line} $ \\(\\texttt{4}\\).</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#programs-with-conditional-jumps","title":"Programs With Conditional Jumps","text":"<p>Suppose the executor of our SM reads a zkASM program where one of its instructions requires a free input to be taken. The aim here is to observe how a variation in free inputs affects the length of the execution trace.</p> <p>For the sake of brevity, we present execution traces with only five columns (i.e., we omit the columns corresponding to the selectors and setters).</p> <p>Example A: (Execution Trace with \\(\\mathtt{FREE = 7}\\)) </p> <p>In this example, the free input is \\(\\mathtt{FREE = 7}\\). Focusing on \\(\\texttt{line}\\) \\(\\texttt{3}\\): Since in the previous operation, \\(\\mathtt{op=ADD}\\) and \\(\\mathtt{A = A + B = 4 \\not= 0}\\), and thus the condition for the \\(\\texttt{JMPZ}\\) is not satisfied. There's no jump. The execution continues sequentially to the instruction in \\(\\texttt{line}\\) \\(\\texttt{4}\\). The resulting execution trace is therefore \\(6\\) steps long.  </p> \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline  \\texttt{ line } &amp; \\bf{Instructions } \\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 0 } &amp; \\text{ }\\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\text{ }\\\\ \\hline \\quad\\texttt{ 1 } &amp; \\text{ }\\mathtt{-3 =&gt; B} \\qquad\\qquad\\qquad\\quad\\quad \\\\ \\hline \\quad\\texttt{ 2 } &amp; \\text{ }\\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 3 } &amp; \\text{ }\\mathtt{A : JMPZ(5) } \\quad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 4 } &amp; \\text{ }\\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 5 } &amp; \\text{ }\\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ } \\\\ \\hline  \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{FREE} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'\\ }\\\\\\hline \\quad\\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{0\\ }\\\\\\hline \\quad\\mathtt{0} &amp;\\mathtt{7} &amp; \\mathtt{7} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ }\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{7} &amp; \\mathtt{4} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ }\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{4} &amp; \\mathtt{4} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ }\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{4} &amp; \\mathtt{1} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ }\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{0}\\\\\\hline \\end{array} \\end{aligned} \\] <p>Example B: (Execution Trace with \\(\\mathtt{FREE = 3}\\)) </p> <p>In this case, the free input is \\(\\mathtt{FREE = 3}\\). Again, focusing on \\(\\texttt{line}\\) \\(\\texttt{3}\\): Since in the previous operation, \\(\\mathtt{op=ADD}\\) and \\(\\mathtt{A = A + B = 0}\\), it means the condition for the \\(\\texttt{JMPZ}\\) is satisfied. Hence the executor jumps to \\(\\texttt{line}\\) \\(\\texttt{5}\\) as per instruction in \\(\\texttt{line}\\) \\(\\texttt{3}\\). The execution trace is now only \\(5\\) steps long.</p> \\[ \\begin{aligned} \\begin{array}{|l|c|} \\hline  \\texttt{ line } &amp; \\bf{Instructions } \\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 0 } &amp; \\text{ }\\mathtt{\\$\\{getAFreeInput()\\} =&gt; A} \\text{ }\\\\ \\hline \\quad\\texttt{ 1 } &amp; \\text{ }\\mathtt{-3 =&gt; B} \\qquad\\qquad\\qquad\\quad\\quad \\\\ \\hline \\quad\\texttt{ 2 } &amp; \\text{ }\\mathtt{:ADD } \\qquad\\qquad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 3 } &amp; \\text{ }\\mathtt{A : JMPZ(5) } \\quad\\qquad\\quad\\quad\\quad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{ 5 } &amp; \\text{ }\\mathtt{:END } \\qquad\\qquad\\qquad\\quad\\qquad\\text{}\\text{ }\\text{ } \\\\ \\hline  \\end{array} \\hspace{0.1cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{FREE} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'\\ }\\\\\\hline \\quad\\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{0\\ }\\\\\\hline \\quad\\mathtt{0} &amp;\\mathtt{3} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ }\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ }\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ }\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{0}\\\\\\hline \\end{array} \\end{aligned} \\] <p>We observe that the inclusion of conditional jumps in the zkASM programs introduces dynamics to the executor's output. For example, the instructions in the zkASM program (in Example B) are not sequentially executed. This requires more agility in our proving system, more especially that our aim is to lighten the verifier's work.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#correctness-checks-for-state-machines-with-jumps","title":"Correctness Checks For State Machines With Jumps","text":"<p>The dynamism brought about by the inclusion of jumps in our zkASM programs means more checks need to be added, in order to prove correct behaviour of the state machine.</p> <p>Since the instructions require the executor to perform varied operations, and these operations are not sequentially executed due to the presence of jumps, we need to do a few more checks;</p> <ol> <li>Check Program Operations. </li> </ol> <p>Every operation being executed needs to be checked if it is the correct one. That is, if the instruction is an \\(\\texttt{ADD}\\), then we must check that indeed an \\(\\texttt{ADD}\\) was performed and not a different operation.</p> <ol> <li>Check Instructions\u2019 Sequence.</li> </ol> <p>The sequence in which the operations are executed must tally with the instructions in the zkASM program, and not necessarily their usual chronological sequence of the lines of code. e.g., The lines of instructions executed in Example B above, are lines \\(\\texttt{ 0, 1, 2, 3, 5,}\\)  where \\(\\texttt{line}\\) \\(\\texttt{4}\\) was skipped.</p> <p>Note that more complicated programs can be built, where for instance, the SM execution jumps to a previous line of code, and thus repeating execution of some instructions.</p> <ol> <li>Correct program ending.</li> </ol> <p>How the program ends also needs to be managed. Due to the presence of jumps, the length of the execution trace is no longer constant for the same program if the free inputs are varied. </p> <ol> <li>Publics Are Placed At Known Steps.</li> </ol> <p>We must ensure that all \\(\\texttt{publics}\\) (the inputs and the outputs) are in the known position. So, \\(\\texttt{publics}\\) should be placed at known steps. This ensures that the SM's PIL does not have to change with every execution. </p> <p>For this reason, \\(\\texttt{publics}\\) are going to be placed in either the first positions of the polynomial or the last positions of the polynomial (these are specified positions in the arrays representing the columns of the trace).</p> <ol> <li>Correct Program (ROM) Execution.</li> </ol> <p>Although the polynomial identities are there to monitor correct state transitions (checking that each instruction does what it is supposed to do), and also that the correct sequence of instructions is followed, one still needs to make sure the instruction being executed belongs to the program in the first place.  So, if for instance, the third instruction is being executed, is it really the third instruction of the right program or not.</p> <p>One of the implications of a dynamic execution trace, due to the inclusion of jumps, is that some of the previously constant (or preprocessed) polynomials must now be committed polynomials.</p> <p>If we are going to allow polynomials (i.e., columns in the execution trace) corresponding to the instructions to be committed, we need to be cautious that only instructions belonging to the right program are being executed. For this purpose, we are going to use a tool called \\(\\mathbf{Plookup}\\).</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#checking-sequence-of-instructions","title":"Checking Sequence Of Instructions","text":"<p>In order to keep track of which line of the program is currently being executed, a new registry called \"Program Counter\" is added to the state machine.</p> <p>We denote it by \\(\\texttt{zkPC}\\) because it is verified in a zero-knowledge manner.</p> <p>The \\(\\texttt{zkPC}\\) is therefore a new column of the execution trace and it contains, at each clock, the line in the zkASM program of the instruction being executed.</p> <p></p>  Figure 7: A state machine with a Program Counter  <p>In addition to the \\(\\texttt{JMPZ(addr)}\\), an unconditional jump instruction \\(\\texttt{JMP(addr)}\\) is allowed in the zkASM program. </p> <p>Unlike the \\(\\texttt{JMPZ(addr)}\\) instruction, when the state machine executes \\(\\texttt{JMP(addr)}\\), it must jump to the line \\(\\texttt{addr}\\), irrespective of what the value of \\(\\texttt{op}\\) is.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#the-program-counter-constraint-related-to-textttjmp","title":"The Program Counter Constraint Related To \\(\\texttt{JMP}\\)","text":"<p>This is how the \\(\\texttt{JMP(addr)}\\) instruction is implemented: A new selector called \\(\\texttt{JMP}\\) is added, as a column to the execution trace. And, the Program Counter \\(\\texttt{zkPC}\\) now uses the following identity to keep track of the correct line of the assembly program to be executed next; $$ \\mathtt{zkPC' = (zkPC+1)+JMP \\cdot \\big(addr\u2212(zkPC+1)\\big)} \\tag{Eqn 2*} $$ \\(\\texttt{JMP}\\) therefore acts as a 'flag' where;</p> <ul> <li>if \\(\\texttt{JMP}\\) is not activated (i.e., if \\(\\texttt{JMP}\\) is \\(\\mathtt{0}\\)),</li> </ul> \\[ \\mathtt{zkPC' =  (zkPC+1)+ 0 \\cdot \\big(addr\u2212(zkPC+1)\\big) = zkPC+1} \\] <ul> <li>otherwise,  if \\(\\texttt{JMP}\\) is activated (i.e., if \\(\\texttt{JMP}\\) is \\(\\mathtt{1}\\)),</li> </ul> \\[ \\mathtt{zkPC' = (zkPC+1)+ 1 \\cdot \\big(addr\u2212(zkPC+1)\\big) = addr} \\] <p>Note that execution continues with the next chronological line of instruction \\(\\texttt{zkPC+1}\\) when \\(\\texttt{JMP}\\) is \\(\\mathtt{0}\\), but otherwise proceeds to execute the instruction in line number \\(\\texttt{addr}\\).</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#the-program-counter-constraint-related-to-textttjmpz","title":"The Program Counter Constraint Related To \\(\\texttt{JMPZ}\\)","text":"<p>The \\(\\texttt{JMPZ(addr)}\\) similarly needs a selector to be added as an extra column to the execution trace, call it \\(\\texttt{JMPZ}\\). Since the \\(\\texttt{JMPZ(addr)}\\) instruction is executed only on condition that \\(\\texttt{op}\\) is zero, we introduce a flag called \\(\\mathtt{isZero}\\), such that; </p> <p>\\(\\mathtt{isZero = 1}\\) if \\(\\texttt{op = 0}\\), and \\(\\mathtt{isZero = 0}\\) if \\(\\mathtt{op \\not= 0}\\). </p> <p>This means \\(\\texttt{op}\\) and \\(\\mathtt{isZero}\\) satisfy the following constraint,</p> \\[ \\mathtt{isZero \\cdot op = 0} \\tag{Eqn 3*} \\] <p>Note that \\(\\texttt{op}\\) is a field element, and every non-zero element of the prime field \\(\\mathbb{F}_p\\) has an inverse. That is, \\(\\texttt{op}^{-1}\\) exists if and only if \\(\\mathtt{op \\not= 0}\\). The following constraint together with \\(\\text{Eqn 3*}\\) can be used to check whether \\(\\texttt{op}\\) and \\(\\mathtt{isZero}\\) are as required, $$ \\mathtt{isZero\\ := (1 \u2212 op \\cdot op^{\u22121})} \\tag{Eqn 4*} $$</p> <p>Since \\(\\mathtt{JMPZ = 1}\\) only if \\(\\texttt{JMPZ(addr)}\\) is the very instruction in the line currently being executed, and \\(\\mathtt{zkPC' = addr}\\)  only if  \\(\\mathtt{isZero = 1}\\). </p> <p>It follows that the factor  \\((\\mathtt{JMPZ \\cdot isZero})\\) \\(\\mathtt{ = 1}\\)  only if both  \\(\\texttt{JMPZ}\\) \\(\\mathtt{= 1}\\)  and \\(\\mathtt{isZero}\\) \\(\\mathtt{= 1}\\)  hold true.</p> <p>Hence, the following constraint enforces the correct sequence of instructions when \\(\\texttt{JMPZ}\\) is executed;</p> \\[ \\mathtt{zkPC' = (zkPC+1)+(JMPZ \\cdot isZero) \\cdot \\big(addr\u2212(zkPC+1)\\big)} \\tag{Eqn 5*} \\] <p>In order to ascertain correct execution of the \\(\\texttt{JMPZ(addr)}\\) instruction, it suffices to check the above three constraints; \\(\\text{Eqn 2*}\\), \\(\\text{Eqn 2*}\\) and \\(\\text{Eqn 4*}\\).</p> <p>Note that \\(\\mathtt{op^{\u22121}}\\) is not part of any instruction. The evaluations of \\(\\mathtt{op^{\u22121}}\\) therefore have to be included in the execution trace as a committed polynomial, and thus enables checking the first identity, \\(\\text{Eqn 2*}\\). </p> <p>Most importantly, we rename the polynomial \\(\\mathtt{op^{\u22121}}\\) as \\(\\texttt{invOp}\\).</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#the-program-counter-constraint-related-to-textttjmp-and-textttjmpz","title":"The Program Counter Constraint Related To \\(\\texttt{JMP}\\) And \\(\\texttt{JMPZ}\\)","text":"<p>All four constraints, \\(\\text{Eqn 0*}\\), \\(\\text{Eqn 1*}\\), \\(\\text{Eqn 2*}\\) and \\(\\text{Eqn 3*}\\) can be merged as follows;</p> \\[ \\mathtt{isZero\\ := (1 \u2212 op \\cdot op^{\u22121})},\\qquad\\qquad\\qquad\\qquad\\text{ }\\qquad \\\\ \\mathtt{isZero \\cdot op = 0},\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\quad \\\\ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP}, \\qquad\\qquad\\qquad\\qquad\\quad \\\\ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big)} \\tag{Eqn 6*} \\] <p>Define \"\\(\\texttt{addr}\\)\" as an intermediate polynomial,  $$ \\mathtt{ addr := offset}, \\tag{Eqn 7*} $$ where \\(\\texttt{offset}\\) is provided as part of the jump instructions, \\(\\texttt{JMPZ(addr)}\\) and \\(\\texttt{JMP(addr)}\\).</p> <p>We now have the following new columns in the execution trace,</p> \\[ \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{zkPC} &amp; \\mathtt{JMP} &amp; \\mathtt{JMPZ} &amp; \\mathtt{invOp} &amp; \\mathtt{offset}\\\\\\hline \\quad\\mathtt{\\dots\\ } &amp; \\mathtt{\\dots } &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots}\\\\\\hline \\quad\\mathtt{\\dots} &amp;\\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots}\\\\\\hline \\quad\\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots}\\\\\\hline \\quad\\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots} &amp; \\mathtt{\\dots}\\\\ \\end{array} \\] <p>With the intermediate definition in \\(\\text{Eqn 7*}\\) , we are preparing the path to expanding the \\(\\texttt{addr}\\) definition, for example, to include other sources (apart from instructions) from which to get the destination address in jumps.</p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#correct-program-ending-with-a-loop","title":"Correct Program Ending With A Loop","text":"<p>We have previously resorted to ending our program by repeating the \"\\(\\texttt{:END}\\)\" instruction. This was not the best solution. </p> <p>To properly finish our programs, we need to ensure that the execution trace generated from the assembly is cyclic.</p> <p>We therefore utilise a loop while the current \\(\\texttt{line}\\) is less than \\(\\mathtt{N-1}\\), a step before the last step of the execution trace. That is, before jumping back to the start, with the \\(\\texttt{JMP(start)}\\) instruction, the current \\(\\texttt{line}\\) is checked with the function \"\\(\\texttt{beforeLast()}\\)\".</p> <p>So, we query the executor for when the execution trace is at its last but one row, with the following line of code,  $$ \\mathtt{${beforeLast()}\\ \\ :JMPZ(finalWait)} ; $$ See Figure 8 for the zkASM code.</p> <p>The assembly program uses labels instead of explicit line numbers, hence conforming to how assembly programs are typically written. Labels are convenient because with them, the assembly compiler can take care of computing actual line numbers. For instance, as in Figure 8 below; \\(\\mathtt{start}\\) is line \\(\\mathtt{0}\\) and \\(\\mathtt{finalWait}\\) is line \\(\\mathtt{5}\\).</p> <p></p>  Figure 8: Ending a zkASM Program with a loop"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#step-by-step-commentary-on-the-execution-trace","title":"Step-by-step Commentary On The Execution Trace","text":"<p>The intention here to give a step-by-step commentary on the execution trace for the Assembly code in Figure 8 above, for a free input equal to \\(\\mathtt{3}\\) and a trace size (interpolation size) equal to \\(\\texttt{N = 8}\\).</p> <p>We show the values corresponding to each \\(\\texttt{step}\\) of the execution trace, particularly for,</p> <ul> <li>The committed polynomials that form part of the instruction; \\(\\texttt{CONST}\\), \\(\\texttt{offset}\\), \\(\\texttt{JMP}\\), \\(\\texttt{JMPZ}\\), \\(\\texttt{setB}\\), \\(\\texttt{setA}\\), \\(\\texttt{inFREE}\\),  \\(\\texttt{inB}\\), \\(\\texttt{inA}\\), \\(\\texttt{zkPC}\\) and \\(\\mathtt{zkPC'}\\). </li> <li>The committed polynomials that are only part of the trace; \\(\\texttt{FREE}\\), \\(\\texttt{A}\\), \\(\\mathtt{A'}\\), \\(\\texttt{B}\\), \\(\\mathtt{B'}\\) and  \\(\\texttt{invOp}\\).</li> <li>The intermediate polynomials \\(\\texttt{Im}\\), which are just intermediate definitions; \\(\\texttt{op}\\), \\(\\texttt{isZero}\\) and \\(\\texttt{doJMP}\\).</li> </ul> <p>Step 0:  \"\\(\\mathtt{\\${getAFreeInput()} =&gt; A}\\)\"</p> <p>Since the instruction here at \\(\\texttt{Step}\\) \\(\\mathtt{0}\\) (corresponding to \\(\\texttt{line}\\) \\(\\texttt{0}\\) of the Assembly code) requires a free input \\(\\mathtt{3}\\) to be taken and moved into the registry \\(\\mathtt{A}\\), the values of the involved polynomials are therefore; $$  \\mathtt{inFREE = 1},\\ \\mathtt{FREE = 3},\\ \\mathtt{setA = 1},\\ \\mathtt{A' = 3}\\ \\texttt{and}\\ \\mathtt{CONST = 0}. $$ As a result, $$ \\mathtt{op\\ =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST = 0 \\cdot A\\ +\\ 0 \\cdot B\\ +\\ 1 \\cdot 3\\ +\\ 0\\ = 3} $$ and \\(\\mathtt{invOp = 3^{-1}}\\).</p> <p>Regarding the Program Counter; First note that initially \\(\\mathtt{zkPC = 0}\\). And, since \\(\\mathtt{op = 3}\\)  and \\(\\mathtt{invOp = 3^{-1}}\\), then  $$ \\mathtt{isZero\\ := (1 \u2212 op \\cdot op^{\u22121}) = (1 \u2212 3 \\cdot 3^{\u22121}) = 0}.\\qquad\\qquad\\qquad\\qquad\\text{ }\\qquad \\ $$ Also, since there are no jumps in the instruction, \\(\\mathtt{JMP = 0}\\) and \\(\\mathtt{JMPZ = 0}\\), and therefore \\(\\mathtt{zkPC\u2032 = zkPC + 1}\\). </p> <p>We use Eqn 4* to check whether \\(\\mathtt{zkPC\u2032 = zkPC + 1 = 0+1 = 1}\\). </p> <p>First, note that, </p> \\[ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP = 0 \\cdot 0 + 0 = 0}. \\qquad\\qquad\\qquad\\qquad\\qquad \\\\ \\] <p>This means, according to Eqn 4*, </p> \\[ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big) = (0+1) + 0 \\cdot \\big( addr\u2212(0+1) \\big) = 0+1 = 1}. \\] <p>Step 1:  \"\\(\\mathtt{\\mathtt{-3 =&gt; B}}\\)\"</p> <p>In this step, a constant  \\(\\mathtt{CONST = -3}\\)  is moved into the \\(\\texttt{B}\\) registry. Hence \\(\\mathtt{setB = 1}\\), \\(\\mathtt{B' = -3}\\), but \\(\\mathtt{inB = 0}\\), \\(\\mathtt{inA = 0}\\) and \\(\\mathtt{inFREE = 0}\\). This yields, $$ \\mathtt{op =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST\\ =\\ 0 \\cdot A\\ +\\ 0 \\cdot B\\ +\\ 0 \\cdot FREE\\ + (-3)    = -3} $$ and  \\(\\mathtt{invOp = (-3)^{-1}}\\).</p> <p>So, \\(\\mathtt{isZero\\ := (1 \u2212 op \\cdot op^{\u22121}) = \\big(1 \u2212 (-3) \\cdot (-3)^{\u22121}\\big) = 0}\\). </p> <p>Again, the absence of jumps in the instruction means, \\(\\mathtt{JMP = 0}\\) and \\(\\mathtt{JMPZ = 0}\\). And therefore \\(\\mathtt{zkPC\u2032 = zkPC + 1}\\).</p> <p>Again, we use Eqn 4* to check whether \\(\\mathtt{zkPC\u2032 = zkPC + 1 = 1+1 = 2}\\). </p> <p>Note that, $$ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP = 0 \\cdot 0 + 0 = 0}. \\qquad\\qquad\\qquad\\qquad\\qquad \\ $$ Since \\(\\mathtt{zkPC = 1}\\), the next value of the Program Counter (according to Eqn 4*) must therefore be,  $$ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big) = (1+1) + 0 \\cdot \\big( addr\u2212(1+1) \\big) = 2}. $$</p> <p>Here is the execution trace thus far;</p>  Table 8: The first 2 steps of the execution trace  \\[ \\small \\begin{array}{|l|c|} \\hline  \\texttt{step} &amp; \\bf{instructions} \\\\ \\hline \\quad\\texttt{0} &amp; \\mathtt{${getAFreeInput()} =&gt; A}\\text{ }\\\\ \\hline \\quad\\texttt{1} &amp; \\mathtt{-3 =&gt; B}\\text{ }\\qquad\\qquad\\qquad\\text{ }\\text{ } \\\\ \\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{CONST} &amp; \\mathtt{offset} &amp; \\mathtt{JMP} &amp; \\mathtt{JMPZ} &amp; \\mathtt{setB} &amp; \\mathtt{setA} &amp; \\mathtt{inFREE} &amp; \\mathtt{inB} &amp; \\mathtt{inA} &amp; \\mathtt{zkPC} &amp; \\mathtt{zkPC'} \\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1}\\\\\\hline \\ \\mathtt{-3} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{2}\\\\\\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{op} &amp; \\mathtt{isZero} &amp; \\mathtt{doJMP} \\\\\\hline \\text{ }\\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{0} \\\\\\hline \\mathtt{-3} &amp;\\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{FREE} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} &amp; \\mathtt{invOp}\\\\\\hline \\quad\\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{0\\ } &amp; \\mathtt{3^{-1}}\\\\\\hline \\quad\\mathtt{0} &amp;\\mathtt{3} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{(-3)^{-1}}\\\\\\hline \\end{array} \\] <p>Step 2:  \"\\(\\mathtt{ :ADD}\\)\"</p> <p>Here the sum of the registry values \\(\\mathtt{A = 3}\\) and \\(\\mathtt{B = -3}\\) is computed, and the result is moved into the registry \\(\\mathtt{A}\\). That is, \\(\\mathtt{A' = 3 + (-3) = 0}\\)  and  \\(\\mathtt{setA = 1}\\). Also, \\(\\mathtt{inA = 1}\\) , \\(\\mathtt{inB = 1}\\) and \\(\\mathtt{inFREE = 0}\\).</p> <p>These values yield the following value of \\(\\mathtt{op}\\), $$ \\mathtt{op\\ =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST\\ =\\ 1 \\cdot 3\\ +\\ 1 \\cdot (-3)\\ +\\ 0 \\cdot FREE\\ +\\ 0\\  =\\ 0}. $$ So, \\(\\mathtt{invOp}\\) is set to a randomly chosen non-zero \\(\\mathtt{\\alpha}\\) in \\(\\mathbb{F}_p\\) , used to pass the identities related to \\(\\texttt{isZero}\\).</p> <p>And, \\(\\mathtt{isZero\\ := (1 \u2212 op \\cdot invOp) = \\big(1 \u2212 0\\cdot \\alpha \\big)\\ =\\ 1}\\).</p> <p>Note that there are no jumps in the instruction, so \\(\\mathtt{JMP = 0}\\) and \\(\\mathtt{JMPZ = 0}\\). And therefore \\(\\mathtt{zkPC\u2032 = zkPC + 1}\\).</p> <p>In order to verify that \\(\\mathtt{zkPC\u2032 = zkPC + 1 = 2 + 1 = 3}\\), we use the constraints given as Eqn 4* above.</p> <p>Firstly, check \\(\\mathtt{doJMP}\\) as follows, $$ \\mathtt{doJMP\\ :=\\ JPMZ \\cdot isZero + JMP\\ = 0 \\cdot 1\\ +\\ 0\\ =\\ 0}. \\qquad\\qquad\\qquad\\qquad\\qquad \\ $$ Then, $$ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big) = (2+1)\\ +\\ 0 \\cdot \\big( addr - (2+1)\\big)\\ =\\ 3}. $$ The Program Counter therefore moves to the subsequent line of instruction. That is, the next instruction to be executed must the one in \\(\\texttt{line}\\) \\(\\texttt{3}\\) of the Assembly code.</p> <p>Step 3:  \"\\(\\mathtt{ A \\quad :JMPZ(finalWait)}\\)\"</p> <p>According this instruction, the executor has to jump on condition that \\(\\texttt{A}\\) is \\(\\mathtt{0}\\), otherwise there is no jump. The polynomials immediately involved in this instruction are \\(\\mathtt{inA}\\) and \\(\\mathtt{JMPZ}\\). Therefore, \\(\\mathtt{inA = 1}\\) and \\(\\mathtt{JMPZ = 1}\\).</p> <p>As mentioned above, the implicit address label \"\\(\\mathtt{finalWait}\\)\" is computed by the Assembly compiler, and in this example, that address is \\(\\mathtt{line}\\) \\(\\mathtt{5}\\). That is, \\(\\mathtt{offset = 5}\\). It follows that \\(\\mathtt{zkPC\u2032 = 5}\\).</p> <p>Note that, \\(\\mathtt{inB = 0}\\) , \\(\\mathtt{inFREE = 0}\\) and \\(\\mathtt{CONST = 0}\\). Therefore,  $$ \\mathtt{op\\ =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST\\ =\\ 1 \\cdot 0\\ +\\ 0 \\cdot (-3)\\ +\\ 0 \\cdot FREE\\ +\\ 0\\  =\\ 0}. $$ Consequently,  \\(\\mathtt{isZero\\ := (1 \u2212 op \\cdot invOp) = \\big(1 \u2212 0 \\big)\\ =\\ 1}\\).</p> <p>Since there are no unconditional jumps, \\(\\mathtt{JMP = 0}\\). We use Eqn 4* to check whether \\(\\mathtt{zkPC\u2032 = 5}\\). Note that,</p> \\[ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP = 1 \\cdot 1 + 0 = 1}. \\qquad\\qquad\\qquad\\qquad\\qquad \\\\ \\] <p>The next value of the Program Counter, according to Eqn 4*, is</p> \\[ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big)\\ =\\ (3+1)\\ +\\ 1 \\cdot \\big(5\u2212(3+1)\\big)\\ =\\ 4 + (5-4)\\ =\\ 5.} \\] <p>Step 4:  \"\\(\\mathtt{\\{beforeLast()\\}\\quad:JMPZ(finalWait)}\\)\"</p> <p>The \\(\\texttt{beforeLast()}\\) function, which keeps track of the number of steps being executed, reads the current step-number as a free input. Since the execution trace is currently at step \\(\\mathtt{4}\\) and not \\(\\mathtt{6}\\), then the executor returns a zero. And thus, \\(\\mathtt{inFREE = 1}\\) and \\(\\mathtt{JMPZ = 1}\\) but \\(\\mathtt{inA = 0}\\), \\(\\mathtt{inB =0}\\), \\(\\mathtt{FREE = 0}\\) and \\(\\mathtt{CONST = 0}\\). Consequently,  $$ \\mathtt{op\\ =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST\\ =\\ 0 \\cdot A\\ +\\ 0 \\cdot B\\ +\\ 1 \\cdot 0\\ +\\ 0\\  =\\ 0}. $$ Therefore \\(\\mathtt{isZero \\ := (1 \u2212 op \\cdot invOp)\\ = (1 \u2212 0 \\cdot \\alpha) = 1}\\). Hence according to \\(\\texttt{JMPZ(finalWait)}\\), a jump is executed. This means the executor must jump to the \\(\\mathtt{offset = 5}\\) address, as computed by the Assembly compiler. It follows that \\(\\mathtt{zkPC\u2032}\\) must be \\(\\mathtt{5}\\).</p> <p>Let us use Eqn 4* to check if indeed \\(\\mathtt{zkPC\u2032 = 5}\\). We first note that, there are no unconditional jumps, so \\(\\mathtt{JMP = 0}\\). And, </p> \\[ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP = 1 \\cdot 1 + 0 = 1}. \\qquad\\qquad\\qquad\\qquad\\qquad \\\\ \\] <p>The next value of the Program Counter is given by,</p> \\[ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big)\\ =\\ (5+1)\\ +\\ 1 \\cdot \\big(5\u2212(5+1)\\big)\\ =\\ 6 + (5-6)\\ =\\ 5.} \\] <p>The execution trace is currently as follows,</p>  Table 9: The first 5 steps of the execution trace  \\[ \\small \\begin{array}{|l|c|} \\hline  \\texttt{step} &amp; \\bf{instructions} \\\\ \\hline \\quad\\texttt{0} &amp; \\mathtt{${getAFreeInput()} =&gt; A}\\quad\\qquad\\qquad\\\\ \\hline \\quad\\texttt{1} &amp; \\mathtt{-3 =&gt; B}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{2} &amp; \\mathtt{:ADD}\\qquad\\quad\\qquad\\qquad\\qquad\\qquad\\qquad\\ \\\\ \\hline \\quad\\texttt{3} &amp; \\mathtt{A \\qquad :JMPZ(finalWait)}\\qquad\\qquad \\\\ \\hline \\quad\\texttt{4} &amp; \\mathtt{\\{beforeLast()\\}\\quad:JMPZ(finalWait)} \\\\ \\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{CONST} &amp; \\mathtt{offset} &amp; \\mathtt{JMP} &amp; \\mathtt{JMPZ} &amp; \\mathtt{setB} &amp; \\mathtt{setA} &amp; \\mathtt{inFREE} &amp; \\mathtt{inB} &amp; \\mathtt{inA} &amp; \\mathtt{zkPC} &amp; \\mathtt{zkPC'} \\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1}\\\\\\hline \\ \\mathtt{-3} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{2}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} &amp; \\mathtt{2} &amp; \\mathtt{3}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{3} &amp; \\mathtt{5}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{5}\\\\\\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{op} &amp; \\mathtt{isZero} &amp; \\mathtt{doJMP} \\\\\\hline \\text{ }\\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{0} \\\\\\hline \\mathtt{-3} &amp;\\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\text{ }\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} \\\\\\hline \\text{ }\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1}\\\\\\hline \\text{ }\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} \\\\\\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{FREE} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} &amp; \\mathtt{invOp}\\\\\\hline \\quad\\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{0\\ } &amp; \\mathtt{3^{-1}}\\\\\\hline \\quad\\mathtt{0} &amp;\\mathtt{3} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{(-3)^{-1}}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ } &amp; \\mathtt{\\alpha}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ } &amp; \\mathtt{\\alpha}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3} &amp; \\mathtt{\\alpha}\\\\\\hline \\end{array} \\hspace{0.02cm} \\] <p>Step 5:  \"\\(\\mathtt{\\{beforeLast()\\}\\quad:JMPZ(finalWait)}\\)\"</p> <p>As seen in Step 4, the \\(\\texttt{beforeLast()}\\) function checks if the execution trace is currently at Step 6. Since the current step is \\(\\mathtt{5}\\) and not \\(\\mathtt{6}\\), the executor returns a zero.  </p> <p>Similarly, \\(\\mathtt{inFREE = 1}\\) and \\(\\mathtt{JMPZ = 1}\\) but \\(\\mathtt{inA = 0}\\), \\(\\mathtt{inB =0}\\), \\(\\mathtt{FREE = 0}\\) and \\(\\mathtt{CONST = 0}\\). As a result, $$ \\mathtt{op\\ =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST\\ =\\ 0 \\cdot A\\ +\\ 0 \\cdot B\\ +\\ 1 \\cdot 0\\ +\\ 0\\  =\\ 0}, $$ which means  \\(\\mathtt{FREE = 0}\\) and \\(\\mathtt{isZero \\ := (1 \u2212 op \\cdot invOp)\\ = (1 \u2212 0 \\cdot \\alpha) = 1}\\). So, again \\(\\texttt{JMPZ(finalWait)}\\) gets executed. </p> <p>The absence of unconditional jumps means \\(\\mathtt{JMP = 0}\\), while \\(\\mathtt{JMPZ = 1}\\). Since \\(\\mathtt{offset = 5}\\), the Program Counter, \\(\\mathtt{zkPC\u2032}\\), must in the next step be \\(\\mathtt{5}\\).</p> <p>We verify this by first checking  $$ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP = 1 \\cdot 1 + 0 = 1}, \\qquad\\qquad\\qquad\\qquad\\qquad \\ $$ and use Eqn 4*, $$ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big)\\ =\\ (5+1)\\ +\\ 1 \\cdot \\big(5\u2212(5+1)\\big)\\ =\\ 6 + (5-6)\\ =\\ 5.} $$</p> <p>Step 6:  \"\\(\\mathtt{\\{beforeLast()\\}\\quad:JMPZ(finalWait)}\\)\"</p> <p>In this case, the current step is the last but one step. That is, the \\(\\texttt{beforeLast()}\\) function holds true, and hence the executor must return a \\(\\mathtt{1}\\). So, \\(\\mathtt{inFREE = 1}\\) and \\(\\mathtt{JMPZ = 1}\\) while \\(\\mathtt{inA = 0}\\), \\(\\mathtt{inB =0}\\) and \\(\\mathtt{CONST = 0}\\). Then, $$ \\mathtt{op\\ =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST\\ =\\ 0 \\cdot A\\ +\\ 0 \\cdot B\\ +\\ 1 \\cdot 1\\ +\\ 0\\  =\\ 1}. $$ This means  \\(\\mathtt{FREE = 1}\\) and \\(\\mathtt{isZero \\ := (1 \u2212 op \\cdot invOp)\\ = (1 \u2212 1 \\cdot 1) = 0}\\). And, this time \\(\\texttt{JMPZ(finalWait)}\\) is not executed, implying the next Program Counter, \\(\\mathtt{zkPC\u2032 = zkPC + 1}\\). </p> <p>Since there are no jumps in this step, \\(\\mathtt{JMP = 0}\\) and \\(\\mathtt{JMPZ = 0}\\), yielding  $$ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP = 0 \\cdot 1 + 0 = 0}, \\ $$ and with a quick verification using Eqn 4*, we obtain $$ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big)\\ =\\ (5+1)\\ +\\ 0 \\cdot \\big(addr \u2212(5+1)\\big)\\ =\\ 6.} $$</p> <p>Step 7:  \"\\(\\mathtt{0 =&gt; A,B\\quad\\ :JMP(start)}\\)\"</p> <p>The aim with this instruction is to complete the execution trace such that it is of the correct size (which is \\(\\mathtt{8}\\) in this example). </p> <p>It ends the execution by setting \\(\\texttt{A}\\) and \\(\\texttt{B}\\) to zero, and jumps to \\(\\mathtt{start}\\), which is line \\(\\mathtt{0}\\). And thus, \\(\\mathtt{zkPC'}\\) must be \\(\\mathtt{0}\\). Hence, \\(\\mathtt{setA = 1}\\), \\(\\mathtt{setB = 1}\\) and \\(\\mathtt{JMP = 1}\\) but \\(\\mathtt{inFREE = 0}\\), \\(\\mathtt{inA =0}\\), \\(\\mathtt{inB =0}\\) and \\(\\mathtt{CONST = 0}\\). Consequently,  $$ \\mathtt{op\\ =\\ inA \\cdot A\\ +\\ inB \\cdot B\\ +\\ inFREE \\cdot FREE\\ +\\ CONST\\ =\\ 0 \\cdot 0\\ +\\ 0 \\cdot (-3)\\ +\\ 0 \\cdot 1\\ +\\ 0\\  =\\ 0}. $$ Therefore \\(\\mathtt{isZero \\ := (1 \u2212 op \\cdot invOp)\\ = (1 \u2212 0 \\cdot \\alpha) = 1}\\). </p> <p>There are no conditional jumps, so \\(\\mathtt{JMPZ = 0}\\). Then, as a consequence of this,  $$ \\mathtt{doJMP := JPMZ \\cdot isZero + JMP = 0 \\cdot 1 + 1 = 1}. \\ $$ The constraint in Eqn 4* verifies the next value of the Program Counter as follows, $$ \\mathtt{zkPC\u2032 = (zkPC+1)+doJMP \\cdot \\big(addr\u2212(zkPC+1)\\big)\\ =\\ (6+1)\\ +\\ 1 \\cdot \\big(0 \u2212(6+1)\\big)\\ =\\ 0.} $$</p> <p>This instruction, as the last step the Assembly program, achieves two things; Firstly, the program ends correctly with the specified size of the execution trace. Secondly, resetting \\(\\texttt{A}\\), \\(\\texttt{B}\\) and \\(\\texttt{zkPC}\\) to zero causes the execution trace to attain cyclicity.</p> <p>See the complete execution trace below,</p>  Table 10: The entire execution trace for an Assembly with JMP and JMPZ   \\[ \\small \\begin{array}{|l|c|} \\hline  \\texttt{step} &amp; \\bf{instructions} \\\\ \\hline \\quad\\texttt{0} &amp; \\mathtt{${getAFreeInput()} =&gt; A}\\quad\\qquad\\qquad\\\\ \\hline \\quad\\texttt{1} &amp; \\mathtt{-3 =&gt; B}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\text{ }\\text{ } \\\\ \\hline \\quad\\texttt{2} &amp; \\mathtt{:ADD}\\qquad\\quad\\qquad\\qquad\\qquad\\qquad\\qquad\\ \\\\ \\hline \\quad\\texttt{3} &amp; \\mathtt{A \\qquad :JMPZ(finalWait)}\\qquad\\qquad \\\\ \\hline \\quad\\texttt{4} &amp; \\mathtt{\\{beforeLast()\\}\\quad:JMPZ(finalWait)} \\\\ \\hline \\quad\\texttt{5} &amp; \\mathtt{\\{beforeLast()\\}\\quad:JMPZ(finalWait)}\\\\ \\hline \\quad\\texttt{6} &amp; \\mathtt{\\{beforeLast()\\}\\quad:JMPZ(finalWait)}\\\\ \\hline \\quad\\texttt{7} &amp; \\mathtt{0 =&gt; A,B \\quad\\qquad\\ \\ :JMP(start)}\\qquad \\\\ \\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{CONST} &amp; \\mathtt{offset} &amp; \\mathtt{JMP} &amp; \\mathtt{JMPZ} &amp; \\mathtt{setB} &amp; \\mathtt{setA} &amp; \\mathtt{inFREE} &amp; \\mathtt{inB} &amp; \\mathtt{inA} &amp; \\mathtt{zkPC} &amp; \\mathtt{zkPC'} \\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1}\\\\\\hline \\ \\mathtt{-3} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{2}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} &amp; \\mathtt{2} &amp; \\mathtt{3}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{3} &amp; \\mathtt{5}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{5}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{5}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{5} &amp; \\mathtt{6}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{6} &amp; \\mathtt{0}\\\\\\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{op} &amp; \\mathtt{isZero} &amp; \\mathtt{doJMP} \\\\\\hline \\text{ }\\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{0} \\\\\\hline \\mathtt{-3} &amp;\\mathtt{0} &amp; \\mathtt{0}\\\\\\hline \\text{ }\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{0} \\\\\\hline \\text{ }\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1}\\\\\\hline \\text{ }\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1} \\\\\\hline \\text{ }\\mathtt{0} &amp;\\mathtt{1} &amp; \\mathtt{1}\\\\\\hline \\text{ }\\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} \\\\\\hline \\text{ }\\mathtt{0} &amp; \\mathtt{1} &amp; \\mathtt{1}\\\\\\hline \\end{array} \\hspace{0.02cm} \\begin{array}{|l|c|c|c|c|c|c|c|}\\hline \\mathtt{FREE} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} &amp; \\mathtt{invOp}\\\\\\hline \\quad\\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{0\\ } &amp; \\mathtt{3^{-1}}\\\\\\hline \\quad\\mathtt{0} &amp;\\mathtt{3} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{(-3)^{-1}}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{3} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ } &amp; \\mathtt{\\alpha}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ } &amp; \\mathtt{\\alpha}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3} &amp; \\mathtt{\\alpha}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ } &amp; \\mathtt{\\alpha}\\\\\\hline \\quad\\mathtt{1} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{-3\\ } &amp; \\mathtt{1}\\\\\\hline \\quad\\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{-3\\ } &amp; \\mathtt{0} &amp; \\mathtt{\\alpha}\\\\\\hline \\end{array} \\hspace{0.02cm} \\] <p>In conclusion, our Assembly program uses jumps to create a loop in its execution. That is, at the right point of the execution, when the registry values of interest have been attained, the executor retains these values until the execution trace is in the last but one row. This way, the result of the computations can be reflected in the last position of the registry \\(\\mathtt{A}\\), in the last row of the execution trace, which is the output of the mFibonacci state machine.</p> <p>Note that in cases where the jumps are such that \\(\\mathtt{offset}\\) is one of the previous addresses, the length of the execution trace can turn out to be much bigger than the final value of the Program Counter. i.e., \\(\\mathtt{zkPC \\leq 2^N - 1}\\) where \\(\\mathtt{2^N -1}\\) is the degree of the state machine polynomials.  </p>"},{"location":"zkEVM/Basic-Concepts/A-Generic-State-Machine/#publics-placed-at-known-steps","title":"Publics Placed at Known Steps","text":"<p>Regarding the \\(\\texttt{publics}\\), it is best to place these at specific and known steps. </p> <p>Notice that, in the above example, the final loop added to Assembly program repeats the values of the registries \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\) until they are reset to Step \\(\\mathtt{0}\\).</p> <p>So if, for example, the execution result or state machine output is the state of registry \\(\\mathtt{A}\\) at the end of all the instructions, we will find this value at \\(\\mathtt{A(N-1)}\\).</p> <p>This is important for verification purposes, because then, we need only add the proper boundary constraint in the PIL, referencing a specific step in the execution trace.   </p>"},{"location":"zkEVM/Basic-Concepts/Intro-zkProver%27s-Design-Approach/","title":"Introduction","text":"<p>The overall design of the Polygon zkEVM follows the state machine model, and thus emulates the Ethereum Virtual Machine (EVM), with the aim to provide the same user experience as in Ethereum. In addition to enabling payments and transfers of ERC20 tokens, users can now run Ethereum smart contracts on it.</p> <p>The rollup strategy is to develop a zkProver that takes a batch of many transactions, proves their validity, and only publishes a minimally-sized validity proof for verification. This helps to reduce transaction finality time and saves gas costs for Ethereum users. </p> <p>However, the zkEVM is not just a rollup but a zero-knowledge rollup. Its design takes advantage of the best known techniques in the ZK folklore, while introducing novel ZK tools. For instance, the Polynomial Identity Language (PIL), which is pivotal in enabling the zkProver produce verifiable proofs.</p> <p>The state machine model is best suited for iterative deterministic computations, which are a common place in the Ethereum blockchain. This model is preferred over the arithmetic circuit model, which would need loops to be unrolled, and hence resulting in undesirably larger circuits.</p>"},{"location":"zkEVM/Basic-Concepts/Intro-zkProver%27s-Design-Approach/#the-basic-design-approach","title":"The Basic Design Approach","text":"<p>The general approach to designing the zkProver so as to realise a proof system based on state machines is as follows,</p> <ul> <li> <p>Firstly, turn the required deterministic computation into a state machine computation.</p> </li> <li> <p>Secondly, describe state transitions in terms of algebraic constraints. These are like rules that every state transition must satisfy.</p> </li> <li> <p>Thirdly, use interpolation of state values to build polynomials that describe the state machine.</p> </li> <li> <p>Fourthly, define polynomial identities that all state values must satisfy.</p> </li> <li> <p>Fifthly, a specially designed cryptographic proving system (e.g. a STARK, a SNARK, or a combination of the two) is used to produce a verifiable proof, which anyone can verify.</p> </li> </ul> <p>The first four steps are commonly referred to as Arithmetization. An arithmetization can be seen, in the case of STARKs, as the Algebraic Intermediate Representation (AIR), while in the case of SNARKs (which use arithmetic circuits) it can be seen as the R1CS system.</p> <p>Also, since the context of the zkProver's deployment is that of a public-key cryptographic system, a commitment scheme is required. In particular, the underpinnings of the zkProver's capability to prove correctness of computations and allow any independent party verify the validity proofs is a polynomial commitment scheme.</p> <p></p>  Figure 1 : General Approach to the zkProver's Design"},{"location":"zkEVM/Basic-Concepts/Intro-zkProver%27s-Design-Approach/#state-machine-basics","title":"State Machine Basics","text":"<p>A state machine is composed of registries that carry numerical values. These values are often called, registry values. At a given point in time, registry values constitute what is called a state of the state machine.</p> <p>A state machine is so called, because it is a machine whose behaviour is described in terms of its states and the rules that determine how one state transitions to another.</p> <p>Hence, the next concept pertinent to state machines, and arithmetization of computations, is that of a clock. A state transition in a state machine occurs at each tick of the clock. A clock thus controls registries of a state machine, determining the timing and order of execution.</p> <p>A computation is deterministic if, given a particular input, it will always produce the same output. This type of computations are consequently verifiable. The zkProver executes these deterministic computations in order to produce verifiable proofs of correctness.</p> <p>There are three types of values required to enable verifiability of these proofs;</p> <p>(a) Computation constants, which are constants specifically related to the computation being carried out.</p> <p>(b) Publics, \\(\\mathbf{x}\\), which are variables; values that can be changed to generate different proofs for the same computation, but are public since they are known by both the prover and the verifier.</p> <p>(c) Privates, \\(\\large{\\mathtt{w}}\\), which are private values, also known as (a.k.a) \u201dthe witness\u201d. These values are only known by the prover.</p> <p></p>  Figure 2: Simplified State Machine in terms of indexed registries  <p>The execution trace of a state machine is the record of all its registry values, commonly represented in table form, where the rows represent the states, and the columns depict its distinct variables (or polynomials). Each column records the values of a particular registry across time, while each row represents the state of the entire machine at a given point in time.</p> <p>Each state machine has initial state values. Figure 3 below depicts the execution trace of a state machine with \\(\\mathtt{K}\\) variables and \\(\\mathtt{T+1}\\) states, where typically, \\(\\mathtt{T+1}\\) is some power of \\(2\\). After reaching the (\\(\\mathtt{T + 1}\\))-th row the state machine gets initialized to the initial state. It loops back to its initial state, hence achieving cyclicity required for iterative computations. Generally, every state machine has a cycle of length \\(\\mathtt{2^t}\\) for some integer \\(\\mathtt{t}\\).</p> <p></p>  Figure 3: Computation Trace of a State Machine  <p>Arithmetic constraints are used to enforce correctness of the computation. These constraints are referred to as arithmetic because they are equations containing arithmetic operations such as addition or multiplication. They define how values of a particular state and its previous state are related.</p> <p>The process of efficiently proving a computation involves interpolating certain values into polynomials, and subsequently forming polynomial equations, a.k.a. polynomial identities.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/","title":"Multiplicative Fibonacci SM","text":"<p>In this document we breakdown the complexities of the Polygon zkEVM's design in terms of a simplified example, a multiplicative Fibonacci state machine. The aim is to illustrate, in a generic sense, how the state machine approach has been implemented to realise the Polygon zkEVM.</p> <p>Consider a proof/verification scheme, using an arbitrary Polynomial Commitment Scheme, where users have to prove knowledge of the N-th member of a multiplicative Fibonacci Series, for specific initial conditions.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#the-multiplicative-fibonacci-series","title":"The Multiplicative Fibonacci Series","text":"<p>The multiplicative Fibonacci Series (or simply mFibonacci Series), denoted by  \\(\\mathbf{a_0, a_1, a_2, \\dots , a_n}\\), has the property that the product of every two consecutive members \\(\\mathbf{a_{i-1}}\\) and \\(\\mathbf{a_i}\\) gives the value of the next member \\(\\mathbf{a_{i+1}}\\). That is, \\(\\mathbf{ a_{i+1} = a_{i-1}\\cdot a_i }\\). And, the initial values are specified as \\(\\mathbf{a_0} = 2\\) and \\(\\mathbf{a_1} = 1\\).</p> <p>Here are the first ten members of the mFibonacci Series,</p> <p>$$ \\mathbf{ \\ \\ 2,\\ \\ 1,\\ \\ 2,\\ \\ 2,\\ \\ 4,\\ \\ 8,\\ \\ 32,\\ \\ 256,\\ \\ 8192,\\ \\ 2097152,\\ \\ \\dots } $$ As a trivial example, the challenge may be: Prove knowledge of the initial values that produced \\(\\mathbf{a_{10} = 17179869184}\\), the eleventh member of the mFibonacci Series, without revealing the initial values. </p> <p>The task therefore, is to first build a state machine that would enable anyone to prove knowledge of the initial values \\(\\mathbf{a_0}\\) and \\(\\mathbf{a_1}\\) that yields a specific N-th member of the mFibonacci Series.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#the-mfibonacci-state-machine","title":"The mFibonacci State Machine","text":"<p>Consider a state machine with registries \\(\\mathbf{A} = [A_0, A_1, \\dots , A_T ]\\) and \\(\\mathbf{B} = [B_0, B_ 1, \\dots , B_T]\\), so that the i-th state is the pair \\(\\big( A_i , B_i \\big)\\).  Such a state machine is an mFibonacci state machine if indeed the registry values conform to the format of the mFibonnacci Series. See Figure 4 below, for an mFibonacci state machine with the initial conditions, \\(A_0 = 2\\) and \\(B_0 = 1\\).</p> <p></p>  Figure 4: mFibonacci SM with two registries  <p>The state transitions from \\(\\mathtt{S} = \\big( A_i , B_i \\big)\\) to \\(\\mathtt{S}' = \\big( A_{i+1} , B_{i+1} \\big)\\) conform to the following constraints, $$ { A_{i+1} = B_i \\quad\\text{ }\\text{ }\\text{ }  } \\ { B_{i+1} = A_i \\cdot B_i } $$ The aim here is to; express the evolution of the execution trace in terms of polynomials, build corresponding polynomial identities, and ultimately construct a ZK proof/verification scheme for our mFibonacci state machine.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#building-the-polynomial-identities","title":"Building The Polynomial Identities","text":"<p>The polynomials that represent the two registries are taken from the set of polynomials \\(\\mathbb{F}_p [X]\\), where the coefficients are elements of a prime field \\(\\mathbb{F}_p\\) and \\(p = 2^{64} \u2212 2^{32} + 1\\). The polynomials are evaluated over the subgroup \\({\\mathcal{H}} = \\{ \\omega, \\omega^2, \\omega^3, \\dots , \\omega^7, \\omega^8 = 1 = \\omega^0 \\} = \\langle \\omega \\rangle \\subseteq \\mathbb{F}_p^*\\) of order \\(8\\).</p> <p>Define two polynomials \\(P(X)\\) and \\(Q(X)\\) such that</p> \\[ P(\\omega^i) = A[i] \\ \\ \\iff  \\ \\ A = [2,1,2,2,4,8,32,256]\\quad\\text{ }\\text{ } \\] \\[ Q(\\omega^i) = B[i]  \\ \\ \\iff \\ \\  B = [1,2,2,4,8,32,256,8192] \\] <p>Since every \\(X\\) in \\({\\mathcal{H}}\\) is of the form \\(X = \\omega^i\\) for some \\(i\\), we have $$ \\begin{aligned} P(X\\cdot \\omega) &amp;=  P(\\omega^{i + 1})  =  A_{i+1}, \\ Q(X\\cdot \\omega) &amp;= Q(\\omega^{i+1})  =  B_{i+1}. \\end{aligned} $$ The previously stated constraints, imposed on the state transitions \\(\\mathtt{S} \\to \\mathtt{S}'\\) of the mFibonacci state machine, translate into the following polynomial identities, $$ P(X\\cdot \\omega) = \\bigg\\lvert_{\\mathcal{H}}\\  Q(X),\\qquad\\text{ }\\text{ }\\text{ }\\text{ }  \\ Q(X\\cdot \\omega) = \\bigg\\lvert_{\\mathcal{H}}\\  P(X) \\cdot Q(X) $$ If these polynomial identities should accurately express the two registries, then every state transition of the mFibonacci SM must satisfy them.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#non-cyclicity-of-the-mfibonacci-sm","title":"Non-cyclicity Of The mFibonacci SM","text":"<p>Note that the definition of \\({\\mathcal{H}}\\) does not restrict the values of \\(i\\) to be less than \\(8\\). Even if we set \\(i = 27\\), the element  \\(\\omega^{27}\\)  is in \\({\\mathcal{H}}\\) because \\(\\ \\omega^{27} = w^8 \\cdot \\omega^8 \\cdot \\omega^8 \\cdot \\omega^3 = 1 \\cdot 1 \\cdot 1 \\cdot \\omega^3 = \\omega^3\\). However, the unrestricted value of \\(i\\), which implies there is no bound on the number of state changes (i.e., on the clock), presents problems with the above polynomial identities.</p> <p>Let's test if the polynomial identities hold true for all permissible values of \\(i\\). Let \\(X = \\omega^7\\) and refer to the registry values given in Figure 4.</p> <ul> <li>For the first identity we get, </li> </ul> \\[ P(X\\cdot \\omega) = P(\\omega^7 \\cdot \\omega) = P(\\omega^8) = P(\\omega^0) = A_0 = 2\\ \\ \\text{ }\\text{ }\\\\ \\] \\[ \\text{ but }\\ Q(X) = Q(\\omega^7) = 8192 \\not= 2 \\qquad\\qquad\\qquad\\qquad\\quad \\] <ul> <li>Similarly, for the second identity, we get, </li> </ul> \\[ Q(X\\cdot \\omega) = Q(\\omega^7 \\cdot \\omega) = Q(\\omega^8) = Q(\\omega^0) = B_0 = 1\\ \\ \\text{ but } \\qquad \\\\ \\] <p>$$ P(X)\\cdot Q(X) = P(\\omega^7)\\cdot Q(\\omega^7) = 256\\cdot 8192 = 2097152 \\not= 1 \\quad $$ Clearly, the polynomial identities are not aligned with the registry values of the mFibonacci SM. The reason for this disparity is that, whereas \\(H\\) is cyclic, the polynomial identities are not.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#introducing-cyclicity-into-the-mfibonacci-sm","title":"Introducing Cyclicity Into The mFibonacci SM","text":"<p>In order to inject some cyclicity into the the mFibonacci SM, we add a third registry \\(\\mathbf{C} = [C_1, C_2, \\dots , C_T]\\) and set the registry values to \\(\\mathbf{C} = [0, 0, \\dots , 0, 1]\\). So the mFibonacci SM is now as depicted in Figure 5 below.</p> <p></p>  Figure 5: mFibonacci SM with three registries  <p>The corresponding polynomial \\(R(x)\\) is defined as follows, $$ R(\\omega^i) = C[i] $$ That is,  $$ \\begin{aligned} R(\\omega^i) = C[i] = 1, \\text{ if } \\ \\ (i+1)\\mod 8 = 0 \\ \\end{aligned} $$ $$ R(\\omega^i) = C[i] = 0, \\text{ otherwise} $$</p> <p>The polynomial \\(R(x)\\) is incorporated into the previous polynomial identities as follows, $$ P(X \\cdot \\omega) = \\bigg\\lvert_{\\mathcal{H}}\\ \\   Q(X) \\cdot \\big( 1 \u2212 R(X) \\big) + R(X)\\cdot  A_0  \\quad\\quad\\text{ }\\text{ }\\text{ } \\ $$ $$ Q(X\\cdot \\omega) = \\bigg\\lvert_{\\mathcal{H}}\\ \\  (1 \u2212 R(X)) \\cdot P(X)\\cdot Q(X) + R(X)\\cdot B_0 $$</p> <p>Note that, for all the states where the new registry \\(C[i] = 0\\), these new identities coincide with the previous ones (where only registries \\(A\\) and \\(B\\) were used).</p> <p>These polynomial identities can be rewritten as, $$ \\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] + R(X)\\cdot \\big[ P(X \\cdot \\omega) \u2212 A_0 \\big] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\quad\\text{ }\\text{ }\\text{ } $$ $$ (1 \u2212 R(X)) \u00b7 [Q(X\u03c9) \u2212 (P(X) \u00b7 Q(X))] + R(X)\\cdot [Q(X\u03c9) \u2212 B_0] = \\bigg\\lvert_{\\mathcal{H}}\\ 0 $$</p> <p>Let's check if these identities are cyclic. Again, let \\(X = \\omega^7\\) and use the registry values given in Figure 5.</p> <ul> <li>For the first identity, we observe that,</li> </ul> \\[ \\begin{aligned} \\text{LHS} = P(X\\cdot \\omega) = P(\\omega^7 \\cdot \\omega) = P(\\omega^8) = P(\\omega^0) = A_0 = 2\\ \\ \\text{ and } \\\\ \\end{aligned} \\] \\[ \\text{RHS} =  Q(X)\\cdot \\big( 1 \u2212 R(X) \\big) + R(X)\\cdot A_0\\ =\\ Q(\\omega^7)\\cdot \\big( 1 \u2212 1 \\big) + 1\\cdot 2 = 2 = \\text{LHS} \\] <ul> <li>Similarly, for the second identity, we observe that, </li> </ul> \\[ \\begin{aligned} \\text{LHS} &amp;= Q(X\\cdot \\omega) = Q(\\omega^7 \\cdot \\omega) = Q(\\omega^8) = Q(\\omega^0) = B_0 = 1 \\ \\ \\text{ and } \\text{ and } \\\\ \\text{RHS} &amp;= (1 \u2212 R(X)) \\cdot P(X)\\cdot Q(X) + R(X)\\cdot B_0 \\\\ &amp;= (1 \u2212 1) \\cdot P(\\omega^7)\\cdot Q(\\omega^7) + 1\\cdot 1 = 0 + 1 = \\text{LHS} \\end{aligned} \\] <p>These polynomial identities enforce correct state transitioning, and are therefore referred to as transition constraints. They apply to every pair of consecutive states. That is, every pair of consecutive rows in the execution trace of the SM.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#verifying-computations-of-the-mfibonacci-sm","title":"Verifying Computations Of The mFibonacci SM","text":"<p>In addition to transition constraints, are boundary constraints. A boundary constraint is a constraint that enforces that a polynomial has a certain value at a particular root of unity.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#varied-initial-conditions","title":"Varied Initial Conditions","text":"<p>Note that instead of being restricted to the given initial conditions \\(\\big( A_0 , B_0 \\big) = \\big( 2 , 1 \\big)\\), the mFibonacci state machine together with its polynomial identities can be adjusted to any initial conditions \\(\\big( A_0 , B_0 \\big)\\).</p> <p>For example, for \\(A_0 = 23\\) and \\(B_0 = 46\\), the constraints should be; $$ \\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] + R(X)\\cdot \\big[ P(X \\cdot \\omega) \u2212 23 \\big] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\quad\\text{ }\\text{ }\\text{ } $$ $$ (1 \u2212 R(X)) \u00b7 [Q(X\u03c9) \u2212 (P(X) \u00b7 Q(X))] + R(X)\\cdot [Q(X\u03c9) \u2212 46] = \\bigg\\lvert_{\\mathcal{H}}\\ 0 $$</p> <p>In the context of our mFibonacci SM, the verifier can set the initial conditions $\\big( A_0 , B_0 \\big) $ to values of his or her own choice, and generate the state machine while keeping \\(A_0\\) and \\(B_0\\) secret. The prover's task is therefore, to prove knowledge of \\(A_0\\) and \\(B_0\\) that led to a given N-th term of the mFibonacci Series.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#boundary-constraints","title":"Boundary Constraints","text":"<p>Boundary constraints apply to particular registry values, and are used to enforce that the correct initial state was applied.</p> <p>The idea here is to set up a specific boundary constraint, which the verifier can use to check that correct initial conditions were applied, when the prover was computing a particular N-th term of the mFibonacci Series. Yet, the verifier must not disclose any information about the secret values \\(A_0\\) and \\(B_0\\).</p> <p>Therefore, the first thing to do, is removing terms in the identities bearing the initial values \\(A_0\\) and \\(B_0\\). This means modifying our polynomial identities to the ones below, $$ \\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\qquad\\text{ }\\text{ }\\text{ } $$ $$ (1 \u2212 R(X)) \u00b7 [Q(X\\cdot \\omega) \u2212 (P(X) \u00b7 Q(X))] = \\bigg\\lvert_{\\mathcal{H}}\\ 0 $$</p> <p>Secondly, knowing that \\(A_0\\) and \\(B_0\\) yield the \\(k\\)-th term \\(A_{k-1} = P(\\omega^{k-1}) =: \\mathcal{K}\\), the verifier adds the boundary constraint, $$ P(\\omega^{k-1}) = \\mathcal{K} $$ In other words, the prover has to provide three polynomials \\(P(X)\\), \\(Q(X)\\), \\(P(X\\omega)\\) and \\(Q(X\\omega)\\) together with the correct \\(k\\)-th term. The verifier then tests if these polynomials conform to the above constraints. If all three constraints are satisfied, then the prover knows the correct initial values \\(A_0\\) and \\(B_0\\).</p> <p>This logic is valid simply because the computations carried out by the state machine are deterministic by nature.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#example-1-proof-elements-and-verification","title":"Example 1. (Proof Elements and Verification)","text":"<p>All computations are carried out in a field \\(\\mathbb{F}_p\\) , where \\(p = \\mathtt{2^{64}-2^{32}+1}\\), a Goldilocks-like prime number.</p> <p>Suppose the verifier knows that an mFibonacci Series starting with initial values, \\(A_0\\) and \\(B_0\\), yields \\(A_{\\mathtt{1023}} = \\mathtt{14\\ 823\\ 897\\ 298\\ 192\\ 278\\ 947}\\) as the value of the \\(\\mathtt{1024}\\)-th term. The verifier can challenge anyone to prove knowledge of the initial condition of the mFibonacci SM to provide three polynomials and the correct \\(\\mathtt{1024}\\)-th term. That is, the verifier uses the following constraints to verify the prover's submissions;  $$ \\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] = \\bigg\\lvert_H\\ 0\\qquad\\quad\\text{ }\\text{ }\\text{ } \\ $$ $$ \\big(1 \u2212 R(X)\\big) \u00b7 [Q(X\\cdot \\omega) \u2212 (P(X) \u00b7 Q(X))] = \\bigg\\lvert_H\\ 0\\text{ } \\ $$</p> \\[ \\big(P(\\omega^{\\mathtt{1023}}) - \\mathcal{K} \\big)\\cdot R(X) = 0\\quad\\text{ }\\text{ } \\] <p>Anyone who knows the three polynomials and the correct initial conditions, say \\(A_0 = 234\\) and \\(B_0 = 135\\), can simply run the mFibonacci SM code to compute \\(A_{\\mathtt{1023}} = P(\\omega^{\\mathtt{1023}})\\). See Figure 6 below for the .js code.</p> <p></p>  Figure 6: Code Example of the mFibonacci SM's Computation Trace"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#the-polynomial-commitment-scheme-setting","title":"The Polynomial Commitment Scheme Setting","text":"<p>The framework for the proof/verification system of our mFibonacci SM is a Polynomial Commitment Scheme. The mechanism for proving correctness of the computations carried out by the mFibonacci SM (or, any state machine in the zkEVM setting), is best described in terms of an interactive zero-knowledge proof system. One therefore thinks of the proof/verification system as an interaction of two parties, traditionally called the Verifier and the Prover.</p> <p>In practice though, the so-called Fiat-Shamir transformation is used to turn such interactive schemes into non-interactive ones.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#commitment-scheme-protocol-an-interactive-setting","title":"Commitment Scheme Protocol (An Interactive Setting)","text":"<p>In the case of our mFibonacci state machine, the Prover needs to commit to the polynomials \\(P(X)\\), \\(Q(X)\\) \\(P(X\\omega)\\) and \\(Q(X\\omega)\\), and the Verifier will request the Prover to evaluate these polynomials at randomly selected points (i.e., field elements).</p> <p>The general protocol, in an interactive setting, is as follows;</p> <ol> <li>The Prover commits to a polynomial or a number of polynomials, using a specified polynomial commitment scheme.</li> <li>The Verifier randomly selects one or more field elements, which she sends one at a time to the Prover as challenges. That is, the Verifier requests the Prover to provide evaluations (called openings) of the committed polynomials at these randomly selected field elements.</li> <li>This back and forth interaction can occur as many times as the number of openings the Verifier deems sufficient to guarantee soundness.  </li> <li>The Verifier uses relevant polynomial constraints to test veracity of the Prover's openings.</li> </ol> <p>If all the relevant constraints hold true, then the Verifier accepts that the Prover has knowledge of the correct polynomials \\(P(X)\\), \\(Q(X)\\), \\(P(X\\omega)\\) and \\(Q(X\\omega)\\).</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#properties-of-commitment-schemes","title":"Properties of Commitment Schemes","text":"<p>For all practical purposes, such the constructed proof/verification system needs to be secure. That is, it must have several cryptographic properties. The most crucial properties are; being hiding and binding, as well as soundness and completeness.</p> <p>(a) Binding means users are able to commit to values but once committed, it should be impossible for users to change or repudiate their committed values. The committed values are called commitments.</p> <p>(b) Hiding literally means users can commit to values without revealing the actual values, and it should be infeasible for anyone else to deduce the actual values.</p> <p>(c) Openness means, given a challenge \\(\\alpha\\) , the prover can generate a verifiable proof such that \\(P(\\alpha) = y\\).</p> <p>(c) Soundness has to do with whether it is infeasible for the adversarial prover to convince the verifier to accept invalid proofs (or commitments). A proof system is sound if the probability for the verifier to accept a false proof is less than a third, \\(\\Big( \\text{probability} &lt; \\dfrac{1}{3} \\Big)\\). In other words, the soundness property of a proof system requires that any proof created from a false witness should not be convincing to the verifier.</p> <p>(d) A proof system has completeness if every valid proof is convincing and acceptable to a verifier.</p> <p>Proof systems based on testing polynomial identities take advantage of a basic property of polynomials expressed by the Schwartz-Zippel Lemma.</p> <p>\\(\\text{Let } {Q(X_1, . . . , X_n)} \\text{ be a nonzero polynomial of } {n} \\text{ variables with degree } {d}, \\text{ and } {S} \\text{ be a finite but}\\) \\(\\text{sufficiently large subset of the field } {\\mathbb{F}}. \\text{ If we assign } { X_1, . . . , X_n } \\text{ values from } {S} \\text{ independently and }\\) \\(\\text{uniformly at random, then } {Pr[Q(X_1, . . . , X_n) = 0] \u2264 \\dfrac{d}{|S|}}.\\)</p> <p>Here's what the Schwartz-Zippel Lemma means in the proof/verification system of our mFibonacci state machine:</p> <p>\u200b   If the verifier selects the challenges \\(\\{ \\alpha_1, \\alpha_2 . . . , \\alpha_l \\}\\) randomly and uniformly, then the probability of the prover finding a false polynomial \\({Q'}\\) of degree \\(d\\), such that \\({Q'(\\alpha_j) = 0 = Q(\\alpha_j)}\\) for all \\(j \\in \\{ 1, 2, \\dots , l \\}\\) , is at most \\({\\dfrac{d}{|S|}}\\), which is very small.</p> <p>This speaks of the soundness of our polynomial commitment scheme.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#example-2-proving-the-mfibonacci-sm-via-a-pcs","title":"Example 2. (Proving the mFibonacci SM via a PCS)","text":"<p>Suppose the prover has to prove knowledge of the initial values of the mFibonacci Series that yields the \\(1024\\)-th term, \\(A_{1023} = \\mathtt{14\\ 823\\ 897\\ 298\\ 192\\ 278\\ 947}\\). Suppose a certain polynomial commitment scheme (PCS) is used to facilitate proving and verification.</p> <p>In a typical commitment scheme, the following  protocol is followed;</p> <p>(a) The prover commits to the polynomials \\(P(X)\\) and \\(Q(X)\\).</p> <p>(b) The verifier selects a random point \\(\\alpha\\), sends it to the prover, with a request for relevant openings.</p> <p>(c) The prover then provides the openings; \\(P(\\alpha)\\), \\(P(\\omega \\alpha)\\), \\(Q(\\alpha)\\) and \\(Q(\\omega \\alpha)\\).</p> <p>(d) The verifier can check correctness of the openings, by using transition constraints, $$ \\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\qquad\\quad\\text{ }\\text{ }\\text{ }\\text{ } $$</p> \\[ \\big(1 \u2212 R(X)\\big) \u00b7 [Q(X\\cdot \\omega) \u2212 (P(X) \u00b7 Q(X))] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\text{ }\\text{ } \\] <p>(e) In order to enable the verifier to check the boundary constraint,  $$ P(\\omega^{\\mathtt{1023}}) = \\mathtt{14\\ 823\\ 897\\ 298\\ 192\\ 278\\ 947}\\qquad\\qquad $$ the prover must send a witness \\(\\large{\\mathtt{w}}\\) as proof that he or she knows the correct value of the \\(1024\\)-th term, without disclosing the actual value \\(A_{1023} = \\mathtt{14\\ 823\\ 897\\ 298\\ 192\\ 278\\ 947}\\).</p> <p>(f) The verifier then uses a formula, which is specific to the commitment scheme in use and it takes the witness as an input, to check whether the prover has computed the correct \\(A_{1023}\\).</p> <p>Note that the prover does not provide any values concerning the constant polynomial \\(R(X)\\), because this is known to both the prover and the verifier.</p> <p>Any PCS such as KZG or FRI-based can be used to efficiently prove correctness of computations of our mFibonacci state machine.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#from-mathcalh-ranged-to-mathbbf_p-ranged-identities","title":"From \\({\\mathcal{H}}\\)-ranged to \\({\\mathbb{F}_p}\\)-ranged Identities","text":"<p>Let's look carefully at the constraints of the mFibonacci state machine; $$ \\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\qquad\\quad\\text{ }\\text{ }\\text{ }\\text{ } $$ $$ \\big(1 \u2212 R(X)\\big) \u00b7 [Q(X\\cdot \\omega) \u2212 (P(X) \u00b7 Q(X))] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\text{ }\\text{ } $$</p> \\[ \\big(P(\\omega^{\\mathtt{T}}) - \\mathcal{K} \\big)\\cdot R(X) = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\quad\\text{ }\\text{ }\\quad\\qquad\\quad\\quad\\qquad\\text{ }\\text{ }\\text{ } \\] <p>where  \\(\\mathtt{T}+1\\)  is the number of rows in the execution trace and \\(\\mathcal{K}\\) is an evaluation of \\(P(X)\\) at \\(\\omega^{\\mathtt{T}}\\), corresponding to the value of the registry \\(\\mathtt{A}\\) in the \\((\\mathtt{T}+1)\\)-st state, when specific initial values \\(\\mathtt{A}_0\\) and \\(\\mathtt{B}_0\\) are used in the state machine.</p> <p>The problem with the transition constraints, as presented above, is that they hold true only for \\(X \\in \\mathcal{H}\\), and not necessarily for \\(X \\in \\mathbb{F}_p\\). Note that the left-hand sides of the polynomial identities are but polynomials, which can be labelled \\(p_1(X)\\), \\(p_2(X)\\) and \\(p_3(X)\\). That is, $$ p_1(X) =\\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] =  \\bigg\\lvert_{\\mathcal{H}}\\ 0\\qquad\\quad\\text{ }\\text{ }\\text{ }\\text{ } \\ $$</p> \\[ p_2(X) = \\big(1 \u2212 R(X)\\big) \u00b7 [Q(X\\cdot \\omega) \u2212 (P(X) \u00b7 Q(X))] = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\text{ }\\text{ }\\\\ \\] \\[ p_3(X) = \\big(P(\\omega^{\\mathtt{T}}) - \\mathcal{K} \\big)\\cdot R(X)  = \\bigg\\lvert_{\\mathcal{H}}\\ 0\\quad\\text{ }\\text{ }\\text{}\\quad\\qquad\\qquad\\qquad\\text{ } \\] <p>Define the so-called vanishing polynomial on \\(\\mathcal{H}\\), denoted by \\(\\mathtt{Z}_{\\mathcal{H}}(X)\\), as the monomial of maximal degree such that \\(\\mathtt{Z}_{\\mathcal{H}}(X) = 0\\) for all \\(X \\in \\mathcal{H}\\). Therefore,  $$ \\mathtt{Z}_{\\mathcal{H}}(X) = (X-1)\\cdot(X-\\omega)\\cdot(X-\\omega^2)\\cdots(X-\\omega^{n-1}) = X^{n} - 1 $$ Since  \\(p_i(X) = 0\\)  for all  \\(X \\in \\mathcal{H} = \\{ \\omega, \\omega^2, \\omega^3, \\dots , \\omega^n = 1 \\}\\), then $$ p_i(X)\\ =\\ \\big((X-1)\\cdot(X-\\omega)\\cdot(X-\\omega^2)\\cdots(X-\\omega^{n-1})\\big)\\cdot q_i(X)\\ =\\ \\big( X^{n} - 1 \\big) \\cdot q_i(X) $$ for some quotient polynomial \\(q_i(X)\\), for each \\(i \\in \\{ 1, 2, 3 \\}\\).</p> <p>The polynomial identities of our mFibonacci state machine can therefore be rewritten as </p> \\[ \\big( 1 \u2212 R(X) \\big) \\cdot \\big[ P(X\\cdot \\omega) \u2212 Q(X) \\big] = \\mathtt{Z}_{\\mathcal{H}}(X)\\cdot q_1(X) \\qquad\\quad\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\] \\[ \\big(1 \u2212 R(X)\\big) \u00b7 [Q(X\\cdot \\omega) \u2212 (P(X) \u00b7 Q(X))] = \\mathtt{Z}_{\\mathcal{H}}(X)\\cdot q_2(X) \\text{}\\text{ }\\\\ \\] \\[ \\big(P(\\omega^{\\mathtt{T}}) - \\mathcal{K} \\big)\\cdot R(X) = \\mathtt{Z}_{\\mathcal{H}}(X)\\cdot q_3(X) \\qquad\\text{}\\text{}\\quad\\qquad\\qquad\\qquad\\text{ } \\] <p>The representatives \\(R(X)\\) and \\(Z_{\\mathcal{H}}(X)\\) in the PCS, can be preprocessed and be made public (i.e., known to both the Prover and the Verifier). The Verifier can check specific openings of these polynomials, \\(R(X)\\) and \\(Z_{\\mathcal{H}}(X)\\).</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#proofverification-via-pil-stark","title":"Proof/Verification via PIL-STARK","text":"<p>The zkEVM's basic proof system for proving correctness of all state machine computations is a STARK. The fundamental configuration is: the zkEVM utilises STARK proofs for proving correctness of computations, due to their speed; but in order to attain succinct verification, these STARK proofs are in turn proved with a single SNARK. So, the zkProver employs STARK proofs internally, while the publicised validity proofs are SNARKs.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#what-is-a-stark","title":"What is a STARK?","text":"<p>A STARK is a Scalable Transparent ARgument of Knowledge based on the Interactive Oracle Proof (IOP) model. Although a STARK is not adequately succinct, as a proof system, it is generally categorised as a special SNARK (which is short for Succinct Non-interactive ARgument of Knowledge).</p> <p>Succinctness here, refers to producing short proofs that are independent of the size of the witness, and thus enabling NP computations to be proved with substantially lower complexity than it is classically required, [AN2019]. In other words, an argument system for NP statements is succinct, if its communication complexity is polylogarithmic in the the size of the statement or the witness.</p> <p>A STARK falls short of succinctness because, although verifier arithmetic complexity is strictly logarithmic with respect to statement or witness size, prover arithmetic complexity is strictly linear, [BBHR18]. Yet, a STARK is scalable because it has at most a polylogarithmic prover overhead, and it is transparent as it requires no trusted setup.</p> <p>See the table below, taken from the presentation here, for a quick comparison of proofs sizes, prover and verification times, between STARKs, SNARKs and Bulletproofs.</p>  Table 1: Comparison of Proof Sizes, Proof and Verification Times  <p></p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#the-fri-pcs-context","title":"The FRI-PCS Context","text":"<p>The performance of a STARK is ascribable to the context in which it is deployed, the FRI Polynomial Commitment Scheme (or FRI-PCS). The acronym FRI is short for Fast Reed-Solomon Interactive Oracle Proof of Proximity, also abbreviated as \"Fast RS-IOPP\".</p> <p>On a high-level, FRI enables proving whether a given function \\(f : {\\mathcal{H}} \\to \\mathbb{F}_p\\) is \u201cclose\u201d to a certain polynomial of low degree. Hence the term proof of proximity.</p> <p>Loosely put, the FRI protocol allows for a random set of queries (requests for openings of polynomials at randomly selected field elements), used by the verifier to ascertain with high probability, the prover's knowledge of a committed polynomial.</p> <p>FRI is in fact a Merkle commitment scheme where commitments are roots of Merkle trees, and therefore needs no trusted setup, as it only uses hash functions.</p> <p>The FRI protocol is considered fast for several reasons;</p> <ul> <li>Firstly, due to its resemblance of the ubiquitous Fast Fourier Transforms (FFTs). </li> <li>Secondly, the arithmetic complexity of the prover is strictly linear.</li> <li>Thirdly, the size of the proof is O(n log(n)). </li> <li>And fourthly, the arithmetic complexity of the verifier is strictly logarithmic.</li> </ul> <p>Our special implementation of a STARK is called PIL-STARK, and its polynomial commitment scheme (PCS) is also based on the FRI protocol. We will later demonstrate how PIL-STARK is used to prove the polynomial identities of the mFibonacci state machine. </p> <p>Before describing PIL-STARK a quick look at the novel Polynomial Identities Language (PIL), and some of its distinguishing features, will be helpful.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#what-is-pil","title":"What Is PIL?","text":"<p>PIL is a domain-specific language (DSL) that provides a method for naming polynomials and describing the identities that define computations carried out by a state machine. </p> <p>A typical \\(\\texttt{.pil}\\) file for a given state machine specifies the details of the computation that the state machine carries out; </p> <ul> <li>the size (or degree) of the polynomials. i.e., the number of rows of the execution trace.</li> <li>the namespace of the state machine, which becomes a prefix to names of the SM's polynomials.</li> <li>defines the \\(\\texttt{ISLAST}\\) polynomial as a constant (preprocessed) polynomial.</li> <li>defines committed polynomials; \\(\\texttt{a}\\) and \\(\\texttt{b}\\).</li> <li>the zero-checks of the transition constraints.</li> <li>and, a zero-check of the boundary constraint.</li> </ul> <p>In cases where several state machines are being proved; although each SM may have a polynomial named \"ISLAST\", there would be no name-clashes in the Prover (and in the Verifier) because each polynomial is identified by prefixing its name with the namespace of the SM it belongs to. For example, \\(\\texttt{mFibonacci.ISLAST}\\) is the identifier of ISLAST where the mFibonacci SM has the namespace \\(\\texttt{mFibonacci}\\).</p> <p>See Figure 7 below, for a description of the mFibonacci SM in PIL, as an \\(\\texttt{mFibonacci.pil}\\) file.</p> <p></p>  Figure 7: The .pil file of the mFibonacci State Machine  <p>The value of the polynomial \\(\\mathtt{a}\\) in the next step (or state) of the state machine, is denoted by \\(\\mathtt{a'}\\) and it is read \"a\"-prime. i.e., If \\(\\mathtt{a = P(\\omega^i)}\\) then \\(\\mathtt{a' = P(\\omega^{i+1})}\\).</p> <p>Note that the current version of the PIL language only accepts degree-two expressions. That is, a single multiplication such as \\(\\texttt{(a-1)*a}\\) and \\(\\texttt{a*b}\\), but not \\(\\texttt{(a-1)*b*c}\\).</p> <p>The extra line, \\(\\text{line 8}\\) in Figure 7, was added for the very reason, to prevent the double multiplication required in the zero-check $$ \\mathtt{(1-ISLAST) * (b' - (a*b)) = 0;} $$ by splitting it into two steps, \\(\\text{line 8}\\) and \\(\\text{line 11}\\).</p> <p>A fuller description of PIL has been documented here.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#compiling-pil-into-json-demo","title":"Compiling PIL Into JSON (Demo)","text":"<p>Due to the modular design of the zkProver, it is possible to take a \\(\\texttt{.pil}\\) file describing computations of any state machine and compile it into a parsed version, a \\(\\texttt{.json}\\) file, that can be interpreted by the other software components.</p> <p>We demonstrate compiling the \\(\\texttt{mFibonacci.pil}\\) file into a \\(\\texttt{.json}\\) file with a novel Polynomial Identities Language Compiler, dubbed \\(\\texttt{PILCOM}\\). The details of \\(\\texttt{PILCOM}\\) will be documented elsewhere, but its repo can be found here. We treat it as a 'blackbox' in this demonstration.</p> <p>Here's how to achieve the compilation of the \\(\\texttt{mFibonacci.pil}\\) file;</p> <ol> <li> <p>Clone the \\(\\texttt{PILCOM}\\) repo,     $$    \\texttt{git clone https://github.com/0xPolygonHermez/pilcom}    $$</p> </li> <li> <p>Once cloned, switch directory to \\(\\texttt{pilcom/}\\), and install the module,    $$    \\mathtt{pilcom$} \\texttt{ npm install}\\quad\\text{}    \\    $$    and build the parser,    $$    \\mathtt{pilcom$} \\texttt{ npm run build}\\text{}\\    $$</p> </li> <li> <p>Type the lines of code, the \\(\\texttt{mFibonacci.pil}\\), into your code editor as it appears in Figure 7 above. You will need to Save it in some temporary folder. Whatever filename you give to the file, remember to use the \"\\(\\texttt{.pil}\\)\" extension.   In our case, we saved it in a folder named  \\(\\texttt{myproject}\\), and named the file  \\(\\texttt{mFibonacci.pil}\\)</p> </li> <li> <p>Compile the \\(\\texttt{mFibonacci.pil}\\) either at the \\(\\texttt{pilcom}\\) directory or the \\(\\texttt{pilcom/src}\\) subdirectory, using the command,    $$    \\mathtt{pilcom$} \\texttt{ node src/pil.js myproject/mfibonacci.pil -o myproject/mfibonacci.pil.json }\\qquad\\qquad\\qquad\\qquad\\text{ }\\    $$    or     $$    \\mathtt{pilcom/src$ } \\texttt{ node pil.js myproject/mfibonacci.pil -o myproject/mfibonacci.pil.json}\\    \\text{ }    $$    You might need to prefix the path \"\\(\\texttt{myproject/mfibonacci.pil}\\)\" with \"~/\" </p> </li> <li> <p>If successful, the output report (printed in the terminal) looks like this,  </p> </li> </ol> <p>It provides information on the number of polynomials used (both constant and committed), the number of polynomial identities to be checked, and other information pertaining to the number of identities checked with; \\(\\texttt{Plookup}\\) tables, \\(\\texttt{Permutation}\\) checks and \\(\\texttt{Connection}\\) checks.</p> <ol> <li>The \\(\\texttt{.json}\\) file that \\(\\texttt{PILCOM}\\) produces has the name speciified in Step 4, and can be found in the folder (subdirectory) specified in Step 4.</li> </ol> <p>In our case, the \\(\\texttt{.json}\\) file produced by \\(\\texttt{PILCOM}\\) appears in the \"MYPROJECT\" folder as \\(\\texttt{\\{ \\} fibonacci.pil.json}\\) and its content looks like this (Well, after removing the many newlines),</p> <p></p> <p>The \\(\\texttt{\\{ \\} fibonacci.pil.json}\\) file contains much more detail than the results seen in Step 5 above. For instance, it reflects the polynomial names prefixed with the state machine namespace \\(\\texttt{mFibonacci}\\) as stipulated to in the \\(\\texttt{mFibonacci.pil}\\) file. </p> <p>Each polynomial is further described with four (4) attributes; </p> <p>(a)  \\(\\texttt{type}\\) which specifies whether the polynomial is committed, constant or intermediate.</p> <p>(b)  \\(\\texttt{id}\\) is a unique identity associated to with the polynomial</p> <p>(c)  \\(\\texttt{polDeg}\\) reflects the degree of the polynomial</p> <p>(d) \\(\\texttt{isArray}\\) is a flag used to control array-based polynomial definitions.</p> <p>Among all the contents of the \\(\\texttt{\\{ \\} fibonacci.pil.json}\\) file, there is a key called \\(\\texttt{expressions}\\) which is an array containing all the identities and operations among the corresponding polynomials.</p> <p>Moreover, the \\(\\texttt{\\{ \\} fibonacci.pil.json}\\) file contains other keys representing all inclusion, permutation and copy constraint arguments.</p> <p>Other fields, important for debugging purposes, are     (a)  \\(\\texttt{nCommitments}\\): which specifies the total number of committed polynomials.     (b) \\(\\texttt{Constants}\\): which specifies the total number of constant polynomials referenced in the PIL file.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#description-of-pil-stark","title":"Description Of PIL-STARK","text":"<p>Simply put, PIL-STARK is a special STARK that enables; the state machine Prover (SM-Prover) to generate a STARK proofs for a State Machine written in PIL, and the state machine Verifier (SM-Verifier) to verify the STARK-proofs provided by the Prover. Hence there is a PIL-STARK component in the SM-Prover which is the Generator of a STARK proof, and another PIL-STARK component in the SM-Verifier which is the actual Verifier of the STARK proof.</p> <p>Since the SM-Prover and the SM-Verifier, who are separate and independent entities, require certain PIL-STARK parameters prior to proving and verification, the system needs some preprocessing phase. Call this phase, the \"Setup\" Phase.</p> <p>The PIL-STARK proof/verification process therefore consists of three (3) phases; the Setup, the Proving and the Verification. These are outlined below.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#pil-stark-preprocessing-setup-phase","title":"PIL-STARK Preprocessing (\"Setup\") Phase","text":"<p>The Setup Phase can be thought of as consisting of three 'components'; the \\(\\texttt{PILCOM}\\), the Setup \\(\\texttt{Executor}\\) and the \\(\\texttt{PIL-STARK Setup}\\).</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#compilation-with-pilcom","title":"Compilation With PILCOM","text":"<p>The novel compiler, called \\(\\texttt{PILCOM}\\), which is used for compiling a \\(\\texttt{.pil}\\) file into a parsed \\(\\texttt{.json}\\) file, is part of the Setup Phase of PIL-STARK. The compilation of the \\(\\texttt{.pil}\\) file into a parsed \\(\\texttt{.json}\\) file therefore happens in this phase of the PIL-STARK proof/verification process.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#the-setup-executor","title":"The Setup Executor","text":"<p>The \\(\\texttt{Setup Executor}\\) takes as input the PIL \\(\\texttt{.json}\\) file from \\(\\texttt{PILCOM}\\) in order to compute the evaluations of the state machine's constant polynomials. For each state machine, described by the \\(\\texttt{.pil}\\) file compiled with \\(\\texttt{PILCOM}\\), the execution process is carried out only once.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#pil-stark-setup","title":"PIL-STARK Setup","text":"<p>The PIL-STARK Setup takes as inputs; the PIL \\(\\texttt{.json}\\) file from \\(\\texttt{PILCOM}\\), the evaluations of the constant polynomials from the \\(\\texttt{Setup}\\) \\(\\texttt{Executor}\\), and the STARK configuration information in the form of a \\(\\texttt{starkstruct.json}\\) file. It then creates a Merkle tree with the evaluations of all the constant polynomials, called the \\(\\texttt{constTree}\\)</p> <p>It outputs PIL-STARK parameters; the \\(\\texttt{constTree}\\) which is a Merkle Tree of evaluations of the constant polynomials, the \\(\\texttt{starkInfo}\\) which is a STARK-specific information, and the \\(\\texttt{constRoot}\\) which is the root of the \\(\\texttt{constTree}\\).</p> <p>Overall, the Setup Phase of PIL-STARK takes as inputs; the \\(\\texttt{.pil}\\) file describing the state machine and STARK-specific parameters. Its outputs are; the evaluations of the constant polynomials, the \\(\\texttt{constTree}\\), the \\(\\texttt{starkInfo}\\), the \\(\\texttt{constRoot}\\), as well as the PIL \\(\\texttt{.json}\\) file from \\(\\texttt{PILCOM}\\).</p> <p>We emphasise that the Setup Phase of PIL-STARK is run only once for a particular \\(\\texttt{.pil}\\) file describing the state machine. A change in the \\(\\texttt{.pil}\\) file means a fresh Setup needs to be executed.</p> <p></p>  Figure 8: The Setup Phase of PIL-STARK"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#pil-stark-proving-phase","title":"PIL-STARK Proving Phase","text":"<p>The Proving Phase consists of two main components; the \\(\\texttt{SM-Prover}\\) \\(\\texttt{Executor}\\) and the PIL-STARK proof \\(\\texttt{Generator}\\).</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#the-sm-provers-executor","title":"The SM-Prover's Executor","text":"<p>The executor in the SM-Prover's takes as inputs; the PIL \\(\\texttt{.json}\\) file from \\(\\texttt{PILCOM}\\) and another \\(\\texttt{.json}\\) file of inputs, called \\(\\texttt{input.json}\\) . In the case of our mFibonacci SM, the inputs in \\(\\texttt{input.json}\\) includes the initial values of the registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\).</p> <p>The SM-Prover's Executor builds the values of polynomials that are to be committed. Its output is the evaluations of the committed polynomials, per proof. These evaluations of committed polynomials are actually the SM's execution trace.</p> <p>Note that the input values in the \\(\\texttt{input.json}\\) file can be varied without altering the actual state machine. The reason the state machine remains intact is due to fact that the \\(\\texttt{.pil}\\) file, that was initially compiled in the Setup phase, is not affected by any change in the input values of the SM-Prover's Executor.</p> <p>However, with every set of inputs, the SM-Prover's Executor computes corresponding evaluations of the committed polynomials to be used in generating the respective STARK proof. In other words, each new set of inputs determines a new set of evaluations, which in turn determines the STARK proof generated by the PIL-STARK Generator.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#pil-stark-proof-generator","title":"PIL-STARK proof Generator","text":"<p>This STARK Proof Generator takes as inputs; the the evaluations of the of committed polynomials from the SM-Prover's Executor, the evaluations of the constant polynomials from the Setup Phase, together with the \\(\\texttt{constTree}\\) and the \\(\\texttt{starkInfo}\\).</p> <p>This is where the evaluations of the committed polynomials, from the SM-Prover's Executor, are Merkelized. And all elements of the ultimate STARK proof are generated, these include; the witness and the required openings of the committed polynomials. </p> <p>The output of the STARK Proof Generator is a \\(\\texttt{STARK}\\) \\(\\texttt{proof}\\) and the \\(\\texttt{publics}\\), which are values to be publicised.</p> <p>For the PIL-STARK Proving Phase as a whole, also as depicted in Figure 9 below, </p> <ul> <li>there are five (5) inputs; the \\(\\texttt{input.json}\\) file, the PIL \\(\\texttt{.json}\\) file from \\(\\texttt{PILCOM}\\), the evaluations of the constant polynomials from the Setup Phase, as well as the \\(\\texttt{constTree}\\) and the \\(\\texttt{starkInfo}\\).</li> <li>and there are two (2) outputs; a \\(\\texttt{STARK}\\) \\(\\texttt{proof}\\) and the \\(\\texttt{publics}\\).</li> </ul> <p></p>  Figure 9: The Proving Phase of PIL-STARK"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#pil-stark-verification-phase","title":"PIL-STARK Verification Phase","text":"<p>The Verification Phase is constituted by the PIL-STARK Verifier. </p> <p>As it is common practice amongst zero-knowledge proof/verification systems, the size of the Verifier's inputs is very small compared to that of the Prover's inputs. For example, while the Proving Phase takes the whole \\(\\texttt{constTree}\\) as one of its inputs, the Verifier takes the \\(\\texttt{constRoot}\\) instead.</p> <p>The inputs to the Verifier are; the \\(\\texttt{STARK}\\) \\(\\texttt{proof}\\) and the \\(\\texttt{publics}\\) from the Prover, together with the \\(\\texttt{starkInfo}\\) and the \\(\\texttt{constRoot}\\) from the Setup Phase.</p> <p>And the Verifier's output is either an \\(\\texttt{Accept}\\) if the proof is accepted, or a \\(\\texttt{Reject}\\) if the proof is rejected.</p> <p></p>  Figure 9: The Verification Phase of PIL-STARK  <p>PIL-STARK is, all-in-all, a specific implementation of a STARK that can be used as a generic tool for proving state machines' polynomial identities.</p> <p>The actual implementation of PIL-STARK uses recursion. That is, hundreds of STARK proofs are proved with another STARK proof, and these STARK proofs of other STARK proofs are also proved with a single STARK proof. This achieves exponential scalability than it would otherwise be possible.</p> <p>The code for implementing PIL-STARK is found in the zkEVM repository here.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#re-writing-boundary-constraints-for-publics","title":"Re-writing Boundary Constraints For Publics","text":"<p>As seen in the description of PIL-STARK, one of the outputs of the SM-Prover is the \\(\\texttt{publics}\\), which are publicly known values. However, looking back at our demonstration, where the \\(\\texttt{mFibonacci.pil}\\) file was compiled with \\(\\texttt{PILCOM}\\), you will notice that the \\(\\texttt{publics}\\) field in the parsed \\(\\texttt{\\{ \\} fibonacci.pil.json}\\) file is empty. Check \\(\\text{line 6}\\) in the provided snapshot of the \"\\(\\texttt{\\{ \\} fibonacci.pil.json}\\)\" file, and notice it reads thus: $$ \\texttt{\"publics\": [],} $$ This is so, because no \\(\\texttt{publics}\\) were defined in the \\(\\texttt{mFibonacci.pil}\\) file that we compiled. This can also be checked in Figure 7 above.</p> <p>Again, you'll notice that the 1024-th value of the polynomial \\(\\texttt{a}\\) was hardcoded as \\(\\mathtt{144115188042301440}\\) in \\(\\texttt{line}\\) \\(\\texttt{13}\\), which checks the boundary constraint: $$ \\mathtt{ISLAST*(a - 144115188042301440) = 0;} $$ This is undesirable because any change in the initial conditions would yield a wrong proof, which the Verifier would reject.</p> <p>The aim in this subsection is to therefore, rewrite the boundary constraint in the \\(\\texttt{mFibonacci.pil}\\) file such that, instead of hardcoding this public value, it is rather generically defined. So, \\(\\mathtt{144115188042301440}\\), is replaced with a public variable called \"\\(\\texttt{out}\\)\". The new variable must be declared, and it is defined as, $$ \\textbf{public} \\texttt{ out = a(\\%N - 1);} $$ The modified boundary constraint check in  \\(\\texttt{mFibonacci.pil}\\) now looks like this, $$ \\texttt{ISLAST*(a - :out) = 0;} $$ where the \":\" colon-prefix indicates a read of the value stored at \\(\\texttt{out}\\).</p> <p>The modified \\(\\texttt{mFibonacci.pil}\\) file, before compilation with \\(\\texttt{PILCOM}\\), is now as follows,</p> <p></p>  Figure 10: mFibonacci.pil file with \"publics\"  <p>This modified \\(\\texttt{mFibonacci.pil}\\) file can be compiled with \\(\\texttt{PILCOM}\\) in the manner demonstrated earlier. The resulting parsed PIL file,  \"\\(\\texttt{\\{ \\} mfibonacci.pil.json}\\)\", now reflects some information in the \"\\(\\texttt{publics}\\)\" field, as shown here:</p> <p></p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#pil-stark-implementation-demo","title":"PIL-STARK Implementation (Demo)","text":"<p>Next, is a demonstration of how PIL-STARK is implemented. Again, you are encouraged to Do-It-Yourself, by following the steps provided in here.</p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#initialise-a-node-project","title":"Initialise A Node Project","text":"<p>The first step is to make a new subdirectory named \\(\\mathtt{mfibonacci\\_sm}\\), switch directory to it and initialise a node project as indicated below, $$ \\texttt{ npm init -y } $$ A successful initialisation looks like this:</p> <p> </p> <p>Next, install the required dependencies with the following command, $$ \\texttt{ npm install pil-stark yargs chai } $$ The installation takes seconds, and again the results looks like this,</p> <p></p>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#create-input-files","title":"Create Input Files","text":"<p>First of all, the overall inputs to PIL-STARK are; the \\(\\texttt{.pil}\\) file describing the mFibonacci state machine, the STARK configuration \\(\\texttt{.json}\\) file and the inputs \\(\\texttt{.json}\\) file, which contains initial values of the mFibonacci state machine.</p> <ul> <li>Either move the modified version of the \\(\\texttt{mfibonacci.pil}\\) file to the \\(\\mathtt{mfibonacci\\_sm}\\) subdirectory, or create a new file afresh at this subdirectory. Call it \\(\\texttt{mfibonacci.pil}\\). That is, copy the text below to the new file. Save the file.</li> </ul> <pre><code>  // mfibonacci.pil\n  constant %N = 1024;\n  namespace mFibonacci(%N);\n    pol constant ISLAST; // 0,0,0,0,.....,1 \n    pol commit a, b;\n    pol ab = a*b;\n  // publics\n    public out = a(%N-1);\n  // transition constraints\n    (1-ISLAST) * (a' - b) = 0;\n    (1-ISLAST) * (b' - (ab)) = 0;\n  // boundary constraint\n    ISLAST*(a-:out)=0;\n</code></pre> <ul> <li>Next, create a new file and call it \\(\\texttt{mfib.starkstruct.json}\\). Copy the code-text shown below, into this JSON file, and save it.</li> </ul> <pre><code>  // text{mfib.starkstruct.json}\n  {\n    \"nBits\": 10,\n    \"nBitsExt\": 11,\n    \"nQueries\": 8, \n    \"verificationHashType\": \"GL\", \n    \"steps\": [\n        {\"nBits\": 11}, \n      {\"nBits\": 7}, \n      {\"nBits\": 3}\n    ]\n  }\n</code></pre> <ul> <li>Create a new file and call it  \\(\\texttt{mfib.input.json}\\). Populate this JSON file with the initial values of the mFibonacci state machine of your choice (the numbers must be positive integers). We use here \\(\\texttt{[ 234, 135 ]}\\). Simply type the 2-element array in the  \\(\\texttt{mfib.input.json}\\) file and save it.</li> </ul>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#create-the-textttexecutor","title":"Create The \\(\\texttt{Executor}\\)","text":"<p>In our earlier description of PIL-STARK, the \\(\\texttt{Executor}\\) was 'split' into the \\(\\texttt{Setup} \\texttt{ executor}\\) and the \\(\\texttt{Prover } \\texttt{executor}\\). This was done for simplicity's sake. The two \\(\\texttt{executors}\\) are but one program that generates the evaluations of the constant polynomial, as well as the evaluations of the committed polynomials.</p> <p>Create a new file and call it  \\(\\mathtt{executor\\_mfibonacci.js}\\). Copy the code-text shown below, into this \\(\\texttt{.js}\\) file and save it in the \\(\\mathtt{mfibonacci\\_sm}\\) subdirectory.</p> <pre><code>// executor_mfibonacci.js\nconst { FGL } = require(\"pil-stark\");\n\nmodule.exports.buildConstants = async function (pols) {\n    const N = 1024;\n    for ( let i=0; i&lt;N; i++) { \n    pols.ISLAST[i] = (i == N-1) ? 1n : 0n;}\n    }\n\nmodule.exports.execute = async function (pols, input) { \n  const N = 1024;\n    pols.a[0] = BigInt(input[0]);\n    pols.b[0] = BigInt(input[1]); \n  for(let i=1; i&lt;N; i++){\n        pols.a[i] = pols.b[i-1];\n        pols.b[i] = FGL.mul(pols.a[i-1], pols.b[i-1]);\n    }\n    return pols.a[N-1];\n}\n</code></pre>"},{"location":"zkEVM/Basic-Concepts/mFibonnaci-State-Machine-eg/#create-pil-stark-proof-generator-and-verifier","title":"Create PIL-STARK Proof Generator And Verifier","text":"<p>Finally, create the PIL-STARK proof generator and verifier by creating a new file (using a code editor) and name it \\(\\mathtt{mfib\\_gen\\_and\\_prove.js}\\). </p> <p>Copy the code-text shown below, into this \\(\\mathtt{mfib\\_gen\\_and\\_prove.js}\\) file and save it in the \\(\\mathtt{mfibonacci\\_sm}\\) subdirectory.</p> <pre><code>const { FGL, starkSetup, starkGen, starkVerify } = require(\"pil-stark\");\nconst { newConstantPolsArray, newCommitPolsArray, compile, verifyPil } = require(\"pilcom\");\nconst path = require(\"path\");\n\n// Files\nconst pilFile = path.join(__dirname, \"mfibonacci.pil\");\nconst input = require(\"./mfib.input.json\");\nconst mFibExecutor = require(\"./executor_mfibonacci\");\nconst starkStruct = require(\"./mfib.starkstruct.json\");\n\nasync function generateAndVerifyPilStark() {\n    // Generate constants (preprocessed)\n    const pil = await compile(FGL, pilFile);\n    const constPols = newConstantPolsArray(pil);\n    const cmPols = newCommitPolsArray(pil);\n    await mFibExecutor.buildConstants(constPols.mFibonacci);\n    const executionResult = await mFibExecutor.execute(cmPols.mFibonacci, input); \n    console.log(executionResult);\n    // Generate trace\n    const evaluationPilResult = await verifyPil(FGL, pil, cmPols , constPols); \n    if (evaluationPilResult.length != 0) {\n        console.log(\"Abort: the execution trace generated does not satisfy the PIL description!\"); \n        for (let i=0; i &lt; evaluationPilResult.length; i++) {\n          console.log(pilVerificationResult[i]); } return;\n        } else { \n          console.log(\"Continue: execution trace matches the PIL!\"); }\n    // Setup for the stark\n    const setup = await starkSetup(constPols, pil, starkStruct);\n    // Generate the stark\n    const proverResult = await starkGen(cmPols,constPols,setup.constTree,setup.starkInfo);\n    // Verify the stark\n    const verifierResult= await starkVerify(proverResult.proof, proverResult.publics, setup.constRoot,setup.starkInfo);\n\n    if (verifierResult === true) { console.log(\"VALID proof!\");\n     } else { console.log(\"INVALID proof!\"); }\n}\n\ngenerateAndVerifyPilStark();\n\n</code></pre> <p>Run the \\(\\mathtt{mfib\\_gen\\_and\\_prove.js}\\) code: $$ \\mathtt{node } \\texttt{ mfib_gen_and_prove.js} $$ After a long reporting on all the checks made, a successful STARK generation and its verification is indicated with a \"\\(\\texttt{VALID proof!}\\)\" message. If you used different filenames from ours, you might have to do some light debugging.</p>"},{"location":"zkEVM/Overview/Overview/","title":"Polygon zkEVM Documentation","text":"<p>Welcome to Polygon zkEVM documentation.</p> <p>Polygon zkEVM is a decentralized Ethereum Layer 2 scalability solution based on cryptographic proofs to provide validation and fast finality to transactions.</p> <p>This documentation presents the Polygon zkEVM. Starting with the architectural overview of Polygon zkEVM, the documentation cascades step-by-step into the finer details of zkEVM's sub-components.</p> <p>We however emphasise that this documentation is still Work In Progress (WIP). Some aspects have been covered in more detail, while others still need further expansion. Also, sections of this documentation might later be reorganized in order to achieve better flow.</p>"},{"location":"zkEVM/Overview/Overview/#zkevms-architectural-overview","title":"zkEVM's Architectural Overview","text":"<p>Over and above what its predecessor was designed to do, the main functionality of zkEVM is to provide smart contract support. It performs the task of state transition resulting from the Ethereum Layer 2 transaction executions (transactions that users send to the network). Subsequently, by employing zero-knowledge proof technology, it generates validity proofs that attest to the correctness of these state change computations carried out off-chain.</p> <p>The major components of zkEVM are:</p> <ul> <li>Proof of Efficiency (PoE) consensus mechanism.</li> <li>zkNode software including a synchronizer, sequencer and aggregator. </li> <li>LX-to-LY bridge.</li> <li>zkProver.</li> <li>Active users of the zkEVM network who create transactions.</li> </ul> <p>The skeletal architecture of zkEVM is shown below:</p> <p></p>  Figure 1 : Skeletal Overview of zkEVM"},{"location":"zkEVM/Overview/Overview/#consensus-algorithm-proof-of-efficiency","title":"Consensus Algorithm: Proof of Efficiency","text":"<p>Our earlier version, Polygon Hermez 1.0, is based on the Proof of Donation (PoD) consensus mechanism. This model decides who would be the next batch creator. PoD is a decentralised auction that is conducted automatically and the participants (coordinators) bid a number of tokens so that they have the chance to create the next batch.</p> <p>However, for the implementation of the current 2.0, PoD needed to be replaced with a much simpler Proof of Efficiency (PoE) model. Let us see why PoE is preferable to PoD.</p>"},{"location":"zkEVM/Overview/Overview/#why-is-pod-not-the-best-option","title":"Why is PoD not the Best Option?","text":"<p>The PoD model fell out of our preferable options for the reasons listed below:</p> <ul> <li>The PoD, being an auction model, has proved to be quite complex for both the coordinators and the validators. Besides, it has also proven to be less viable economically.  </li> <li>This consensus mechanism is vulnerable to attacks, especially during the bootstrapping phases. At any given point in time, the network is controlled by a permissionless participant. This raises the risk for the network to suffer service level delays should such a third party turn malicious or experience operational issues.</li> <li>PoD assigns the right to produce batches in a specific timeframe and validators need to be very competitive if they are to gain any economic incentives.</li> <li>The efficacy of selecting \u201cthe best\u201d operator amounts to a \"winner-takes-all\" model, which turns out to be unfair to competitors with slightly less performance. Consequently, only a few select operators validate batches more often than others, defeating the concept of network decentralization.</li> <li>Another drawback is that the auction protocol is very costly and complex for validators. The auction requires bidding some time in advance.</li> </ul>"},{"location":"zkEVM/Overview/Overview/#why-is-poe-a-better-model","title":"Why is PoE a Better Model?","text":"<p>The Proof of Efficiency (PoE) model leverages the existing Proof of Donation mechanism and supports the permissionless participation of multiple coordinators to produce batches in Layer L2. These batches are created from the rolled-up transactions of Layer 1. As compared to PoD, PoE employs a much simpler mechanism and is preferred owing to its better efficiency to solve the problems inherent in PoD.   </p> <p>The strategic implementation of PoE promises to ensure that the network: </p> <ul> <li>Maintains its \"permissionless\" feature to produce L2 batches </li> <li>Is efficient, a criterion which is key for the overall network performance</li> <li>Attains an acceptable degree of decentralization</li> <li>Is protected from malicious attacks, especially by validators</li> <li>Keeps a proportionate balance between the overall validation effort and the value in the network.</li> </ul> <p>Note: Possibilities of coupling PoE with a PoS (Proof of Stake) are currently being explored.</p> <p>A detailed description of zkEVM's PoE is found here.</p>"},{"location":"zkEVM/Overview/Overview/#hybrid-mode-for-on-chain-data-availability","title":"Hybrid Mode for On-Chain Data Availability","text":"<p>A full zk-rollup schema requires that both the data (which is required by users to reconstruct the full state) and the validity proofs (zero-knowledge proofs) be published on-chain. However, given the Ethereum setting, publishing data on-chain incurs gas fees, which is an already-existing problem with Layer 1. This makes it difficult to choose between a full zk-rollup configuration and a hybrid one. </p> <p>Under a hybrid schema, either of the following is possible:</p> <ul> <li>Validium: Data is stored off-chain and only the validity proofs are published on-chain.</li> <li>Volition: For some transactions, both the data and the validity proofs remain on-chain while for the remaining ones, only proofs go on-chain.</li> </ul> <p>Unless, among other things, the proving module can be highly accelerated to mitigate costs for the validators, a hybrid schema remains viable. The team is yet to finalise the best consensus configuration.</p>"},{"location":"zkEVM/Overview/Overview/#the-poe-smart-contract","title":"The PoE Smart Contract","text":"<p>The underlying protocol in zkEVM ensures that the state transitions are correct by employing a validity proof. To ensure that a set of pre-determined rules have been followed for allowing transitioning of the state, a smart contract is employed. The verification of the validity proofs by a smart contract checks if each transition is done correctly. This is achieved by using zk-SNARK circuits. Such a mechanism entails two processes: batching of transactions and validation of the batched transactions. zkEVM uses two types of participants to carry out these processes: Sequencers and Aggregators. Under this two-layer model: </p> <ul> <li> <p>Sequencers propose transaction batches to the network, i.e. they roll-up the transaction requests to batches and add them to the PoE smart contract.</p> </li> <li> <p>Aggregators check the validity of the transaction batches and provide validity proofs. Any permissionless Aggregator can submit the proof to demonstrate the correctness of the state transition computation.</p> </li> </ul> <p>The PoE smart contract, therefore, makes two basic calls: A call to receive batches from Sequencers, and another call to Aggregators, requesting batches to be validated. See Figure 2 below:</p> <p></p>  Figure 2: Simplified Proof of Efficiency"},{"location":"zkEVM/Overview/Overview/#proof-of-efficiency-tokenomics-sequencers-and-aggregators","title":"Proof of Efficiency Tokenomics: Sequencers and Aggregators","text":"<p>The PoE smart contract imposes a few requirements on Sequencers and Aggregators.</p> <p>Sequencers</p> <p>A Sequencer receives L2 transactions from the users, preprocesses them as a new L2 batch, and then proposes the batch to the PoE smart contract as a valid L2 transaction.</p> <ul> <li>Anyone with the software necessary for running a zkEVM node can be a Sequencer. </li> <li>Every Sequencer must pay a fee in form of MATIC tokens to earn the right to create and propose batches. </li> <li>A Sequencer that proposes valid batches (which consist of valid transactions), is incentivised with the fee paid by transaction-requestors or the users of the network. </li> </ul> <p>Aggregators</p> <p>An Aggregator receives all the transaction information from the Sequencer and sends it to the prover which provides a small zk-proof after complex polynomial computations. The smart contract validates this proof. This way, an aggregator collects the data, sends it to the prover, receives its output and finally, sends the information to the smart contract to check that the validity proof from the prover is correct. </p> <ul> <li>An Aggregator's task is to provide validity proofs for the L2 transactions proposed by Sequencers.</li> <li>In addition to running zkEVM's zkNode software, Aggregators need to have specialised hardware for creating the zero-knowledge validity proofs. We, herein, call it the zkProver. (You will read about it later in this document).</li> <li>For a given batch or batches, an Aggregator that submits a validity proof first earns the Matic fee (which is being paid by the Sequencer(s) of the batch(es)).</li> <li>The Aggregators need to indicate their intention to validate transactions and then they compete to produce the validity proofs based on their own strategy.</li> </ul>"},{"location":"zkEVM/Overview/Overview/#incentivization-structure","title":"Incentivization Structure","text":"<p>Below is a summary of the structure of how Sequencers and Aggregators are incentivised:</p> <p>(a) Sequencer</p> <ul> <li>Collects transactions and publish them in a batch</li> <li>Receives fees from the published transactions</li> <li>Pays L1 transaction fees + MATIC (depends on pending batches)</li> <li>MATIC goes to Aggregators</li> <li>Profitable if: <code>txs fees</code> &gt; <code>L1 call</code> + <code>MATIC</code> fee</li> </ul> <p>(b) Aggregator</p> <ul> <li>Processes transactions published by Sequencers</li> <li>Builds zkProof</li> <li>Receives MATIC from Sequencer</li> <li>Static Cost: L1 call cost + Server cost (to build a proof)</li> <li>Profitable if: <code>MATIC fee</code> &gt; <code>L1 call</code> + <code>Server cost</code></li> </ul>"},{"location":"zkEVM/Overview/Overview/#zknode","title":"zkNode","text":"<p>A zkNode is the software needed to run a zkEVM node. It is a client that the network requires to implement the synchronization and govern the roles of the participants (Sequencers or Aggregators). </p>"},{"location":"zkEVM/Overview/Overview/#zknode-architecture","title":"zkNode Architecture","text":"<p>The zkNode Architecture is composed of:</p> <ol> <li> <p>Sequencers and Aggregators: Polygon zkEVM participants will choose how they participate; either as a node to know the state of the network; or as a participant in the process of batch production in any of the two roles: Sequencer or Aggregator. An Aggregator runs the zkNode but also performs validation using the core part of the zkEVM, called the zkProver (this is labelled Prover in Figure 3 below.)</p> </li> <li> <p>Synchronizer: Other than the sequencing and the validating processes, the zkNode also enables synchronisation of batches and their validity proofs, which happens only after these have been added to L1. This is accomplished using a subcomponent called the Synchronizer. A Synchronizer is in charge of getting all the data from smart contracts, which includes the data posted by the sequencers (transactions) and the data posted by the coordinators (which is the validity proof). All this data is stored in a huge database and served to third parties through a service called \"JSON-RPC\".    The Synchronizer is responsible for reading the events from the Ethereum blockchain, including new batches to keep the state fully synced. The information read from these events must be stored in the database. The Synchronizer also handles possible reorgs, which will be detected by checking if the last <code>ethBlockNum</code> and the last <code>ethBlockHash</code> are synced.</p> </li> </ol> <p></p>  Figure 3: zkEVM zkNode Diagram  <p>The architecture of zkNode is modular and implements a set of functions as depicted in Figure 3 above.</p> <ol> <li> <p>RPC: RPC (Remote Procedure Call) is a JSON RPC interface compatible with Ethereum. For a software application to interact with the Ethereum blockchain (by reading blockchain data and/or sending transactions to the network), it must connect to an Ethereum node. RPC enables integration of the zkEVM with existing tools, such as Metamask, Etherscan and Infura. It adds transactions to the Pool and interacts with the State using read-only methods. </p> </li> <li> <p>State: A subcomponent that implements the Merkle Tree and connects to the DB backend. It checks integrity at the block level (information related to gas and block size, among others) and some transaction-related information (signatures, sufficient balance). State also stores smart contract code into the Merkle tree and processes transactions using the EVM.</p> </li> <li> <p>zkProver: All the rules for a transaction to be valid are implemented and enforced in the zkProver. A zkProver performs complex mathematical computations in the form of polynomials and assembly language; these are then verified on a smart contract. Those rules could be seen as constraints that a transaction must accomplish in order to be able to modify the state tree or the exit tree. The zkProver is the most complex module; it required developing two new programming languages to implement the needed elements. Read below to know more about zkProver. </p> </li> </ol>"},{"location":"zkEVM/Overview/Overview/#zkprover","title":"zkProver","text":"<p>zkEVM employs advanced zero-knowledge technology to create validity proofs. It uses a zero-knowledge prover (zkProver), which is intended to run on any server and is being engineered to be compatible with most consumer hardware. Every Aggregator will use this zkProver to validate batches and provide validity proofs. zkProver has its own detailed architecture which is outlined below. It consists of a Main State Machine Executor, a collection of secondary State Machines (each with its own executor), a STARK-proof builder, and a SNARK-proof builder. See Figure 4 below for a simplified diagram of the zkEVM zkProver:</p> <p></p>  Figure 4: A Simplified zkProver Diagram  <p>In a nutshell, the zkEVM expresses state changes in a polynomial form. Therefore, the constraints that each proposed batch must satisfy are, in fact, polynomial constraints or polynomial identities. That is, all the valid batches must satisfy certain polynomial constraints.</p>"},{"location":"zkEVM/Overview/Overview/#zkprover-architecture","title":"zkProver Architecture","text":"<p>The zkNode Architecture is composed of:</p> <ol> <li> <p>Main State Machine Executor: The Main Executor handles the execution of the zkEVM. This is where EVM Bytecodes are interpreted using a new zero-knowledge Assembly language (or zkASM), specially developed by the team. The executor also sets up the polynomial constraints that every valid batch of transactions must satisfy. Another language, specially developed by the team, called  Polynomial Identity Language (or PIL), is used to encode all the polynomial constraints.</p> </li> <li> <p>Secondary State Machines: Every computation required in proving the correctness of transactions is represented in the zkEVM as a state machine. The zkProver, being the most complex part of the whole project, consists of several state machines; from those carrying out bitwise functionalities (e.g., XORing, padding, etc.) to those performing hashing (e.g., Keccak, Poseidon), even to verifying signatures (e.g., ECDSA).    The collection of the secondary state machines, therefore, refers to a collection of all state machines in the zkProver. It is not a subcomponent per se, but a collection of various executors for individual secondary state machines. The set of state machines are:</p> </li> </ol> <p>\u200b    (a) Binary SM</p> <p>\u200b    (b) Memory SM</p> <p>\u200b    (c) Storage SM</p> <p>\u200b    (d) Poseidon SM</p> <p>\u200b    (e) Keccak SM</p> <p>\u200b    (f) Arithmetic SM</p> <p>See Figure 5 below for dependencies among these SMs.</p> <p>While some SMs use both zkASM and PIL, others rely only on one of these languages depending upon the specific operations each SM is responsible for.</p> <p></p>  Figure 5: zkEVM State Machines  <ol> <li> <p>STARK Proof Builder: STARK, which stands for \"Scalable Transparent Argument of Knowledge\", is a proof system that enables provers to produce verifiable proofs without the need for a trusted setup. A STARK Proof Builder refers to the subcomponent used to produce zero-knowledge STARK proofs, which are zk-proofs attesting to the fact that all the polynomial constraints are satisfied.State machines generate polynomial constraints and zk-STARKs are used to prove that batches satisfy these constraints. In particular, zkProver utilises \"Fast Reed-Solomon Interactive Oracle Proofs of Proximity (RS-IOPP)\", colloquially called FRI, to facilitate fast zk-STARK proving.</p> </li> <li> <p>SNARK Proof Builder: SNARK, which stands for \"Succinct Non-interactive Argument of Knowledge\", is a proof system that produces verifiable proofs. Since STARK proofs are bigger than the SNARK proofs, zkEVM zkProver uses SNARK proofs to prove the correctness of these STARK proofs. Consequently, the SNARK proofs, which are much cheaper to verify on L1, are published as validity proofs.The aim is to generate a CIRCOM circuit which can be used to generate or verify a SNARK proof. Whether a PLONK or a GROTH16 SNARK proof will be used for zkEVM is a question that needs to be discussed. </p> </li> </ol>"},{"location":"zkEVM/Overview/Overview/#the-lx-to-ly-bridge","title":"The LX-to-LY Bridge","text":"<p>An LX-LY bridge is a smart contract that lets users transfer their assets between two layers, LX and LY. The L1-L2 in zkEVM is a decentralised bridge for secure deposits and withdrawal of assets; it is a combination of two smart contracts, one deployed on one chain and the second on the other.</p> <p>The L1 and L2 contracts in zkEVM are identical except for where each is deployed. Bridge L1 Contract is on the Ethereum mainnet in order to manage asset transfers between rollups, while Bridge L2 Contract is on a specific rollup and it is responsible for asset transfers between mainnet and the rollup (or rollups). Layer 2 Interoperability allows a native mechanism to migrate assets between different L2 networks. This solution is embedded in the bridge smart contract.</p>"},{"location":"zkEVM/Overview/Overview/#bridge-l1-contract","title":"Bridge L1 Contract","text":"<p>Bridge L1 Contract carries out two operations: <code>bridge</code> and <code>claim</code>. The <code>bridge</code> operation transfers assets from one rollup to another, while the <code>claim</code> operation applies when the contract makes a claim from any rollup.</p> <p>Bridge L1 Contract requires two Merkle trees in order to perform the above operations: <code>globalExitTree</code> and <code>mainnet exit tree</code>. The <code>globalExitTree</code> contains all the information of exit trees of all rollups, whereas the <code>mainnet exit tree</code> has information on transactions made by users who interact with the mainnet. A contract named the global exit root manager L1 is responsible for managing exit roots across multiple networks. </p> <p>The exit tree structure is depicted in Figure 6 below:</p> <p></p>  Figure 6: The Exit Tree Structure"},{"location":"zkEVM/Overview/Overview/#bridge-l2-contract","title":"Bridge L2 Contract","text":"<p>Bridge L2 Contract is deployed on Layer L2 with ether on it. The ether will be set on the genesis in order to enable the minting/burning of the native ether.</p> <p>Bridge L2 Contract also requires all the information of exit trees of all rollups contained in the <code>globalExitTree</code> Merkle tree. In this case, a smart contract named the global exit root manager L2 is responsible for managing the exit roots across multiple networks.</p> <p>Note: When a batch is verified in the PoE smart contract in L1, the rollup exit root is updated in the global exit root manager L1. Bridge L2 Contract handles the rollup side of the <code>bridge</code> and the <code>claim</code> operations, as well as interacting with the <code>globalExitTree</code> and the <code>rollup exit tree</code>, mainly to update exit roots.</p>"},{"location":"zkEVM/Overview/Overview/#lx-to-ly-bridge","title":"LX-to-LY Bridge","text":"<p>Typically, a bridge smart contract is an L2-to-L1 Bridge, but the zkEVM Bridge is more flexible and interoperable. It can function as a bridge between any two arbitrary Layer 2 chains, L2_A and L2_B, or between any Layer 2 (say L2_X) and L1 (Ethereum blockchain). It consequently allows asset transfers among multiple rollups. Hence the term \"LX-to-LY Bridge\".</p>"},{"location":"zkEVM/Overview/Overview/#zkevm-design-characteristics","title":"zkEVM Design Characteristics","text":"<p>The architectural details (for engineering and implementation) described in the sections above will help zkEVM attain its design goals. That would mean a network which is: permissionless, decentralized, secure, efficient and comes with verifiable block data.</p> <p>Development efforts aim at permissionless-ness, that is, allowing anyone with the zkEVM software to participate in the network. For instance, the consensus algorithm will give everyone the opportunity to be a Sequencer or an Aggregator.</p> <p>Data availability is most crucial for decentralization, where every user has sufficient data needed to rebuild the full state of a rollup. As discussed above, the team still has to decide on the best configuration for data availability. The aim is to ensure that there is no censorship and that no one party can control the network.</p> <p>zkEVM was designed with security in mind. As an L2 solution, most of the security is inherited from Ethereum. Smart contracts will warrant that anyone who executes state changes must, firstly, do it correctly; secondly, create a proof that attests to the validity of a state change; and thirdly, avail validity proofs on-chain for verification.</p>"},{"location":"zkEVM/Overview/Overview/#efficiency-and-overall-strategy","title":"Efficiency and Overall Strategy","text":"<p>Efficiency is key to network performance. zkEVM, therefore, applies several implementation strategies to guarantee efficiency. A few of them are listed below:</p> <ol> <li> <p>The first strategy is to deploy PoE, which incentivizes the most efficient aggregators to participate in the proof generation process.</p> </li> <li> <p>The second strategy is to carry out all computations off-chain while keeping only the necessary data and zk-proofs on-chain.</p> </li> </ol> <p>There are other strategies too that are implemented within specific components of the zkEVM system. For instance:</p> <ol> <li> <p>The way in which the bridge smart contract is implemented, such as settling accounts in a UTXO manner, by only using the Exit Tree Roots.</p> </li> <li> <p>Utilisation of specialised cryptographic primitives within the zkProver in order to speed up computations and minimise proof sizes, as seen in:</p> </li> </ol> <p>(a) Running a special zero-knowledge Assembly language (zkASM) for interpretation of byte codes</p> <p>(b) Using zero-knowledge tools such as zk-STARKs for proving purposes; these proofs are very fast though they are bigger in size. See. </p> <p>So, instead of publishing the sizeable zk-STARK proofs as validity proofs, a zk-SNARK is used to attest to the correctness of the zk-STARK proofs. These zk-SNARKs are, in turn, published as the validity proofs to state changes. This helps in reducing the gas costs from 5M to 350K.</p>"},{"location":"zkEVM/Overview/Overview/#final-remarks-and-whats-next","title":"Final Remarks And What's Next ...","text":"<p>Given the EVM opcode compatibility, zkEVM is designed to process smart contracts seamlessly and verify state changes efficiently. It promises not only to be secure and efficient but to also accomplish competitive decentralization. In an effort to achieve high-speed proving and succinct proofs for quick verification, the team is focused on the optimization of the zkProver.</p> <p>The team also leverages the synergies among the different Polygon teams that are also looking into zk-rollup solutions for achieving Ethereum scalability. Although development is still far from mainnet, an alpha version of the zkEVM code (together with all documentation) was open-sourced since EthCC[5] in Paris.</p> <p>This was done so as to align with the principle of transparency for open-source projects, as well as keep the Polygon community of developers and users of Polygon Hermez 1.0 updated with the upcoming changes. Our next step will be a public testnet. Although it is difficult to set a fixed date for the same, our plan is to launch it during the third quarter of 2022.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/","title":"Intro Anthony","text":"<p>Polygon zkEVM is a zk-rollup that executes smart contracts transparently, by publishing zero-knowledge validity proofs, while maintaining opcode compatibility with the Ethereum Virtual Machine. Core to its integrity is the zero-knowledge prover, dubbed the zkProver. In this section of the documentation we provide an architectural description of the zkProver, highlighting the elements of the proving machinery, without delving into its technical complexities. It is therefore a prelude to the state machines' documentation.</p> <p>Firstly, we recall briefly that the zkProver operates in the zk-rollup context, producing verifiable zero-knowledge proofs as validity proofs. Secondly, we present the zkProver's state machines in a cursory manner, highlighting their dependencies. And thirdly, we introduce two novel languages that are key to attaining an efficient zkProver. That is, what it takes to create validity proofs, as well as to enable easy verification of these proofs.</p> <p>Since the zkProver is an algebraic processor, as opposed to an electronic processor, we delineate the arithmetization approach in subsections subsequent to this introduction.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#zkprover-and-the-zknode","title":"zkProver And The zkNode","text":"<p>Before delving into the state machines, note that the zkProver is but a component in the Polygon zkEVM, and the only component responsible for proving correctness of zkEVM computations.</p> <p>In order to lay the context for the state machines, recall that the zkProver mainly interacts with two other components, the Node and the Database (DB).</p> <p></p>  Figure 1: zkProver and the Node  <p>As depicted in Figure 1 above; </p> <p>Firstly, the Node sends the content of Merkle trees to the DB, to be stored there. </p> <p>Secondly, the Node sends the input transactions to the zkProver. </p> <p>Thirdly, the zkProver accesses the DB, fetching the information it needs to produce verifiable proofs of the transactions sent by the Node. This information consists of, among others, the Merkle roots, the keys and hashes of relevant siblings. </p> <p>Fourthly, the zkProver generates the proofs of transactions, and sends these proofs back to the Node. </p> <p>But this only scratches the surface of what the zkProver does. There is a lot more detail involved in how the zkProver actually creates these verifiable proofs of transactions. And, it is in these details that the state machines come into the picture.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#state-machines","title":"State Machines","text":"<p>The zkProver follows modularity of design to the extend that, except for a few components, it is mainly a cluster of state machines. It has a total of fourteen (14) state machines;</p> <ul> <li>The Main State Machine, </li> <li>Secondary state machines; The Binary SM, the Storage SM, the Memory SM, the Arithmetic SM, the Keccak Function SM, and the PoseidonG SM,</li> <li>Auxiliary state machines; The Padding-PG SM, the Padding-KK SM, the Nine2One SM, the Memory Align SM, the Norm Gate SM, the Byte4 SM, and the ROM SM.</li> </ul> <p>The modular design of the zkProver allows the Main SM to delegate as many of its duties as possible to other specialist state machines. As such, efficiency is achieved through delegation.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#secondary-state-machines","title":"Secondary State Machines","text":"<p>The Main SM Executor directly instructs each of the secondary state machines by sending appropriate instructions called Actions, as depicted in Figure 2 below.</p> <p>The grey boxes in Figure 2 below, do not represent state machines but Actions, which are specific instructions from the Main SM to the relevant secondary SM.</p> <p>These instructions dictate how a state should transition in a state machine. However, every \"Action\" performed, whether by the generic Main SM or the specific SM, must be supported with proof that it was correctly executed.</p> <p></p>  Figure 2: The Main SM Executor's Instructions  <p>There are some natural dependencies such as between; </p> <ul> <li>the Storage State Machine which uses merkle Trees and the \\(\\text{POSEIDON}\\) State Machine, which is needed for computing hash values of all nodes in the Storage's Merkle Trees.</li> <li>Each of the hashing state machines, Keccak Function SM and the PoseidonG SM, and their respective padding state machines, the Padding-KK SM and the Padding-PG SM.</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#two-novel-languages-for-the-zkprover","title":"Two Novel Languages For The zkProver","text":"<p>The Polygon Hermez team has created two novel languages especially for the zkProver; The Zero-Knowledge Assembly language and the Polynomial Identity Language. </p> <p>Since adopting the state machines paradigm means switching from highlevel programming to low-level programming, it is not suprising for the zkProver to employ an especially designed language for the firmware and another for the hardware.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#the-zero-knowledge-assembly","title":"The Zero-Knowledge Assembly","text":"<p>As an Assembly language, the Zero-Knowledge Assembly (or zkASM) language is specially designed to map instructions from the zkProver's Main SM to other state machines. In the case of state machines with the firmware, zkASM is therefore the interpreter for the firmware. </p> <p>zkASM codes take instructions from the Main SM and generate prescriptive assembly codes for how the specific SM Executor has to execute computations. The Executor's strict adherence to the rules and logic of the zkASM codes, enables easy verification of computations.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#the-polynomial-identities-language","title":"The Polynomial Identities Language","text":"<p>The Polynomial Identity Language (or PIL) is a domain-specific language for defining polynomial constraints of the executional trace in state machines. It was especially designed for the zkProver, because almost all state machines express computations in terms of polynomials. State transitions in state machines must therefore satisfy computation-specific polynomial identities or constraints.</p> <p>Since the  context is that of an efficient Zero-Knowledge Commitment Scheme, and the most secure and efficient commitment schemes are the Polynomial Commitment Schemes, it was expedient to translate computations into some polynomial language, where verification boils down to testing whether execution satisfies certain polynomial constraints. All PIL codes, in the zkProver's state machines, therefore form the very DNA of the verifier code. </p> <p>These two languages, zkASM and PIL, were designed mindful of prospects for broader adoption outside Polygon zkEVM.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#the-micro-processor-context","title":"The Micro-Processor Context","text":"<p>There are two micro-processor-type state machines; the Main SM and the Storage SM. This means these two SMs have the firmware part and the hardware part.</p> <p>The firmware part runs the zkASM language to set up the logic and rules, which are expressed in JSON format and stored in a ROM. The JSON-file is then parsed to the specific SM Executor, which then executes Storage Actions in compliance with the rules and logic in the JSON-file.</p> <p>The hardware part, which speaks the Polynomial Identity Language (PIL), defines constraints (or polynomial identities), expresses them in JSON format and stores them in the corresponding JSON-file. As in the firmware case, these constraints are also parsed to the specific SM Executor, because all computations must be executed in conformance to the polynomial identities.</p> <p></p>  Figure 3 : Micro-Processor State Machine  <p>Although these two micro-processor SMs, the Main SM and the Storage SM, have the same look and feel, they differ considerably.</p> <p>For instance, the Storage SM specialises with execution of Storage Actions (also called SMT Actions), whilst the Main SM is responsible for a wider range of Actions. Nevertheless, the Main SM delegates most of these Actions to specialist state machines. And, of course, the Storage SM remains secondary in that it also receives instructions from the Main SM, and not conversely.</p> <p>It is worth noting that each of these micro-processor SMs has its own ROM. Specific details are covered in the respective documents for these state machines. The document for the Storage SM is found here.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#hashing-in-the-zkprover","title":"Hashing In The zkProver","text":"<p>There are two secondary state machines specialising with hashing; The Keccak State Machine and the \\(\\text{POSEIDON}\\) State Machine, where each is an 'automised' version of its standard cryptographic hash function.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#the-keccak-state-machine","title":"The Keccak State Machine","text":"<p>The deployment of the Keccak hash function is not surprising given the fact that it is deployed in Ethereum, and Polygon Hermez is a zk-rollup, an L2 scaling solution for Ethereum.</p> <p>The Keccak state machine is a gates state machine, and thus has a set of logic gates (the hardware) and a set of connections between the gates (the logic). It is a secondary state machine composed of the Keccak SM Hash Generator and the Keccak PIL code, where the latter is for validation purposes.</p> <p>A full description of the Keccak SM can be found in its individual document here.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#the-textposeidon-state-machine","title":"The \\(\\text{POSEIDON}\\) State Machine","text":"<p>The \\(\\text{POSEIDON}\\) hash function, although newer than the Keccak hash and thus still under the scritiny of cryptanalysts, it has been publicised as a zk-STARK-friendly hash function. As such, it is best-suited for the zkProver context.</p> <p>The \\(\\text{POSEIDON}\\) SM is the most straight forward especially if one is familiar with the internal mechanism of the original Poseidon hash function. </p> <p>The hash function's permutation process translates readily to the state transitions of the \\(\\text{POSEIDON}\\) State Machine. The hash function's twelve (12) input elements, the non-linear substitution layers (the S-boxes) and the linear diffusion layers (the MDS matrices), are directly implemented in the state machine.   </p> <p>Although a secondary state machine, the \\(\\text{POSEIDON}\\) SM receives instructions from both the Main SM and the Storage SM.</p> <p>The \\(\\text{POSEIDON}\\) SM has the executor part and an internal PIL code, which is a set of verification rules, written in the PIL language.</p> <p>A full description of the \\(\\text{POSEIDON}\\) SM can be found in its individual document here.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/Intro-Anthony/#basic-approach-to-proving-execution-correctness","title":"Basic Approach To Proving Execution-Correctness","text":"<p>What follows is an outline of the basic approach to proving that computations were correctly executed in each state machine.</p> <p>The zkProver's state machines are designed to execute programs, as well as to guarantee that these programs are correctly executed.</p> <p>Each secondary state machine therefore consists of its own executor and a PIL program that can be used to check correct execution of all the instructions coming from the Main SM Executor.</p> <p>Here is a step-by-step outline of how the system achieves proof/verification of transactions,</p> <ul> <li>Represent a given computation as a state machine (SM),</li> <li>Express the state changes of the SM as polynomials,</li> <li>Capture traces of state changes, called execution traces, as rows of a lookup table, </li> <li>Form polynomial identities/constraints that these state transitions satisfy, </li> <li>'Prover' uses a specific polynomial commitment scheme to commit and prove knowledge of the committed polynomials,</li> <li>Plookup is one of the ways to check if the Prover's commited polynomials produce correct traces.</li> </ul> <p>While the polynomial constraints are written in the PIL language, the instructions are initially written in zk-assembly but subsequently expressed and stored in JSON format.</p> <p>The above outline of the proof/verification procedure was explained in this blogpost, and further detailed in the documentation here.</p> <p>Although not all verification involves a Plookup, the diagram below, briefly illustrates the wide role Plookup plays in the zkProver.</p> <p></p>  Figure 4: Plookup and the zkProver State Machines"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/","title":"Merkle Tree Specification","text":"<p>This document describes the Merkle Tree that is used. Basic understanding on how Merkle trees and Merkle proofs work is assumed.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#glossary","title":"Glossary","text":"<ul> <li>Key: position of a leaf in the tree.</li> <li>Branch: node of the tree that have children insted of data, e.g: a non-leaf node.</li> <li>Leaf: node of the tree that stores data.</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#topology","title":"Topology","text":"<ul> <li>Hexary (16 child per branch, could be 8 if deemed necessary to reduce complexity in zk circuits).</li> <li>Number of levels doesn't have to be fixed, because STARK allows to compute it dynamically. Max levels is 64 due to key size. At least 32 levels (we may consider using more levels to avoid collisions. Amount of leafs = <code>16**levels</code>. 32 levels ~= 3.4e38).</li> <li>Sparse.</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#keys-and-paths","title":"Keys and Paths","text":"<p>A key is the index of a leaf. They've to be generated in a way that there are no collisions and are deterministic (same leaf always have the same key). Therefore a convinient way to generate keys is by hashing some content of the leaf that uniquely identifies it. Poseidon hash will be used for that purpose (could be changed).</p> <p>A path is a list of directions that enable navigation from root to a given leaf. Paths are derived from keys by taking the last <code>4bits * (Levels-1)</code>, each 4 bit group will represent a number (values 0 to 15) that indicates which is the child of the branch that follows the path to the leaf.</p> <p>Since poseidon hashes output 253,59 bits, and 4 bits are needed to encode each direction, the tree can have a maximum of 64 levels: <code>253.59bits / 4bits = Levels-1</code>.</p> <p>Keys are Finite Field Elements. Values are numbers between \\(0\\) and \\(2^{256}-1\\) (uint256).</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#example","title":"Example","text":"<p>Given a tree with 8 levels (for example purposes, the actual implementation will have at least 32 levels), and the following key, the path will be this:</p> <p>Key (in Little Endian encoding): <code>0x21665a9251173584a82d950b0ea5f3c19297fdce2383ef325d3c01cb30191d10</code></p> <p>Path:</p> direction used bits Root =&gt; L1 0x0 252:256 L1 =&gt; L2 0x1 248:252 L2 =&gt; L3 0xd 244:248 L3 =&gt; L4 0x1 240:244 L4 =&gt; L5 0x9 236:240 L5 =&gt; L6 0x1 232:236 L6 =&gt; L7 0x0 228:232 <p>Graphical representation:</p> <p></p>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#reference-implementation","title":"Reference Implementation","text":"<p>Jordi has done js implementation here: hermeznetwork/zkproverjs</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#example-of-mt-creation","title":"Example of MT Creation","text":"<p>Initially we have an empty MT, that has zero value as a root hash. For the example purpose it has 5 levels and keys are 2 bytes long (4 bits * 4).</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#step-1","title":"Step 1","text":"<p>Adding first leaf to sparse MT:</p> <ul> <li>Key: <code>0x4321</code></li> <li>Value: <code>0x66</code></li> </ul> <p>Leafs:</p> Key (LE) Path Value Real Path Hash 4321 1234 66 - H[1,1234,66,0,0,0,0,0..0] <p>Merkle root hash equals to the hash of the leaf node, which is <code>H[1,1234,66,0,0..0]</code>, since there's no other leaves in the tree. <code>keyPrime</code> equals to Path.</p> <p>Graphical representation:</p> <p></p> <ul> <li>Yellow nodes need (re)calculation</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#step-2","title":"Step 2","text":"<p>Adding second leaf:</p> <ul> <li>Key: <code>0x4421</code></li> <li>Value: <code>0x77</code></li> </ul> <p>Leafs:</p> Path Value Real Path Hash 1234 66 123 H[1,4,66,0,0,0,0..0] 1244 77 124 H[1,4,77,0,0,0,0..0] <p>Graphical representation:</p> <p></p> <ul> <li>Yellow nodes need (re)calculation</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#step-3","title":"Step 3","text":"<p>Adding third leaf:</p> <ul> <li>Key: <code>0x6541</code></li> <li>Value: <code>0x88</code></li> </ul> <p>Leafs:</p> Path Value Real Path Hash 1234 66 123 H[1,4,66,0,0,0,0..0] 1244 77 124 H[1,4,77,0,0,0,0..0] 1456 88 14 H[1,56,88,0,0,0,0..0] <p>Graphical representation:</p> <p></p> <ul> <li>Yellow nodes need (re)calculation</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#step-4","title":"Step 4","text":"<p>Adding fourth leaf:</p> <ul> <li>Key: <code>0x5541</code></li> <li>Value: <code>0x99</code></li> </ul> <p>Leafs:</p> Path Value Real Path Hash 1234 66 123 H[1,4,66,0,0,0,0..0] 1244 77 124 H[1,4,77,0,0,0,0..0] 1455 99 145 H[1,5,99,0,0,0,0..0] 1456 88 145 H[1,6,88,0,0,0,0..0] <p>Graphical representation:</p> <p></p> <ul> <li>Yellow nodes need (re)calculation</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#nodes","title":"Nodes","text":"<p>Hermez 1.5 has 2 categories of nodes:</p> <ul> <li>Leafs: node of the tree that instead of pointing to other nodes, it holds data. There is 4 types of leafs:<ul> <li>Nonce: Counter of transactions made by an account</li> <li>Balance: amount of Ether holded by an account</li> <li>SC code: code of a smart contract</li> <li>SC storage: persistent data stored by a smart contract</li> </ul> </li> <li>Branches: node of the tree that point to other nodes.</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#leafs","title":"Leafs","text":"<p>Generic schema to generate node hash: <code>poseidon.Hash(1, keyPrime, V0, V1, V2, V3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</code> where:</p> <ul> <li><code>keyPrime</code> - is a remaining part of the key, depends on a position of the Leaf in the Tree</li> <li> <p><code>V0, V1, V2, V3</code> - parts of Value split in 64 bit chunks</p> <p> Value, 256 bits MSB LSB 64 bits 64 bits 64 bits 64 bits V3 V2 V1 V0 </p> </li> <li> <p><code>0 ... 0</code> - zero padding to get 16 inputs to poseidon hash in total, in this case 10 additional zero values</p> </li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#branches","title":"Branches","text":"<ul> <li>Value: array of 16 poseidon hashes</li> <li>Key: -</li> <li>Hash: <code>poseidon.Hash(hashChild0, hashChild1, ..., hashChild15)</code></li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#proofs","title":"Proofs","text":"<p>Proofs are very similar to the implementation used in Hermez 1.0.</p>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#proof-of-leaf-inclusion-in-merkle-tree","title":"Proof of Leaf Inclusion in Merkle Tree","text":"<p>This type of proof is needed to prove that a key in Merkle Tree has specific value.</p> <p>Structure of the proof from a reference implementation:</p> <pre><code>{\n    root: root,\n    key: key,\n    value: value,\n    siblings: siblings,\n    isOld0: isOld0, // true if leaf hash is 0\n    insKey: insKey,\n    insValue: insValue,\n}\n</code></pre>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#proof-of-leaf-update","title":"Proof of Leaf Update","text":"<p>This type of proof is needed as an input for the ZKP, to prove the transiction from one state <code>state A</code> to the next one <code>state B</code>.</p> <p>Structure of the proof from a reference implementation:</p> <pre><code>{\n    oldRoot: oldRoot,\n    newRoot: newRoot,\n    key: key,\n    siblings: siblings, // array [level][keys[level]] bytes,\n    insKey: insKey,\n    insValue: insValue,\n    isOld0: isOld0, // true if previous leaf hash was 0\n    oldValue: oldValue,\n    newValue: value,\n}\n</code></pre>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#hermez-specific-leaf-types","title":"Hermez specific Leaf Types","text":""},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#balance","title":"Balance","text":"<ul> <li>Value: unsigned integer of 256 bits</li> <li>Key: key is generated by hashing the Ethereum address and a constant with value 0 using Poseidon: <code>key = poseidon.Hash(ethAddrBytes[0:8], ethAddrBytes[8:16], ethAddrBytes[16:24], 0, 0..0)</code></li> <li>Hash: <code>poseidon.Hash(1, keyPrime, balanceBytes[0:8], balanceBytes[8:16], balanceBytes[16:24], balanceBytes[24:32], 0..0)</code></li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#nonce","title":"Nonce","text":"<ul> <li>Value: unsigned integer of 256 bits</li> <li>Key: key is generated by hashing the Ethereum address and a constant with value 1 using Poseidon: <code>key = poseidon.Hash(ethAddrBytes[0:8], ethAddrBytes[8:16], ethAddrBytes[16:24], 1, 0..0)</code></li> <li>Hash: <code>poseidon.Hash(1, keyPrime, nonceBytes[0:8], nonceBytes[8:16], nonceBytes[16:24], nonceBytes[24:32], 0..0)</code></li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#sc-code","title":"SC Code","text":"<ul> <li>Value: byte array that represents the compiled code</li> <li>Key: key is generated by hashing the Ethereum address and a constant with value 2 using Poseidon: <code>key = poseidon.Hash(1, keyPrime, ethAddrBytes[0:8], ethAddrBytes[8:16], ethAddrBytes[16:24], 2, 0..0)</code></li> <li>Hash: TBD</li> <li>probably by splitting the code into chunks of 15 elements, and hashing the 15 elements and the hash of the previous chunk</li> </ul>"},{"location":"zkEVM/Temporary-Files-Deleteme/tools-optimizations/merkle-tree/#sc-storage","title":"SC storage","text":"<ul> <li>Value: 256 bits that will be interpreted by the SC</li> <li>Key: key is generated by hashing the Ethereum address and a constant with value 3 and the position of the storage that is being accessed: <code>key = poseidon.Hash(ethAddrBytes[0:8], ethAddrBytes[8:16], ethAddrBytes[16:24], 3, storagePositionBytes[0:8], storagePositionBytes[8:16], storagePositionBytes[16:24], storagePositionBytes[24:32], 0..0)</code></li> <li>Hash: <code>poseidon.Hash(1, keyPrime, valueBytes[0:8], valueBytes[8:16], valueBytes[16:24], valueBytes[24:32], 0..0)</code></li> </ul>"},{"location":"zkEVM/zk-Tooling/PIL/Advanced-Features/","title":"Advanced Features","text":"<p>This last section wraps the document by introducing some advanced features that PIL supports, such as permutation checks over multiple (possibly distinct) domains.</p>"},{"location":"zkEVM/zk-Tooling/PIL/Advanced-Features/#public-inputs","title":"Public Inputs","text":"<p>Public inputs are values of a polynomial that are known prior to the execution of a state machine. In the following example, the public input \\(\\texttt{publicInput}\\) is set to be the first element of the polynomial \\(\\texttt{a}\\) and a colon \"\\(:\\)\" is used to indicate this to the compiler (see line 12 in the code excerpt below).</p> <p></p>  Code Excerpt 19: Public Inputs PIL Example  <p>Note here, the use of the Lagrange polynomial \\(L_1\\) to create a constraint,</p> \\[ L_1 \\cdot (\\texttt{a} - :\\texttt{publicInput}) = 0. \\] <p>Whenever relevant, the constraint enforces the value of \\(\\texttt{a}\\) to be equal to \\(\\texttt{publicInput}\\).</p>"},{"location":"zkEVM/zk-Tooling/PIL/Advanced-Features/#permutation-check","title":"Permutation Check","text":"<p>In this example we use the \\(\\texttt{is}\\) keyword to denote that the vectors \\([\\texttt{sm1.a},\\texttt{sm1.b},\\texttt{sm1.c}]\\) and \\([\\texttt{sm2.a}, \\texttt{sm2.b}, \\texttt{sm2.c}]\\) are a permutation of each other, seen as evaluations over the designated domain.</p> <p></p>  Code Excerpt 20: Permutation Check PIL Example  <p>This constraint becomes useful to connect distinct state machines, since it is forcing that polynomials belonging to different state machines are the same (up to permutation).</p>"},{"location":"zkEVM/zk-Tooling/PIL/Advanced-Features/#two-special-functionalities","title":"Two Special Functionalities","text":"<p>Here are some vectors for which the \\(\\texttt{in}\\) and \\(\\texttt{is}\\) functionalities are designed for:</p> \\[\\begin{array}{ccc} (3,2) &amp; \\text{in} &amp; (1,2,3,4)\\\\ (1,5,5,5,8,1,1,2) &amp; \\text{in} &amp; (1,2,4,5,8)\\\\ (3,2,3,1) &amp; \\text{is} &amp; (1,2,3,3)\\\\ (5,5,6,9,0) &amp; \\text{is} &amp; (6,5,9,0,5). \\end{array}\\]"},{"location":"zkEVM/zk-Tooling/PIL/Advanced-Features/#the-connect-keyword","title":"The Connect Keyword","text":"<p>The \\(\\texttt{connect}\\) keyword is introduced to denote that the copy constraint argument is applied to \\([\\texttt{a},\\texttt{b},\\texttt{c}]\\) using the permutation induced by \\([\\texttt{SA}, \\texttt{SB}, \\texttt{SC}]\\).</p> <p></p>  Code Excerpt 21: Connect Keywords PIL Example  <p>Naturally, the previous feature can be used to describe the correctness of an entire PlonK circuit in PIL:</p> <p></p>  Code Excerpt 22: Plonk Circuit in PIL"},{"location":"zkEVM/zk-Tooling/PIL/Advanced-Features/#permutation-check-with-multiple-domain","title":"Permutation Check with Multiple Domain","text":"<p>Another important feature is the possibility to prove that polynomials of distinct state machines are the same (up to permutation) in a subset of its elements. This helps to improve efficiency when state machines are defined over subgroups of distinct size, since without this permutation argument one would need to equal the size of both polynomials.</p> <p>PIL introduces this possibility by the introducing selectors that choose the subset of elements to be included in the permutation argument.</p> <p></p>  Code Excerpt 23: Permutation Argument in PIL  <p>Any combination of \\(\\texttt{sel}\\), \\(\\texttt{not sel}\\) and \\(\\texttt{in}\\), \\(\\texttt{is}\\) are available as permutation arguments. This leads to a total of \\(4\\) possibilities.</p> <p>Figure 18 depicts an example of the permutation multi-domain protocol, with one selector per table, that is, we prove that:</p> \\[ \\text{sel } \\cdot [a,b,c] = \\sigma\\left(\\text{sel' } \\cdot [d,e,f]\\right). \\] <p></p>  Figure 18: Permutation Multi-Domain Protocol"},{"location":"zkEVM/zk-Tooling/PIL/Components/","title":"Components","text":"<p>The aim with this section is to explain most of the PIL components in-depth.</p>"},{"location":"zkEVM/zk-Tooling/PIL/Components/#namespaces","title":"Namespaces","text":"Code Excerpt 6: PIL Namespace File  <p>State machines in PIL are organized in namespaces. Namespaces are written with the keyword \\(\\texttt{namespace}\\) followed by the name of the state machine, and they can optionally include other parameters. In the previous snippet, a state machine called \\(\\texttt{Name}\\) is created.</p> <p>The namespace keyword opens a workspace for the developer to englobe all the polynomials and identities of a single state machine. Every component of a state machine is included within its namespace. There is a one-to-one correspondence between state machine and namespaces.</p> <p>The same name cannot be used twice between state machines that are directly or indirectly related, since this would cause an overlap in the lookup arguments and the compiler would not be able to decide.</p> <p>So, for instance the following two examples are not allowed,</p> <p></p>  Code Excerpt 7: PIL No Common Names"},{"location":"zkEVM/zk-Tooling/PIL/Components/#polynomials","title":"Polynomials","text":"Code Excerpt 8: PIL Constant and Committed Polynomials  <p>Polynomials are the key component of PIL. Values of polynomials have to be compared with computational trace's columns. In fact, in PIL, the two are considered to be the same thing. More precisely, polynomials are just the interpolation of the columns over all the rows of the computational trace.</p> <p>Every polynomial is prefixed with the keyword \\(\\texttt{pol}\\) and needs to be explicitly set to be either a constant (also known as preprocessed) or committed. Polynomials fall into these two categories depending on the origin of their creation or how they are going to be used. Consequently, in PIL there exist two keywords to denote the two types of polynomials: \\(\\texttt{constant}\\) and \\(\\texttt{commit}\\).</p>"},{"location":"zkEVM/zk-Tooling/PIL/Components/#constant-polynomials","title":"Constant Polynomials","text":"Code Excerpt 9: A Constant in PIL  <p>Constant polynomials, also known in the literature as preprocessed polynomials, are polynomials known prior to the execution of the state machine. They correspond to polynomials that do not change during the execution, and are known to both the prover \\(\\mathcal{P}\\) and the verifier \\(\\mathcal{V}\\) prior to execution. They can be thought of as the preprocessed polynomials of an arithmetic circuit.</p> <p>A typical use of these polynomials is in the inclusion of selectors, latches and sequencers. A constant polynomial is created or initialize as a polynomial with the keyword \\(\\texttt{constant}\\). And it is typically written in uppercase. This is good practice as it helps to differentiate them from the committed ones.</p>"},{"location":"zkEVM/zk-Tooling/PIL/Components/#committed-polynomials","title":"Committed Polynomials","text":"Code Excerpt 9: A Constant in PIL  <p>Committed polynomials are not known prior to the execution of the state machine. They are analogous to variables because their values change during execution, and are only known to the prover \\(\\mathcal{P}\\). In order to create a committed polynomial, simply prefix the polynomial in question with the keyword \\(\\texttt{committed}\\) (in the same way a variable-type is declared in standard programming languages).</p> <p>These polynomials are typically divided between input polynomials and state variables. Although they are instantiated in the usual way, their purpose is completely different in the PIL context.</p> <p>Free Input Polynomials</p> <p>Free input polynomials are used to introduce data to the state machines. Each individual state machine applies its specific logic over the data introduced by these polynomials when executing computations. The data is considered the output of some state transition (or the output of the state machine, if it is the last transition). Also, free input polynomials are introduced by the prover, yet they are unknown to the verifier. They are therefore labelled, and prefixed, as \\(\\texttt{committed}\\).</p> <p>State Variables</p> <p>State variables are a set of values considered to be the state of the state machine. These polynomials play a pivotal role in the state machines, which is to help the prover focus on the correct evolution of the state variables during the generation of a proof.</p> <p>The output of the computation in each state transition is included in the state variables. The state of the state variables in the last transition is the \\(\\textit{output}\\) of the computation.</p> <p>State variables depend on the input and the constant polynomials. They are also therefore labelled as committed.</p>"},{"location":"zkEVM/zk-Tooling/PIL/Components/#polynomial-element-types","title":"Polynomial Element Types","text":"Code Excerpt 10: Types of Polynomial Element  <p>A polynomial definition can also contain a keyword indicating the type of elements a polynomial is composed of. Types include, for instance, \\(\\texttt{bool}\\), \\(\\texttt{u16}\\), \\(\\texttt{field}\\).</p> <p>The type is strictly informative. This means that to enforce the elements of some polynomial to be restricted over some smaller domain, one should include a constraint reflecting the bounds.</p>"},{"location":"zkEVM/zk-Tooling/PIL/Components/#constraints","title":"Constraints","text":"<p>The set of constraints is one of the most important part of a PIL code. The constraints are defined to be the set of relations between polynomials that dictate the correct evolution of the state machine at every step. A state machine does what it does because the set of constraints enforces such a behavior.</p> <p></p>  Code Excerpt 11: Polynomial Constraints  <p>Constraints can generally be of the following types (to be changed),</p> <p></p>  Code Excerpt 12: The Main Polynomial Constraints"},{"location":"zkEVM/zk-Tooling/PIL/Cyclical-Nature/","title":"Cyclical Nature","text":"<p>There is one implicit complexity in the design of state machines:</p> \\[ \\textbf{State machines should have a cyclical nature.} \\] <p>This means the description (in terms of constraints) of a state machine is not correct if the appropriate constraints are not satisfied in every row transition. In particular, this should remain true in the transition from the last row to the first row. This is an important aspect that has to be taken care of when designing the set of constraints of a state machine.</p> <p></p>  Figure 10: Cyclic Nature of State Machines  <p>If there is some constraint that is not satisfied in the last transition, one normally overcomes this problem by adding artificial values in latter evaluations of some polynomials.</p> <p>For example, consider the following state machine with its respective computational trace.</p> <p></p>  Code Excerpt 13: State Machine Example  <p>Clearly, the constraint \\(b' = b+a\\) is not satisfied in the last transition: \\((a,b) = (1,2)\\) to \\((a,b) = (1,1)\\).</p> <p>This can be solved by appending two extra rows. Figure 11 shows how this can be performed in the previous example.</p> <p></p>  Figure 11: Inducing a Cyclic Nature  <p>Another option would be the introduction of a selector:</p> <p></p>  Code Excerpt 14: State Machine Example  <p>As it can be seen in the above code excerpt, now the cost of adding extra rows has been substituted by the addition of the selector \\(\\texttt{SEL}\\).</p> <p>A third option (when possible) is taking advantage of some existing selectors to accommodate latter values.</p>"},{"location":"zkEVM/zk-Tooling/PIL/Hello-World-Examples/","title":"Hello Word Examples","text":"<p>In this section, an exploration of some state machine examples is presented.</p>"},{"location":"zkEVM/zk-Tooling/PIL/Hello-World-Examples/#state-machine-that-multiplies-two-numbers","title":"State Machine that Multiplies Two Numbers","text":"<p>Consider a state machine that takes two input numbers \\(x\\) and \\(y\\), and multiplies them. Hence call the state machine, the Multiplier state machine, described by the function;</p> \\[ f(x,y) = x \\cdot y. \\] <p>Table 5 below, shows the computational trace on various inputs.</p> <p>As it can be observed, the input to this computation is fed into the two free input polynomials, \\(\\texttt{freeIn}_1\\) and \\(\\texttt{freeIn}_2\\), and the output of this computation is set to the output polynomial \\(\\texttt{out}\\), which contains the product of the free input polynomials.</p> <p></p>  Table 5: Computational Trace for the Multiplier State Machine  <p>The nature of the previous polynomials suggests the following classification,</p> <ul> <li>\\(\\textbf{Free Input Polynomials}\\). These are polynomials which are in charge of introducing the various inputs to the computation.They are referred to as \"free\" because at every clocking of the computation their values do not strictly depend on any previous iteration. These are analogous to independent variables of the entire computation.</li> <li>\\(\\textbf{State Variables}\\). These are the polynomials that compose the state of the state machine. Here state refers to the set of values that represent the output of the state machine at each step and, if we are in the last step, the output of the entire computation.</li> </ul> <p>Figure 6 below provides a diagram of this division.</p> <p></p>  Figure 6: Multiplier State Machine with the distinct polynomials  <p>In order to achieve correct behaviour of this state machine, one obvious constraint that must be satisfied is,</p> \\[ \\texttt{out} = \\texttt{freeIn}_1 \\cdot \\texttt{freeIn}_2. \\] <p>In PIL, all the components (polynomials and identities) of this state machine are introduced as shown in the code snippet below:</p> <p></p>  Code Excerpt 1: Components of PIL  <p>The problem with this design is that the number of committed polynomials grows linearly with the number of multiplications; so that, if we would have to compute a huge number of (possibly distinct) operations, the number of free input polynomials would be unnecessarily big.</p> <p>Reduction of the number of free input polynomials can be achieved by introducing constant polynomials. These are preprocessed inputs to the state machine. That is, polynomials known prior to the execution of the computation and used as selectors, latches or sequencers, among other roles. Figure 7 below, is an updated version of Figure 6 above. The difference being an addition of constants.</p> <p></p>  Figure 6: Multiplier State Machine with the Constant Polynomials  <p>Table 8 shows the computational trace for the optimized Multiplier state machine.</p> <p></p>  Table 6: State Machine with the Constant Polynomials  <p>Now, the two inputs to this computation are sequentially fed into the only free input polynomial \\(\\texttt{freeIn}\\). In the first step, the first input \\(x=4\\) is moved from \\(\\texttt{freeIn}\\) to \\(\\texttt{out}\\). In the second step, \\(x\\) is multiplied by the second input \\(y=2\\), and the result is set to be in \\(\\texttt{out}\\).</p> <p>In order to achieve the correctness of this new version, the previous constraint is changed so that the constant polynomial \\(\\texttt{SET}\\) helps in achieving the desired behavior:</p> \\[ \\texttt{out}' = \\texttt{SET} \\cdot \\texttt{freeIn} + (1 - \\texttt{SET}) \\cdot (\\texttt{out} \\cdot \\texttt{freeIn}). \\] <p>Notice how the \\(\\texttt{SET}\\) polynomial helps out with the branching. On the one hand, whenever \\(\\texttt{SET}\\) is set to \\(1\\), then \\(\\texttt{freeIn}\\) is moved to the next value of \\(\\texttt{out}\\). While on the other hand, when \\(\\texttt{SET}\\) is set to \\(0\\), then the stored value in \\(\\texttt{out}\\) is multiplied by the actual value of \\(\\texttt{freeIn}\\), which corresponds to the second input to the computation.</p> <p>Note that as a convention, a tick \\('\\) (which is read \"prime\") is used to denote the \"next\" iteration.</p> <p>In the case of polynomials defined over the roots of unity, this notation translates to,</p> \\[ f'(X) := f(\\omega X). \\] <p>In PIL, the optimized Multiplier is implemented as follows,</p> <p></p>  Code Excerpt 2: Optimised Multiplier State Machine"},{"location":"zkEVM/zk-Tooling/PIL/Hello-World-Examples/#a-state-machine-that-generates-4-byte-numbers","title":"A State Machine that Generates 4-Byte Numbers","text":"<p>Consider now building a state machine that takes two \\(2\\)-byte numbers and generates a \\(4\\)-byte number from them. Since the logic of this state machine is similar to the previous one, the number of polynomials (and its meaning) is also the same. In the first step, the first input \\(x\\) is moved from \\(\\texttt{freeIn}\\) to \\(\\texttt{out}\\). In a second step, \\(x\\) is concatenated to the second input \\(y\\) and set to be in \\(\\texttt{out}\\).</p> <p>Table 9 shows the computational trace for a Byte4 state machine.</p> <p></p>  Table 9: Computational Trace for the Byte4 State Machine  <p>For the purpose of displaying PIL's new features, the Byte4 state machine is built in a modular manner as illustrated next.</p> <p>First, deploy the configuration file, called config.pil, which is typically used to include some configuration-related components, shared among various state machines. In the example below, this configuration file will include the definition of a constant \\(N\\) representing the upper bound for the number of rows to be used across various state machines.</p> <p></p>  Code Excerpt 3: PIL Configuration File for the Byte4 State Machine  <p>Second, use the Global state machine. This state machine is used to store various polynomials representing \"small\" lookup tables, to be used by other state machines. For instance, defining the Lagrange polynomial \\(L_1\\) or the polynomial representing the set of \\(1\\)-byte numbers. As we have set this state machine to have size \\(N\\), there are some polynomials that need to be accommodated in size.</p> <p></p>  Code Excerpt 4: PIL Global File for the Byte4 State Machine  <p>Third, and finally, the Byte4 state machine is completed. Similar to the previous example, the constraint that needs to be satisfied is the following:</p> \\[ \\texttt{out}' = \\texttt{SET} \\cdot \\texttt{freeIn} + (1 - \\texttt{SET}) \\cdot (2^{16} \\cdot \\texttt{out} + \\texttt{freeIn}). \\] <p>Note how the product \\(2^{16} \\cdot \\texttt{out}\\) forces the state machine to allocate the value from \\(\\texttt{out}\\) at the upper part of the result, while the addition of \\(\\texttt{freeIn}\\) allocates them at the lower part of the result.</p> <p>This state machine is implemented in PIL as follows:</p> <p></p>  Code Excerpt 5: The Byte4 State Machine PIL File"},{"location":"zkEVM/zk-Tooling/PIL/Introduction/","title":"Introduction","text":"<p>Polynomial Identity Language (PIL) is a novel domain-specific language useful for defining state machines. The aim for creating PIL is to provide developers a holistic framework for both constructing state machines through an easy-to-use interface, and abstracting the complexity of the proving mechanisms. One of the main peculiarities of PIL is its modularity, which allows programmers to define parametrizable state machines, called namespaces, which can be instantiated from larger state machines. Building state machines in a modular manner makes it easier to test, review, audit and formally verify even large and complex state machines. In this regard, by using PIL, developers can create their own custom namespaces or instantiate namespaces from some public library.</p> <p>Some of the keys features of PIL are;</p> <ul> <li>Providing \\(\\texttt{namespaces}\\) for naming the essential parts that constitutes state machines.</li> <li>Denoting whether the polynomials are \\(\\texttt{committed}\\) or \\(\\texttt{constant}\\).</li> <li>Expressing polynomial relations, including \\(\\texttt{identities}\\) and \\(\\texttt{lookup arguments}\\).</li> <li>Specifying the type of a polynomial, such as \\(\\texttt{bool}\\) or \\(\\texttt{u32}\\).</li> </ul>"},{"location":"zkEVM/zk-Tooling/PIL/Introduction/#state-machines-the-computational-model-behind-pil","title":"State Machines: The Computational Model Behind PIL","text":"<p>Many other domain-specific languages (DSL) or toolstacks, such as Circom or Halo2, focus on the abstraction of a particular computational model, such as an arithmetic circuit.</p> <p>Arithmetic circuits arise naturally in the context of succinct interactive protocols and are therefore an appropriate representation in the context of PIL.</p> <p>Arithmetic circuits are covered by developer tools generally in two ways, either in the vanilla PlonK Style or the PlonKish Style. See Figure 1 for a high-level description of these two styles and how they differ.</p> <p></p>  Figure 1: Vanilla PlonK vs PlonKish Circuit Representation Style  <p>However, recent proof systems such as STARKs have shown that arithmetic circuits might not be the best computational models in all use-cases. Given a complete programming language, computing a valid proof for a circuit satisfiability problem, may result in long proving times due to the overhead of re-used logic. Opting for deployment of state machines, with their low-level programming, shorter proving times are attainable especially with the advent of proof/verification-aiding languages such as PIL.</p> <p>Figure 2 below, provides a high-level description of a state machine architecture. A typical state machine takes some input and produces the corresponding output, according to the Arithmetic-Logic Unit (ALU). This ALU is the very core of the state machine as it determines the internal state of the state machine, as well as the values of its output.</p> <p></p>  Figure 2: Architectural view of a State Machine  <p>Figure 3 and 4 show the comparison between the design of circuits and state machines in various natural scenarios. The former makes a comparison in the case of a program with a looping nature, and the latter shows a program with a branching nature.</p> <p></p>  Figure 3: Circuit and state machine comparison in a loop-based computation  <p></p>  Figure 4: Circuit and State Machine comparison in a branch-based computation"},{"location":"zkEVM/zk-Tooling/PIL/Modularity/","title":"Modularity","text":"<p>Although several polynomials could be added to the above state machine so as to express more operations, it would only make the design hard to test, audit or formally verify.</p> <p>In order to avoid this complication, PIL lets one use a divide and conquer technique:</p> <p>(a) Instead of developing one (big) state machine, a typical architecture consists of different state machines.</p> <p>(b) Each state machine is devoted to proving the execution of a specific task, each with its own set of constraints.</p> <p>(c) Then, relevant polynomials on different state machines are related and compared using lookup tables or permutation arguments.</p> <p>(d) This guarantees consistency as if it would have been a single state machine.</p> <p>PIL is therefore best suited for a modular design of state machines.</p> <p>Figure 12 depicts a connection between the polynomials \\([a,b,c]\\) and \\([d,e,f]\\).</p> <p></p>  Figure 12: Polynomial Connections Across State Machines  <p>To illustrate this process,</p> <ol> <li>First, design a state machine to manage arithmetic operations over \\(2\\)-byte elements.</li> <li>Then, connect this state machine with another state machine (that needs to perform arithmetic operations) via a lookup argument.</li> </ol>"},{"location":"zkEVM/zk-Tooling/PIL/Modularity/#the-arithmetic-state-machine","title":"The Arithmetic State Machine","text":"<p>The Arithmetic State Machine is in charge of checking that some arithmetic operations like additions and multiplications are correctly performed over \\(2\\)-byte elements. For this, the polynomials; \\(\\texttt{a}\\), \\(\\texttt{b}\\), \\(\\texttt{c}\\), \\(\\texttt{d}\\), and \\(\\texttt{e}\\); must satisfy the identity:</p> \\[ \\texttt{a}(X) \\cdot \\texttt{b}(X) + \\texttt{c}(X) = 2^{16} \\cdot \\texttt{d}(X) + \\texttt{e}(X). \\] <p>Notice the following,</p> <p>(a) The multiplication between \\(\\texttt{a}\\) and \\(\\texttt{b}\\), which are \\(2\\)-byte elements, can be expressed with \\(\\texttt{e}\\) and \\(\\texttt{d}\\), where these are also \\(2\\)-byte elements.</p> <p>(b) Enforce that all the evaluations of \\(\\texttt{a}\\), \\(\\texttt{b}\\), \\(\\texttt{c}\\), \\(\\texttt{d}\\) and \\(\\texttt{e}\\) are \\(2\\)-byte elements.</p> <p></p>  Figure 13: Architecture of the Arithmetic State Machine  <p>Figure 13 shows how the Arithmetic State Machine is designed. And, Tableb14 displays an example of how the computational trace looks like.</p> <p></p>  Table 14: Computational Trace of the Arithmetic State Machine  <p>The Arithmetic state machine works as follows. \\(\\texttt{LATCH}\\) is used to flag when the operation is ready. Note that \\(\\texttt{SET}[A]\\), \\(\\texttt{SET}[B]\\), \\(\\texttt{SET}[C]\\), \\(\\texttt{SET}[D]\\), \\(\\texttt{SET}[E]\\) and \\(\\texttt{LATCH}\\) are constant polynomials. \\(\\texttt{freeIn}\\) is committed, and contains the values on which arithmetic operations are performed. Polynomials \\(\\texttt{a}\\), \\(\\texttt{b}\\), \\(\\texttt{c}\\), \\(\\texttt{d}\\) and \\(\\texttt{e}\\) compose the state variables.</p> <p>The polynomial identities that define the Arithmetic State Machine are as follows:</p> \\[ \\begin{aligned} &amp;\\texttt{freeIn} \\subset [0,2^{16} - 1], \\\\ \\texttt{a}' &amp;= \\texttt{SET}[A]\\cdot(\\texttt{freeIn} - \\texttt{a}) + \\texttt{a}, \\\\ \\texttt{b}' &amp;= \\texttt{SET}[B]\\cdot(\\texttt{freeIn} - \\texttt{b}) + \\texttt{b}, \\\\ \\texttt{c}' &amp;= \\texttt{SET}[C]\\cdot(\\texttt{freeIn} - \\texttt{c}) + \\texttt{c}, \\\\ \\texttt{d}' &amp;= \\texttt{SET}[D]\\cdot(\\texttt{freeIn} - \\texttt{d}) + \\texttt{d}, \\\\ \\texttt{e}' &amp;= \\texttt{SET}[E]\\cdot(\\texttt{freeIn} - \\texttt{e}) + \\texttt{e}, \\\\ 0 &amp;= [ \\texttt{a} \\cdot \\texttt{b} + \\texttt{c} - (2^{16} \\cdot \\texttt{d} + \\texttt{e}) ] \\cdot \\texttt{LATCH}. \\end{aligned} \\] <p>These are included in PIL as shown in the code excerpt below.</p> <p></p>  Code Excerpt 15: PIL Example"},{"location":"zkEVM/zk-Tooling/PIL/Modularity/#the-main-state-machine","title":"The Main State Machine","text":"<p>The Main State Machine is in charge of some (major) tasks, but will specifically use the Arithmetic SM when Arithmetic operations needs to be performed over certain values.</p> <p></p>  Figure 15: The Main State Machine Architecture  <p>Hence, the first task in PIL is to introduce the various polynomials. It looks as follows,</p> <p></p>  Code Excerpt 15: Arithmetic State Machine PIL Example  <p>if some polynomial is intended to be boolean, then a constraint that reflects so must be added.</p> <p></p>  Code Excerpt 16: PIL Example with Added Constraint  <p>Now, add various constraints regarding the evolution of the \"main\" state variables \\(a\\), \\(b\\), \\(c\\), \\(d\\) and \\(e\\), so that any kind of linear combination between the main state variables, the free input and any constant is subject to be moved in the next iteration of some (or all) the state variables. Figure 16 shows a diagram of the desired behavior.</p> <p></p>  Figure 16: Boolean Polynommials in the Main State Machine  <p>In PIL, it translates to the following:</p> <p></p>  Code Excerpt 17: Verification of Basic Registry Operations  <p>Finally, the constraints reflecting the relationship between the Main and the Arithmetic SMs can be checked.</p> <p></p>  Code Excerpt 18: PIL Example Connect Main and Arithmetic SMs  <p>The connections can be depicted in terms of tables, as Figure 17 below,</p> <p></p>  Figure 17: Connecting Arithmetic and Main State Machines  <p>On the one side, the \\(\\texttt{arith}\\) selector is used in the Main SM to point to this state machine when an arithmetic lookup have to be performed. On the other side, the \\(\\texttt{LATCH}\\) selector, which also works as a selector for which rows should be added in the lookup argument is used. And, as illustrated in Figure 17 above, this proves that,</p> \\[\\begin{array}{c} \\texttt{Main.arith} \\cdot [\\texttt{Main.a} , \\texttt{Main.b} , \\texttt{Main.c} , \\texttt{Main.d}, \\texttt{Main.e}] \\\\ \\subset \\\\ \\texttt{Arith.LATCH} \\cdot [\\texttt{Arith.a}, \\texttt{Arith.b}, \\texttt{Arith.c}, \\texttt{Arith.d}, \\texttt{Arith.e}]. \\end{array}\\]"},{"location":"zkEVM/zk-Tooling/PIL/Related-Repos/","title":"Related Repositories","text":"<ul> <li>A compiler that compiles the PIL description to a JSON file that can be read by the  zkExecutor and the zkProver can be found at this repository.</li> </ul>"},{"location":"zkEVM/zk-Tooling/zkASM/Basic-Syntax/","title":"Basic Syntax","text":"<p>This section is devoted to explain the basic syntax of zkASM from a high-level point of view. Advanced syntax is totally dependendant of the use case (e.g. the design of a zkEVM) and will be explained in more detail with more complete examples in a latter section.</p> <p>It is important to remark that each instruction of the zkASM is executed sequentially (the exception being the execution of a jump) one after the other. Instructions are depicted line by line and are divided in two parts. The left side part includes the part of the code that is actually gets executed in the corresponding file, while the right part is related to the execution of opcodes, jumps and subrutines, which is indicated by the colon \"\\(:\\)\" symbol.</p>"},{"location":"zkEVM/zk-Tooling/zkASM/Basic-Syntax/#comments-and-modules","title":"Comments and Modules","text":"<p>Comments are made with the semicolon \"\\(;\\)\" symbol.</p> <pre><code>; This a totally useful comment\n</code></pre> <p>At this moment, only one-line comments are available.</p> <p>One can subdivide the zkASM code into multiple files and import code with the <code>INCLUDE</code> keyword. This is what we refer to as the modularity of the zkASM.</p> <pre><code>; File: main.zkasm\n\nINCLUDE \"utils.zkasm\"\nINCLUDE \"constants.zkasm\"\n; -- code --\n</code></pre>"},{"location":"zkEVM/zk-Tooling/zkASM/Basic-Syntax/#storing-values-on-registers","title":"Storing Values on Registers","text":"<p>There are many ways in which values can be stored into registers:</p> <ol> <li> <p>Assign a constant into one or more registers is made using the arrow operator \"=&gt;\".</p> <pre><code>0 =&gt; A,B\n</code></pre> </li> <li> <p>Similarly, we can store the value of a register into other registers.</p> <pre><code>A =&gt; B,C\n</code></pre> <p>More generally, we can store the value of a function \\(f\\) of registers.</p> <pre><code>f(A,B) =&gt; C,D\n</code></pre> </li> <li> <p>We can also store a global variable into some register.</p> <pre><code>%GLOBAL_VAR =&gt; A,B\n</code></pre> </li> <li> <p>The result of executing an executor method can also be stored into one or more registers. The indication of such an execution is done with the dollar \"$\" sign, which should be treated as a free input.</p> <pre><code>${ExecutorMethod(params)} =&gt; A,B\n</code></pre> <p>Notice that the method <code>ExecutorMethod</code> does not necessarily depends on the registers. An good example of such a method is <code>SHA256</code>.</p> </li> <li> <p>If a method gets executed (with the dollar sign) by its own, its main purpose is generating log information.</p> <pre><code>${ExecutorMethod(params)}\n</code></pre> </li> <li> <p>Apart from executor methods, one can also use inline functions. This functions, which are also instantiated by the executor, are simply \"short\" and non-reused executor methods.</p> <pre><code>${A &gt;&gt; 2} =&gt; B\n${A &amp; 0x03} =&gt; C\n</code></pre> </li> </ol>"},{"location":"zkEVM/zk-Tooling/zkASM/Basic-Syntax/#introducing-opcodes","title":"Introducing Opcodes","text":"<p>Until this point, every instruction consisted in a direct interaction with the registers. Now, we move one step forward and we obtain interaction with other parts of the ROM thank to the introduction of the zkEVM opcodes.</p> <p>To assign the output of a zkEVM opcode into some register we use the following syntax:</p> <pre><code>$ =&gt; A,B    :OPCODE(param)\n</code></pre> <p>A clear example of such situation is when using the memory load opcode:</p> <pre><code>$ =&gt; A,B    :MLOAD(param)\n</code></pre> <p>When a registers appear at the side of an opcode, it is typically used to indicate that the value of the register <code>A</code> is the input of the memory store opcode:</p> <pre><code>A   :MSTORE(param)\n</code></pre> <p>Similarly, we can assign a free input into a register and later on execute several zkEVM opcodes using the following syntax:</p> <pre><code>${ExecutorMethod(params)} =&gt; A      :OPCODE1\n                                    :OPCODE2\n                                    :OPCODE3\n                                    ...\n</code></pre> <p>When a executor method with a register to store its result gets combined with a jump opcode is typically to handle some unexpected situation, such as running out of gas:</p> <pre><code>${ExecutorMethod(params)} =&gt; A :JMP(param)\n</code></pre> <p>It is also typicall to encounter negative jumps to check appropiate situations in which carry on forthcoming operations:</p> <pre><code>SP - 2  :JMPN(stackUnderflow)\n</code></pre>"},{"location":"zkEVM/zk-Tooling/zkASM/Basic-Syntax/#code-injection","title":"Code Injection","text":"<p>Inline javascript-based instruction can be injected in plain by using the doble dollar \"$\" symbol.</p> <pre><code>$${CODE}\n</code></pre> <p>The main difference between the single dollar sign and the doble dollar sign is that while the methods inside the single dollar sign come from the Executor, the doble dollar ones do not: its is plain javascript code that is executed by the ROM.</p>"},{"location":"zkEVM/zk-Tooling/zkASM/Basic-Syntax/#asserts","title":"Asserts","text":"<p>Asserts work by comparing what is being asserting with what the value on register <code>A</code>. So, for instance, the following instructions compares the value inside register <code>B</code> with the value inside register <code>A</code>:</p> <pre><code>B    :ASSERT\n</code></pre>"},{"location":"zkEVM/zk-Tooling/zkASM/Introduction/","title":"Introduction","text":"<p>Ethereum is a state machine that transition from an old state to a new state by reading a series of transactions. It is a natural choice, in order to interpret the set of EVM opcodes, to design another state machine as for the interpreter. One should think of it as building a state machine inside another state machine, or more concretely, building an Ethereum inside the Ethereum itself. The distinction here is that the former contains a virtual machine, the zkEVM, that is zero-knowledge friendly.</p>"},{"location":"zkEVM/zk-Tooling/zkASM/Introduction/#the-zkevm-as-a-microprocessor","title":"The zkEVM as a Microprocessor","text":"<p>Following the previous discussion, it is good to see the outer state machine as a microprocessor. What we have done is creating a microprocessor, composed by a series of assembly instructions and its associate program (i.e., the ROM) running on top of it, that interprets the EVM opcodes.</p> <p></p>  Figure 1: Block diagram of a basic uniprocessor-CPU computer. Black lines indicate data flow, whereas red lines indicate control flow; arrows indicate flow directions.  <p>As in input, the microprocessor will take the transactions that we want to process and the old state. After fetching the input, the ROM is used to interpret the transactions and generate a new state (the output) from them.</p> <p></p>  Figure 2: Block diagram of a basic machine cycle."},{"location":"zkEVM/zk-Tooling/zkASM/Introduction/#the-role-of-the-zkasm","title":"The Role of the zkASM","text":"<p>The zero-knowledge Assembly (zkASM) is the language used to describe, in a more abstract way, the ROM of our processor. Specifically, this ROM will tell the Executor how to interpret the distinct types of transactions that it could possibly receive as an input. From this point, the Executor will be capable of generating a set of polynomials will describe the state transition and will be later on used by the STARK generator to generate a prove of correctness of this transition.</p> <p></p>  Figure 3: Big picture of the Prover in the zkEVM project, with focus in the zkASM part."},{"location":"zkEVM/zk-Tooling/zkASM/Related-Repos/","title":"Related Repositories","text":"<ul> <li> <p>The ROM for the EVM can be found at this repository. </p> </li> <li> <p>A compiler that compiles the zkASM program to a JSON file that can be read by the  executor can be found at this repository.</p> </li> <li> <p>The assembly for the EC Recover can be found at this repository. </p> </li> </ul>"},{"location":"zkEVM/zk-Tooling/zkASM/Some-Examples/","title":"Some Examples","text":"<p>This section serves as a compendium of useful examples.</p>"},{"location":"zkEVM/zk-Tooling/zkASM/Some-Examples/#evm-add","title":"EVM ADD","text":"<p>Let's take the EVM ADD opcode as our first introductional example:</p> <pre><code>opADD:\n    SP - 2          :JMPN(stackUnderflow)\n    SP - 1 =&gt; SP\n    $ =&gt; A          :MLOAD(SP--)\n    $ =&gt; C          :MLOAD(SP)\n\n    ; Add operation with Arith\n    A               :MSTORE(arithA)\n    C               :MSTORE(arithB)\n                    :CALL(addARITH)\n    $ =&gt; E          :MLOAD(arithRes1)\n    E               :MSTORE(SP++)\n    1024 - SP       :JMPN(stackOverflow)\n    GAS-3 =&gt; GAS    :JMPN(outOfGas)\n                    :JMP(readCode)\n</code></pre> <p>Let us explain in detail how the ADD opcode gets interpreted by us. Recall that at the beginning the stack pointer is pointing to the next \"empty\" address in the stack:</p> <ol> <li> <p>First, we check if the stack is filled \"properly\" in order to carry on the ADD operation. This means that, as the ADD opcode needs two elements to operate, it is checked that these two elements are actually in the stack:</p> <pre><code>SP - 2          :JMPN(stackUnderflow)\n</code></pre> <p>If less than two elements are present, then the <code>stackUnderflow</code> function gets executed.</p> </li> <li> <p>Next, we move the stack pointer to the first operand, load its value and place the result in the <code>A</code> register. Similarly, we move the stack pointer to the next operated, load its value and place the result in the <code>C</code> register.</p> <pre><code>SP - 1 =&gt; SP\n$ =&gt; A          :MLOAD(SP--)\n$ =&gt; C          :MLOAD(SP)\n</code></pre> </li> <li> <p>Now its when the operation takes place. We perform the addition operation by storing the value of the registers <code>A</code> and <code>C</code> into the variables <code>arithA</code> and <code>arithB</code> and then we call the subrutine <code>addARITH</code> that is the one in charge of actually performing the addition.</p> <pre><code>A               :MSTORE(arithA)\nC               :MSTORE(arithB)\n                :CALL(addARITH)\n$ =&gt; E          :MLOAD(arithRes1)\nE               :MSTORE(SP++)\n</code></pre> <p>Finally, the result of the addition gets placed into the register <code>E</code> and the corresponding value gets placed into the stack pointer location; moving it forward afterwise.</p> </li> <li> <p>A bunch of checks are performed. It is first checked that after the operation the stack is not full and then that we do not run out of gas.</p> <pre><code>1024 - SP       :JMPN(stackOverflow)\nGAS-3 =&gt; GAS    :JMPN(outOfGas)\n                :JMP(readCode)\n</code></pre> <p>Last but not least, there is an instruction indicating to move forward to the next intruction.</p> </li> </ol>"},{"location":"zkEVM/zkNode/Bridge/Introduction/","title":"Introduction","text":"<p>Welcome to Polygon zkEVM documentation.</p> <p>We emphasise that this documentation is still Work In Progress (WIP). Some aspects have been covered in more detail, while others still need further expansion. Also, sections of this documentation might later be reorganized in order to achieve better flow.</p> <p>This section will explain how the bridge of the polygon zkEVM network works, but it is still in the TODO list.</p>"},{"location":"zkEVM/zkNode/Proof-of-Efficiency/Introduction/","title":"Introduction","text":"<p>Welcome to Polygon zkEVM documentation.</p> <p>We emphasise that this documentation is still Work In Progress (WIP). Some aspects have been covered in more detail, while others still need further expansion. Also, sections of this documentation might later be reorganized in order to achieve better flow.</p> <p>This section will explain how the new Proof of Efficiency Protocol works, but it is still in the TODO list.</p>"},{"location":"zkEVM/zkProver/Debug/","title":"Debug","text":""},{"location":"zkEVM/zkProver/Debug/#zkprover-debugging","title":"zkProver debugging","text":"<ul> <li>zkProver debugging<ul> <li>Repositories involved</li> <li>Setup environment</li> <li>Executor insights</li> <li>VSCode debugging</li> <li>Debugging tips</li> <li>Table rom assembly instructions</li> <li>Examples assembly<ul> <li>MSTORE</li> <li>MREAD</li> <li>LOAD FROM STORAGE</li> <li>WRITE TO STORAGE</li> </ul> </li> </ul> </li> </ul>"},{"location":"zkEVM/zkProver/Debug/#repositories-involved","title":"Repositories involved","text":"<ul> <li>zkproverjs: prover reference implementation writen in javascript</li> <li>zkproverc: prover implementation writen in C</li> <li>zkasm: compiles .zkasm to a json ready for the zkproverjs</li> <li>zkpil: Polynomial Identity Language</li> <li>zkvmpil: PIL source code for the zkVM (state-machines)</li> <li>zkrom: zkasm source code of the zkEVM</li> <li>zkevmdoc: docs zkevm</li> </ul>"},{"location":"zkEVM/zkProver/Debug/#setup-environment","title":"Setup environment","text":"<ul> <li>ideal repository structure:</li> </ul> <pre><code>github\n    --&gt; zkrom\n    --&gt; zkvmpil\n    --&gt; zkproverjs\n</code></pre> <ul> <li>Next steps are required to run the <code>zkprover:executor</code>:</li> </ul> <pre><code>git clone https://github.com/hermeznetwork/zkrom.git\ncd zkrom\nnpm i &amp;&amp; npm run build\ncd ..\ngit clone https://github.com/hermeznetwork/zkvmpil.git\ncd zkvmpil\nnpm i &amp;&amp; npm run build\ngit clone https://github.com/hermeznetwork/zkproverjs.git\ncd zkproverjs\nnpm i\n</code></pre> <ul> <li>Detailed explanation:</li> <li>repository <code>zkrom</code><ul> <li><code>main/*</code> : contains assembly code</li> <li><code>build</code>: compiled assembly. code ready to the executor</li> </ul> </li> <li>repository <code>zkvmpil</code><ul> <li><code>src</code>: state-machines</li> <li><code>build</code>: compiled state-machines. code ready to the executor </li> </ul> </li> <li> <p>repository <code>zkproverjs</code></p> <ul> <li><code>src/main_executor.js</code>: cli to run executor easily</li> <li>executor needs files fenerated from <code>zkrom/build</code> &amp; <code>zkvm pil/build</code></li> <li>it also needs an <code>input.json</code></li> <li>Examples:<ul> <li>zkrom file</li> <li>zkvmpil file</li> <li>input file</li> </ul> </li> </ul> </li> <li> <p>Run executor (in <code>zkproverjs</code> repository)</p> <p>to just test the executor, the output is not needed</p> </li> </ul> <pre><code>node src/main_executor.js ./testvectors/input.json -r ../zkrom/build/rom.json -p ../zkvmpil/build/zkevm.pil.json -o ./testvectors/poly.bin\n</code></pre>"},{"location":"zkEVM/zkProver/Debug/#executor-insights","title":"Executor insights","text":"<p>Basically, the executor runs the program that is specified by the ROM. The program can be seen in the <code>rom.json</code> file, which includes some debugging information. Let's see an example of <code>assembly code</code> builded into the <code>rom.json</code>:</p> <pre><code>ASSEMBLY: 1 =&gt; B\nJSON FILE:\n{\n  \"CONST\": 1,\n  \"neg\": 0,\n  \"setB\": 1,\n  \"line\": 51,\n  \"fileName\": \"../zkrom/main/main.zkasm\"\n }\n</code></pre> <p>All operations are defined in the JSON file, plus <code>line</code> &amp; <code>fileName</code> where the assembly code is. This JSON file is ready to be interpreted by the <code>executor</code></p>"},{"location":"zkEVM/zkProver/Debug/#vscode-debugging","title":"VSCode debugging","text":"<p>In the <code>zkproverjs</code> repository you can find an example of <code>launch.json</code> to debug the executor code: https://github.com/hermeznetwork/zkproverjs/blob/main/.vscode/launch.json#L8</p>"},{"location":"zkEVM/zkProver/Debug/#debugging-tips","title":"Debugging tips","text":"<ul> <li>Main executor code to debug: https://github.com/hermeznetwork/zkproverjs/blob/main/src/executor.js#L12</li> <li>variable <code>l</code> is the rom.json that is going to be executed: https://github.com/hermeznetwork/zkproverjs/blob/main/src/executor.js#L61</li> <li>debug helpers</li> <li>print registers</li> <li>By monioring <code>ctx(context)</code>, registers and <code>op</code> you will see all the states changes made by the executor</li> <li><code>ctx.input</code> contins all the variables loaded from <code>input.json</code></li> <li><code>storage</code> makes refrence to the merkle-tree</li> <li>transactions places at <code>input.json</code> are pre-processed and store it on <code>ctx.pTxs</code>. Besides, <code>globalHash</code> is computed given all the <code>inputs.json</code> according to specification (TO_BE_UPDATED) </li> </ul>"},{"location":"zkEVM/zkProver/Debug/#table-rom-assembly-instructions","title":"Table rom assembly instructions","text":"NAME DESCRIPTION EXECUTION MLOAD memory load op = mem(addr) MSTORE memory storage mem(addr) = op SLOAD storage load op = <code>storage.get(SR, H[A0 , A1 , A2 , B0 , C0 , C1 , C2 , C3, 0...0]))</code> where <code>storage.get(root, key) -&gt; value</code> SSTORE storage store op = <code>storage.set(SR, (H[A0 , A1 , A2 , B0 , C0 , C1 , C2 , C3, 0...0], D0 + D1 * 2^64 + D2 * 2^128 + D3 * 2^192 )</code> where <code>storage.set(oldRoot, key, newValue) -&gt; newRoot</code> HASHW hash write bytes hash[addr].push(op[0..D-1]) HASHE hash end hash[addr].end() HASHR hash read op = hash[addr].result ARITH arithmetic operation AB + C = D OR op SHL shift left op = A &lt;&lt; D SHR shift right op = A &gt;&gt; D ECRECOVER signature recover op = ECRECOVER( A: HASH, B: R, C:S, D: V) ASSERT assertion A = op"},{"location":"zkEVM/zkProver/Debug/#examples-assembly","title":"Examples assembly","text":""},{"location":"zkEVM/zkProver/Debug/#mstore","title":"MSTORE","text":"<ul> <li>assembly ```javascript= A                       :MSTORE(sequencerAddr)</li> </ul> <pre><code>- rom.json\n```json=\n{\n  \"inA\": 1,\n  \"neg\": 0,\n  \"offset\": 4,\n  \"mWR\": 1,\n  \"line\": 9,\n  \"offsetLabel\": \"sequencerAddr\",\n  \"useCTX\": 0,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n }\n</code></pre> <ul> <li>description: load <code>A</code> register in <code>op</code>, write in memory position 4 (<code>offset</code>) the <code>op</code> value</li> </ul>"},{"location":"zkEVM/zkProver/Debug/#mread","title":"MREAD","text":"<ul> <li>assembly: ```javascript= $ =&gt; A          : MLOAD(pendingTxs)</li> </ul> <pre><code>- rom.json\n```json=\n{\n  \"freeInTag\": {\n   \"op\": \"\"\n  },\n  \"inFREE\": 1,\n  \"neg\": 0,\n  \"setA\": 1,\n  \"offset\": 1,\n  \"mRD\": 1,\n  \"line\": 25,\n  \"offsetLabel\": \"pendingTxs\",\n  \"useCTX\": 0,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n }\n</code></pre> <ul> <li>description: load a memory value from position 1 (<code>offset</code>) into <code>op</code> (action marked by <code>inFREE</code>), set <code>op</code> in <code>A</code> register</li> </ul>"},{"location":"zkEVM/zkProver/Debug/#load-from-storage","title":"LOAD FROM STORAGE","text":"<ul> <li>assembly ```javascript= $ =&gt; A                          :MLOAD(sequencerAddr) 0 =&gt; B,C $ =&gt; A                          :SLOAD </li> </ul> <pre><code>- rom.json\n```json=\n {\n  \"freeInTag\": {\n   \"op\": \"\"\n  },\n  \"inFREE\": 1,\n  \"neg\": 0,\n  \"setA\": 1,\n  \"offset\": 4,\n  \"mRD\": 1,\n  \"line\": 47,\n  \"offsetLabel\": \"sequencerAddr\",\n  \"useCTX\": 0,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n },\n {\n  \"CONST\": 0,\n  \"neg\": 0,\n  \"setB\": 1,\n  \"setC\": 1,\n  \"line\": 48,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n },\n {\n  \"freeInTag\": {\n   \"op\": \"\"\n  },\n  \"inFREE\": 1,\n  \"neg\": 0,\n  \"setA\": 1,\n  \"sRD\": 1,\n  \"line\": 49,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n }\n</code></pre> <ul> <li>description</li> <li>load from memory position 5 (<code>sequencerAccValue</code>) into <code>op</code>, store <code>op</code> on <code>D</code> register</li> <li>load from memory position 4 (<code>sequencerAddr</code>) into <code>op</code>, store <code>op</code> on <code>A</code> register</li> <li>load CONST in <code>op</code>, store it in registers <code>B</code> and <code>C</code></li> <li>Perform SLOAD (reading from merkle-tree) with the follwing key: <code>storage.get(SR, H[A0 , A1 , A2 , B0 , C0 , C1 , C2 , C3, 0...0]))</code><ul> <li><code>SR</code> is the current state-root saved in register <code>SR</code></li> <li><code>A0, A1, A2</code> has the sequencer address</li> <li><code>B0</code> is set to <code>0</code> pointing out that the <code>balance</code> is going to be read</li> <li><code>C0,C1,C2,C3</code> are set to 0 since they are not used when reading balance from merkle-tree</li> </ul> </li> <li>merkle-tree value is store in <code>op</code> (marked by <code>inFREE</code> tag), set <code>op</code> to register <code>A</code></li> </ul>"},{"location":"zkEVM/zkProver/Debug/#write-to-storage","title":"WRITE TO STORAGE","text":"<ul> <li>assembly ```javascript= $ =&gt; A                          :MLOAD(sequencerAddr) 0 =&gt; B,C $ =&gt; SR                         :SSTORE</li> </ul> <pre><code>- rom.json\n```json=\n{\n  \"freeInTag\": {\n   \"op\": \"\"\n  },\n  \"inFREE\": 1,\n  \"neg\": 0,\n  \"setA\": 1,\n  \"offset\": 4,\n  \"mRD\": 1,\n  \"line\": 56,\n  \"offsetLabel\": \"sequencerAddr\",\n  \"useCTX\": 0,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n },\n {\n  \"CONST\": 0,\n  \"neg\": 0,\n  \"setB\": 1,\n  \"setC\": 1,\n  \"line\": 57,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n },\n {\n  \"freeInTag\": {\n   \"op\": \"\"\n  },\n  \"inFREE\": 1,\n  \"neg\": 0,\n  \"setSR\": 1,\n  \"sWR\": 1,\n  \"line\": 58,\n  \"fileName\": \".../zkrom/main/main.zkasm\"\n }\n</code></pre> <ul> <li>description</li> <li>read from memory position 4 (<code>sequencerAddr</code>) and store it on <code>op</code>, set <code>op</code> to register A</li> <li>set CONST to <code>op</code>, store <code>op</code> in registers <code>B</code> and <code>C</code></li> <li>Perform SWRITE (write to merkle-tree) according: <code>storage.set(SR, (H[A0 , A1 , A2 , B0 , C0 , C1 , C2 , C3, 0...0], D0 + D1 * 2^64 + D2 * 2^128 + D3 * 2^192 )</code><ul> <li><code>SR</code> is the current state-root saved in register <code>SR</code></li> <li><code>A0, A1, A2</code> has the sequencer address</li> <li><code>B0</code> is set to <code>0</code> pointing out that the <code>balance</code> is going to be read</li> <li><code>C0,C1,C2,C3</code> are set to 0 since they are not used when reading balance from merkle-tree</li> <li><code>D0, D1, D2, D3</code> is the value writen in the merkle-tree pointed out by <code>H[A0 , A1 , A2 , B0 , C0 , C1 , C2 , C3, 0...0]</code> --&gt; in this example register <code>D</code> has the balance of the <code>seqAddr</code></li> </ul> </li> <li>write merkle-tree state root in <code>SR</code> register </li> </ul>"},{"location":"zkEVM/zkProver/Mock/","title":"The mock server is at git@github.com:hermeznetwork/zk-mock-prover.git","text":""},{"location":"zkEVM/zkProver/Mock/#server-definition","title":"Server definition","text":"<ul> <li><code>proto/zk-prover-proto</code> contains the service specification</li> </ul> <p>syntax = \"proto3\";</p> <p>package zkprover;</p> <p>service ZKProver {     rpc GetStatus(NoParams) returns (State) {}     rpc GenProof(stream Batch) returns (stream Proof) {}     rpc Cancel(NoParams) returns (State) {}     rpc GetProof(NoParams) returns (Proof) {} }</p> <p>message NoParams {}</p> <p>message State {     enum Status {         IDLE = 0;         ERROR = 1;         PENDING = 2;         FINISHED = 3;     }     Status status = 1;     Proof proof = 2; }</p> <p>message ProofX {     repeated string proof = 1; }</p> <p>message PublicInputs {     bytes currentStateRoot = 1;     bytes currentLocalExitRoot = 2;     bytes newStateRoot = 3;     bytes newLocalExitRoot = 4;     string sequencerAddress = 5;     bytes l2TxsDataLastGlobalExitRoot = 6;     uint64 chainId = 7; }</p> <p>message Proof {     repeated string proofA = 1;     repeated ProofX proofB = 2;     repeated string  proofC = 3;     PublicInputs publicInputs = 4; }</p> <p>message Batch {     string message = 1;     bytes currentStateRoot = 2;     bytes newStateRoot = 3;     bytes l2Txs = 4;     bytes lastGlobalExitRoot = 5;     string sequencerAddress = 6;     uint64 chainId = 7; }</p> <ul> <li>Following documentation pretends to explain further its behaviour</li> </ul>"},{"location":"zkEVM/zkProver/Mock/#service-functionalities","title":"Service functionalities","text":"<pre><code>rpc GetStatus(NoParams) returns (State) {}\nrpc GenProof(stream Batch) returns (stream Proof) {}\nrpc Cancel(NoParams) returns (State) {}\nrpc GetProof(NoParams) returns (Proof) {}\n</code></pre>"},{"location":"zkEVM/zkProver/Mock/#getstatus","title":"GetStatus","text":"<p>Function to know the status of the prover.</p> <p>The client does not need to enter data to make this call. The status is returned in the following form:</p> <pre><code>message State {\n    enum Status {\n        IDLE = 0;\n        ERROR = 1;\n        PENDING = 2;\n        FINISHED = 3;\n    }\n    Status status = 1;\n    Proof proof = 2;\n}\n</code></pre> <p>The status will be one of those defined in the <code>enum</code>. Proof is only defined if the status is <code>FINISHED</code>.</p>"},{"location":"zkEVM/zkProver/Mock/#genproof","title":"GenProof","text":"<p>Function to generate the proofs.</p> <p>The client must provide the following information to the server when calling the function:</p> <pre><code>message Batch {\n    string message = 1;\n    bytes currentStateRoot = 2;\n    bytes newStateRoot = 3;\n    bytes l2Txs = 4;\n    bytes lastGlobalExitRoot = 5;\n    string sequencerAddress = 6;\n    uint64 chainId = 7;\n}\n</code></pre> <p>Where the message can be: - <code>\"calculate\"</code>: to generate the proof - <code>\"cancel\"</code>: to cancel the last proof</p> <p>And the server will respond:</p> <pre><code>message Proof {\n    repeated string proofA = 1;\n    repeated ProofX proofB = 2;\n    repeated string  proofC = 3;\n    PublicInputs publicInputs = 4;\n}\n</code></pre> <p>Where:</p> <pre><code>message PublicInputs {\n    bytes currentStateRoot = 1;\n    bytes currentLocalExitRoot = 2;\n    bytes newStateRoot = 3;\n    bytes newLocalExitRoot = 4;\n    string sequencerAddress = 5;\n    bytes l2TxsDataLastGlobalExitRoot = 6;\n    uint64 chainId = 7;\n}\n\nmessage ProofX {\n    repeated string proof = 1;\n}\n</code></pre> <p>This channel will be open until the client decides to close it. In this way, the client can continue requesting proofs by sending the message <code>Batch</code>.</p>"},{"location":"zkEVM/zkProver/Mock/#cancel","title":"Cancel","text":"<p>If the previous channel is closed and the server has computed a proof, the client can cancel it with this call.</p> <p>The client does not need to enter data to make this call. The prover returns the status to confirm that the proof calculation is canceled.</p>"},{"location":"zkEVM/zkProver/Mock/#getproof","title":"GetProof","text":"<p>Function to get the last calculated proof.</p> <p>The client does not need to enter data to make this call. If the status is <code>FINISHED</code>, the last proof is returned.</p>"},{"location":"zkEVM/zkProver/Overview/zkProver-Overview/","title":"zkProver Overview","text":"<p>For the sake of simplicity, one can think of the zkProver as being composed of the following four components; </p> <ol> <li>The Executor, which is the Main State Machine Executor</li> <li>The STARK Recursion Component</li> <li>The CIRCOM Library</li> <li>The zk-SNARK Prover</li> </ol> <p>In the nutshell, the zkProver uses these four components to generates verifiable proofs. Figure 5 below surmises the process. </p> <p></p>  Figure 1: Simplified Data Flow in the zkProver"},{"location":"zkEVM/zkProver/Overview/zkProver-Overview/#the-executor","title":"The Executor","text":"<p>The Executor is in fact the Main SM Executor. It takes as inputs; the transactions, the old and the new states, the ChainID of the Sequencer, to mention a few.</p> <p>The executor also needs; </p> <ol> <li>The PIL, which is the list of polynomials, the list of the registers, and</li> <li>The ROM, which stores the list of instructions pertaining to execution.</li> </ol> <p>So, with these inputs, the Executor executes all instructions on top of the PIL hardware and generates the committed polynomials; which are the state machine cycles, or a list of all the states. It also generates some public data, which forms part of the input to the zk-SNARK verifier.</p> <p>A full description of the Executor can be found in the Main State Machine's individual document.</p>"},{"location":"zkEVM/zkProver/Overview/zkProver-Overview/#the-stark-recursion-component","title":"The STARK Recursion Component","text":"<p>Once the Main SM Executor has converted transactions and related data to committed polynomials, the STARK Recursion Component takes as inputs;</p> <ol> <li>The Committed Polynomials,</li> <li>The Constant Polynomials,</li> <li>Scripts, which are lists of instructions,</li> </ol> <p>in order to generate a zk-STARK proof.</p> <p>In an effort to facilitate fast zk-STARK proving, the STARK Recursion Component utilises Fast Reed-Solomon Interactive Oracle Proofs of Proximity (RS-IOPP), also referred to as FRI, for each zk-proof.</p> <p>The component is referred to as the STARK Recursion, because;</p> <p>\u200b   (a) It actually produces several zk-STARK proofs,</p> <p>\u200b   (b) Collates them into bundles of a few zk-STARK proofs,</p> <p>\u200b   (c) And produces a further zk-STARK proof of each bundle,</p> <p>\u200b   (d) The resulting zk-STARK proofs of the bundle are also collated and proved with only one zk-STARK proof.</p> <p>This way, hundreds of zk-STARK proofs are represented and proved with only one zk-STARK proof.</p>"},{"location":"zkEVM/zkProver/Overview/zkProver-Overview/#the-circom-library","title":"The CIRCOM Library","text":"<p>The single zk-STARK proof produced by the STARK Recursion Component is the input to a CIRCOM component.</p> <p>CIRCOM is a circuits library used in the zkProver to generate the witness for the zk-STARK proof produced by the STARK Recursion Component.</p> <p>The original CIRCOM paper describes it as both a circuits programming language to define Arithmetic circuits, and a compiler that generates, </p> <ol> <li>A file containing a set of associated Rank-1 Constraints System (R1CS) constraints, and </li> <li>A program (written either in C++ or WebAssembly) to efficiently compute a valid assignment to all wires of the Arithmetic circuit.</li> </ol> <p>Arithmetic circuits are mostly used as standard models for studying the complexity of computations involving polynomials.</p> <p>That being said, the CIRCOM component takes as inputs; the zk-STARK proof from the STARK Recursion Component and the Verifier Data; in order to produce a witness. This witness is in fact an Arithmetic circuit expressed in terms of its R1CS constraints.  </p>"},{"location":"zkEVM/zkProver/Overview/zkProver-Overview/#the-zk-snark-prover","title":"The zk-SNARK Prover","text":"<p>The last component of the zkProver is the zk-SNARK Prover, in particular, Rapid SNARK. </p> <p>Rapid SNARK is a zk-SNARK proof generator, written in C++ and intel assembly, which is very fast in generating proofs of CIRCOM's outputs.</p> <p>With regards to the zkProver, the Rapid SNARK takes as inputs </p> <ol> <li>The witness from CIRCOM, and </li> <li>The STARK verifier data, which dictates how the Rapid SNARK must process the data,    and then generate a zk-SNARK proof.</li> </ol>"},{"location":"zkEVM/zkProver/Overview/zkProver-Overview/#a-strategy-to-achieving-succinctness","title":"A Strategy To Achieving Succinctness","text":"<p>zk-STARK proofs are used because of their speed, and they require no trusted setup. They are however a lot more sizable compared to zk-SNARK proofs. It is for this reason, and the succinctness of the zk-SNARKs, that the zkProver uses a zk-SNARK to attest to the correctness of the zk-STARK proofs. zk-SNARKs are therefore published as the validity proofs to state changes. This strategy has huge benefits as it results in gas costs reducing from 5M to 350K.</p>"},{"location":"zkEVM/zkProver/State-Machines/Main-State-Machine/Introduction/","title":"Introduction","text":"<p>Welcome to Polygon zkEVM documentation.</p> <p>We emphasise that this documentation is still Work In Progress (WIP). Some aspects have been covered in more detail, while others still need further expansion. Also, sections of this documentation might later be reorganized in order to achieve better flow.</p> <p>This section will explain how the main state machine works, but it is still in the TODO list.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/","title":"zkProver State Machines - An Overview","text":"<p>Core to the integrity of the Polygon zkEVM is its zero-knowledge prover, dubbed the zkProver.</p> <p>This document seeks to provide a more detailed architectural description of the zkProver without delving  deep into its technical complexities, as well as to introduce the zkProver's state machines in a cursory manner. It is therefore a prelude to the state machines' documentation. </p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#introduction","title":"Introduction","text":"<p>The design paradigm at Polygon Hermez has shifted to developing a zero-knowledge virtual machine (zkEVM) that emulates the Ethereum Virtual Machine (EVM).</p> <p>Proving and verification of transactions in Hermez 2.0 are all handled by a zero-knowledge prover-component dubbed the zkProver.</p> <p>But before delving deep into the state machines, note that the zkProver is but a component in the Polygon Hermez zkEVM, and the only one responsible for proving.</p> <p>In order to lay the context for the state machines, recall that the zkProver mainly interacts with two other components, the Node and the Database (DB).</p> <p></p>  Figure 1: zkProver and the Node  <p>As depicted in Figure 1 above; </p> <p>Firstly, the Node sends the content of Merkle trees to the DB, to be stored there. </p> <p>Secondly, the Node sends the input transactions to the zkProver. </p> <p>Thirdly, the zkProver accesses the DB, fetching the information it needs to produce verifiable proofs of the transactions sent by the Node. This information consists of, among others, the Merkle roots, the keys and hashes of relevant siblings. </p> <p>Fourthly, the zkProver generates the proofs of transactions, and sends these proofs back to the Node. </p> <p>But this only scratches the surface of what the zkProver does. There is a lot more detail involved in how the zkProver actually creates these verifiable proofs of transactions. And, it is in these details that the state machines come into the picture.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#state-machines","title":"State Machines","text":"<p>The zkProver follows modularity of design to the extend that, except for a few components, it is mainly a cluster of state machines. It has a total of thirteen (13) state machines;</p> <ul> <li>The Main State Machine, </li> <li>Secondary state machines; The Binary SM, The Storage SM, The Memory SM, The Arithmetic SM, The Keccak Function SM, The PoseidonG SM,</li> <li>Auxiliary state machines; The Padding-PG SM, The Padding-KK SM, The Bits2Field SM, The Memory Align SM, The Byte4 SM, The ROM SM.</li> </ul> <p>The modular design of the zkProver allows the Main SM to delegate as many of its duties as possible to other specialist state machines. As such, efficiency is achieved through delegation.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#secondary-state-machines","title":"Secondary State Machines","text":"<p>The Main SM Executor directly instructs each of the secondary state machines by sending appropriate instructions called Actions, as depicted in Figure 2 below.</p> <p>The grey boxes are not state machines but indicate Actions, which are specific instructions from the Main SM to the relevant secondary SM.</p> <p>These instructions dictate how a state should transition in a state machine. However, every \"Action\", whether from the generic Main SM or the specific SM, must be supported with a proof that it was correctly executed.</p> <p></p>  Figure 2: The Main SM Executor's Instructions  <p>There are some natural dependencies such as between; </p> <ul> <li>the Storage State Machine which uses merkle Trees and the \\(\\text{POSEIDON}\\) State Machine, which is needed for computing hash values of all nodes in the Storage's Merkle Trees.</li> <li>Each of the hashing state machines, Keccak Function SM and the PoseidonG SM, and their respective padding state machines, the Padding-KK SM and the Padding-PG SM.</li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#two-novel-languages-for-the-zkprover","title":"Two Novel Languages For The zkProver","text":"<p>The Polygon Hermez team has created two novel languages especially for the zkProver; The Zero-Knowledge Assembly language and the Polynomial Identity Language. </p> <p>Since adopting the state machines paradigm means switching from highlevel programming to low-level programming, it is not suprising for the zkProve to employ an especially designed language for the firmware and another for the hardware.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-zero-knowledge-assembly","title":"The Zero-Knowledge Assembly","text":"<p>As an Assembly language, the Zero-Knowledge Assembly (or zkASM) language is specially designed to map instructions from the zkProver's Main SM to other state machines. In the case of state machines with the firmware, zkASM is therefore the interpreter for the firmware. </p> <p>zkASM codes take instructions from the Main SM and generate prescriptive assembly codes for how the specific SM Executor has to execute computations. The Executor's strict adherence to the rules and logic of the zkASM codes, enables easy verification of computations.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-polynomial-identities-language","title":"The Polynomial Identities Language","text":"<p>The Polynomial Identity Language (or PIL) is especially designed for the zkProver, because almost all state machines express computations in terms of polynomials. State transitions in state machines must therefore satisfy computation-specific polynomial identities.</p> <p>Recall that the aim of this project is creating the most effective solution to the Blockchain Trilemma; Privacy, Secure and Scalable. And its context is that of an efficient Zero-Knowledge Commitment Scheme. Since the most secure and efficient commitment schemes are the Polynomial Commitment Schemes, it was expedient to translate computations into some polynomial language, where verification boils down to testing whether execution satisfies certain polynomial identities.</p> <p>All PIL codes, in the zkProver's state machines, therefore form the very DNA of the verifier code. </p> <p>These two languages, zkASM and PIL, were designed mindful of prospects for broader adoption outside Polygon zkEVM.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-micro-processor-context","title":"The Micro-Processor Context","text":"<p>There are two micro-processor-type state machines; the Main SM and the Storage SM. This means these two SMs have the firmware part and the hardware part.</p> <p>The firmware part runs the zkASM language to set up the logic and rules, which are expressed in JSON format and stored in a ROM. The JSON-file is then parsed to the specific SM Executor, which then executes Storage Actions in compliance with the rules and logic in the JSON-file.</p> <p>The hardware part, which speaks the Polynomial Identity Language (PIL), defines constraints (or polynomial identities), expresses them in JSON format and stores them in the corresponding JSON-file. As in the firmware case, these constraints are also parsed to the specific SM Executor, because all computations must be executed in conformance to the polynomial identities.</p> <p></p>  Figure 3 : Micro-Processor State Machine  <p>Although these two micro-processor SMs, the Main SM and the Storage SM, have the same look and feel, they differ considerably.</p> <p>For instance, the Storage SM specialises with execution of Storage Actions (also called SMT Actions), whilst the Main SM is responsible for a wider range of Actions. Nevertheless the Main SM delegates most of these Actions to specialist state machines. And, of course, the Storage SM remains secondary in that it also receives instructions from the Main SM, and not conversely.</p> <p>It is worth noting that each of these micro-processor SMs has its own ROM.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#hashing-in-the-zkprover","title":"Hashing In The zkProver","text":"<p>There are two secondary state machines specialising with hashing; The Keccak State Machine and the \\(\\text{POSEIDON}\\) State Machine, where each is an 'automised' version of its standard cryptographic hash function.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-keccak-state-machine","title":"The Keccak State Machine","text":"<p>The deployment of the Keccak hash function is not surprising given the fact that it is deployed in Ethereum, and Polygon Hermez is a zk-rollup, an L2 scaling solution for Ethereum.</p> <p>The Keccak state machine is a gates state machine, and thus has a set of logic gates (the hardware) and a set of connections between the gates (the logic). It is a secondary state machine composed of the Keccak SM Hash Generator and the Keccak PIL code, where the latter is for validation purposes.</p> <p>A full description of the Keccak SM can be found in its individual document.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-poseidon-state-machine","title":"The POSEIDON State Machine","text":"<p>The \\(\\text{POSEIDON}\\) hash function, although newer than the Keccak hash and thus still under the scrutiny of cryptanalysts, it has been publicised as a zk-STARK-friendly hash function. As such, it is best-suited for the zkProver context.</p> <p>The \\(\\text{POSEIDON}\\) SM is the most straight forward especially if one is familiar with the internal mechanism of the original Poseidon hash function. </p> <p>The hash function's permutation process translates readily to the state transitions of the \\(\\text{POSEIDON}\\) State Machine. The hash function's twelve (12) input elements, the non-linear substitution layers (the S-boxes) and the linear diffusion layers (the MDS matrices), are directly implemented in the state machine.   </p> <p>Although a secondary state machine, the \\(\\text{POSEIDON}\\) SM receives instructions from both the Main SM and the Storage SM.</p> <p>The \\(\\text{POSEIDON}\\) SM has the executor part and an internal PIL code, which is a set of verification rules, written in the PIL language.</p> <p>A full description of the \\(\\text{POSEIDON}\\) SM can be found in its individual document.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#basic-approach-to-proving-execution-correctness","title":"Basic Approach To Proving Execution-Correctness","text":"<p>What follows is an outline of the basic approach to proving that computations were correctly executed in each state machine.</p> <p>The zkProver's state machines are designed to execute programs, as well as to guarantee that these programs are correctly executed.</p> <p>Each secondary state machine therefore consists of its own executor and a PIL program that can be used to check correct execution of all the instructions coming from the Main SM Executor.</p> <p>Here is a step-by-step outline of how the system achieves proof/verification of transactions,</p> <ul> <li>Represent a given computation as a state machine (SM),</li> <li>Express the state changes of the SM as polynomials,</li> <li>Capture traces of state changes, called execution traces, as rows of a lookup table, </li> <li>Form polynomial identities/constraints that these state transitions satisfy, </li> <li>'Prover' uses a specific polynomial commitment scheme to commit and prove knowledge of the committed polynomials,</li> <li>Plookup is one of the ways to check if the Prover's commited polynomials produce correct traces.</li> </ul> <p>While the polynomial constraints are written in the PIL language, the instructions are initially written in zk-assembly but subsequently expressed and stored in JSON format.</p> <p>The above outline of the proof/verification procedure was explained in this blogpost, and further detailed in the documentation here.</p> <p>Although not all verification involves a Plookup, the diagram below, briefly illustrates the wide role Plookup plays in the zkProver.</p> <p></p>  Figure 4: Plookup and the zkProver State Machines"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#main-components-of-the-zkprover","title":"Main Components Of The zkProver","text":"<p>For the sake of simplicity, one can think of the zkProver as being composed of the following four components; </p> <ol> <li>The Executor, which is the Main State Machine Executor</li> <li>The STARK Recursion Component</li> <li>The CIRCOM Library</li> <li>The zk-SNARK Prover</li> </ol> <p>In the nutshell, the zkProver uses these four components to generates verifiable proofs. Figure 5 below surmises the process. </p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-executor","title":"The Executor","text":"<p>The Executor is in fact the Main SM Executor. It takes as inputs; the transactions, the old and the new states, the ChainID of the Sequencer, to mention a few.</p> <p>The executor also needs; </p> <ol> <li>The PIL, which is the list of polynomials, the list of the registers, and</li> <li>The ROM, which stores the list of instructions pertaining to execution.</li> </ol> <p>So, with these inputs, the Executor executes all instructions on top of the PIL hardware and generates the committed polynomials; which are the state machine cycles, or a list of all the states. It also generates some public data,which forms part of the input to the zk-SNARK verifier.</p> <p>A full description of the Executor can be found in the Main State Machine's individual document.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-stark-recursion-component","title":"The STARK Recursion Component","text":"<p>Once the Main SM Executor has converted transactions and related data to committed polynomials, the STARK Recursion Component takes as inputs;</p> <ol> <li>The Committed Polynomials,</li> <li>The Constant Polynomials,</li> <li>Scripts, which are lists of instructions,</li> </ol> <p>in order to generate a zk-STARK proof.</p> <p>In an effort to facilitate fast zk-STARK proving, the STARK Recursion Component utilises Fast Reed-Solomon Interactive Oracle Proofs of Proximity (RS-IOPP), also referred to as FRI, for each zk-proof.</p> <p>The component is referred to as the STARK Recursion, because; </p> <p>(a) It actually produces several zk-STARK proofs, </p> <p>(b) Collates them into bundles of a few zk-STARK proofs, </p> <p>(c) And produces a further zk-STARK proof of each bundle,</p> <p>(d) The resulting zk-STARK proofs of the bundle are also collated and proved with only one zk-STARK proof.</p> <p>This way, hundreds of zk-STARK proofs are represented and proved with only one zk-STARK proof.</p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-circom-library","title":"The CIRCOM Library","text":"<p>The single zk-STARK proof produced by the STARK Recursion Component is the input to a CIRCOM component.</p> <p>CIRCOM is a circuits library used in the zkProver to generate the witness for the zk-STARK proof produced by the STARK Recursion Component.</p> <p>The original CIRCOM paper describes it as both a circuits programming language to define Arithmetic circuits, and a compiler that generates, </p> <ol> <li>A file containing a set of associated Rank-1 Constraints System (R1CS) constraints, and </li> <li>A program (written either in C++ or WebAssembly) to efficiently compute a valid assignment to all wires of the Arithmetic circuit.</li> </ol> <p>Arithmetic circuits are mostly used as standard models for studying the complexity of computations involving polynomials.</p> <p>That being said, the CIRCOM component takes as inputs; the zk-STARK proof from the STARK Recursion Component and the Verifier Data; in order to produce a witness. This witness is in fact an Arithmetic circuit expressed in terms of its R1CS constraints.  </p>"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#the-zk-snark-prover","title":"The zk-SNARK Prover","text":"<p>The last component of the zkProver is the zk-SNARK Prover, in particular, Rapid SNARK. </p> <p>Rapid SNARK is a zk-SNARK proof generator, written in C++ and intel assembly, which is very fast in generating proofs of CIRCOM's outputs.</p> <p>With regards to the zkProver, the Rapid SNARK takes as inputs </p> <ol> <li>The witness from CIRCOM, and </li> <li>The STARK verifier data, which dictates how the Rapid SNARK must process the data, </li> </ol> <p>and then generate a zk-SNARK proof.</p> <p></p>  Figure 5: Simplified Data Flow in the zkProver"},{"location":"zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#a-strategy-to-achieving-succinctness","title":"A Strategy To Achieving Succinctness","text":"<p>zk-STARK proofs are used because of their speed, and they require no trusted setup. They are however a lot more sizable compared to zk-SNARK proofs. It is for this reason, and the succinctness of the zk-SNARKs, that the zkProver uses a zk-SNARK to attest to the correctness of the zk-STARK proofs. zk-SNARKs are therefore published as the validity proofs to state changes. This strategy has huge benefits as it results in gas costs reducing from 5M to 350K.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Arithmetic/Arithmetic/","title":"The Arithmetic State Machine","text":"<p>As a secondary state machine, the Arithmetic State Machine has the executor part (the Arithmetic SM Executor) and an internal Arithmetic PIL (program) which is a set of verification rules, written in the PIL language. The Arithmetic SM Executor is written in two versions; Javascript and C/C++.</p> <p>The Polygon Hermez Repo is here  https://github.com/0xPolygonHermez</p> <p>Arithmetic SM Executor: sm_arith folder</p> <p>Arithmetic SM PIL: arith.pil </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Arithmetic/Arithmetic/#introduction","title":"Introduction","text":"<p>The Arithmetic State Machine (SM) is one of the six secondary state machines receiving instructions from the Main SM Executor. As a secondary state machine, the Arithmetic SM has the executor part (the Arithmetic SM Executor) and an internal Arithmetic PIL program written in the PIL language.</p> <p>The main purpose of the Arithmetic SM is carry out elliptic curve arithmetic operations, such as Point Addition and Point Doubling as well as performing \\(256\\)-bits operations like addition, product or division. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Arithmetic/Arithmetic/#standard-elliptic-curve-arithmetic","title":"Standard Elliptic Curve Arithmetic","text":"<p>Consider an elliptic curve \\(E\\) defined by \\(y^2 = x^3 + ax + b\\) over the finite field \\(\\mathbb{F} = \\mathbb{Z}_p\\), where \\(p\\) is the prime,</p> \\[\\begin{aligned} p = 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 -2^6 - 2^4 - 1. \\end{aligned}\\] <p>Set the coefficients \\(a = 0\\) and \\(b = 7\\), so that \\(E\\) reduces to \\begin{aligned} y^2 = x^3 + 7. \\end{aligned}</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Arithmetic/Arithmetic/#elliptic-curve-point-addition","title":"Elliptic Curve Point Addition","text":"<p>Given two points, \\(P = (x_1,y_1)\\) and  \\(Q = (x_2,y_2)\\), on the curve \\(E\\) with \\(x_1 \\neq x_2\\), the point \\(P+Q = (x_3,y_3)\\)  is computed as follows,</p> \\[\\begin{aligned} x_3 &amp;= s^2 - x_1 - x_2,\\\\ y_3 &amp;= s (x_1 - x_3) - y_1 \\end{aligned}\\] <p>where \\begin{aligned} s = \\dfrac{y_2 - y_1}{x_2 - x_1}. \\end{aligned}</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Arithmetic/Arithmetic/#elliptic-curve-point-doubling","title":"Elliptic Curve Point Doubling","text":"<p>Given a point \\(P = (x_1,y_1)\\) on the curve \\(E\\) such that \\(P \\neq \\mathcal{O}\\), the point \\(P+P = 2P = (x_3,y_3)\\) is computed as follows,</p> \\[\\begin{aligned} x_3 &amp;= s^2 - 2x_1,\\\\ y_3 &amp;= s (x_1 - x_3) - y_1, \\end{aligned}\\] <p>where \\begin{aligned} s = \\dfrac{3x_1^2}{2y_1}. \\end{aligned}</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Arithmetic/Arithmetic/#field-arithmetic","title":"Field Arithmetic","text":"<p>We can express several \\(256\\)-bits operations in the following form</p> \\[ A \\cdot B + C = D \\cdot 2^{256} + E \\] <p>where \\(A, B, C, D\\) and \\(E\\) are \\(256\\)-bits integers.</p> <p>For example, if \\(C = 0\\), we are stating that the result of multiplying \\(A\\) and \\(B\\) is \\(E\\) with a carry of \\(D\\) (that is, the chunk that exceeds \\(256\\) bits). Or, setting \\(B = 1\\) we state that the result of add \\(A\\) and \\(C\\) is the same as before. We can also express divisions, modular reductions, etc.</p> <p>We will perform this kind of operations in the Arithmetic State Machine, with registers satisfying the PIL relation</p> \\[ \\text{EQ}_0 \\colon \\quad x_1 \\cdot y_1 + x_2 - y_2 \\cdot 2^{256} - y_3 = 0 \\] <p>Remark: Since the above Elliptic Curve operations are implemented in the PIL language, it is more convenient to express them in terms of the constraints they must satisfy. These constraints are:</p> \\[\\begin{aligned} \\text{EQ}_0 \\colon \\quad &amp;x_1 \\cdot y_1 + x_2 - y_2 \\cdot 2^{256} - y_3 = 0, \\\\ \\text{EQ}_1 \\colon \\quad &amp;s \\cdot x_2 - s \\cdot x_1 -y_2 + y_1 + q_0 \\cdot p = 0, \\\\ \\text{EQ}_2 \\colon \\quad &amp; 2 \\cdot s \\cdot y_1 - 3 \\cdot x_1 \\cdot x_1 + q_0 \\cdot p = 0, \\\\ \\text{EQ}_3 \\colon \\quad &amp; s \\cdot s - x_1 - x_2 - x_3 + q_1 \\cdot p = 0, \\\\ \\text{EQ}_4 \\colon \\quad &amp; s \\cdot x_1 - s \\cdot x_3 - y_1 - y_3 + q_2 \\cdot p = 0, \\end{aligned}\\] <p>where \\(q_0,q_1,q_2 \\in \\mathbb{Z}\\), implying that these equations hold true over the integers. </p> <p>This approach is taken in order avoid having to compute divisions by \\(p\\).</p> <p>Note also that only three possible computation scenarios arise:</p> <ol> <li>\\(\\text{EQ}_0\\) is activated while the rest are deactivated,</li> <li>\\(\\text{EQ}_1\\), \\(\\text{EQ}_3\\) and \\(\\text{EQ}_4\\) are activated but \\(\\text{EQ}_0\\) and \\(\\text{EQ}_2\\) are deactivated, </li> <li>\\(\\text{EQ}_2\\), \\(\\text{EQ}_3\\) and \\(\\text{EQ}_4\\) are activated and \\(\\text{EQ}_0\\) and \\(\\text{EQ}_1\\) are deactivated.</li> </ol> <p>Since at most, one of \\(\\text{EQ}_1\\) and \\(\\text{EQ}_2\\) are activated in any scenario, we can afford \"sharing'' the same \\(q_0\\) for both.</p> <p>Motivated by the implemented operations, the Arithmetic SM is composed of 6 registers  \\begin{aligned} x_1,\\ y_1,\\ x_2,\\ y_2,\\ x_3,\\ y_3. \\end{aligned}</p> <p>Each of these registers is composed of \\(16\\) sub-registers of \\(16\\)-bit (\\(2\\) byte) capacity, adding up to a total of \\(256\\) bits per register. </p> <p>There is also a need to provide \\(s\\) and \\(q_0,q_1,q_2\\), which are also \\(256\\)-bit field elements. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Arithmetic/Arithmetic/#how-the-operations-are-performed","title":"How The Operations Are Performed","text":"<p>Compute the previous operations at \\(2\\)-byte level. </p> <p>This means that if, for instance, one is performing the multiplication of \\(x_1\\) and \\(y_1\\), at the first clock \\(x_1[0] \\cdot y_1[0]\\) is computed. </p> <p>Then, \\((x_1[0] \\cdot y_1[1]) + (x_1[1] \\cdot y_1[0])\\) is computed in the second clock, followed by \\((x_1[0] \\cdot y_1[2]) + (x_1[1] \\cdot y_1[1]) + (x_1[2] \\cdot y_1[0])\\)  in the third, and so on. </p> <p>As depicted in Figure 1, this process is completely analogous to the schoolbook multiplication. However, it is performed at \\(2\\)-byte level, instead of at decimal level.</p> <p></p>  School Multiplication Example  <p>Use the following notation;</p> \\[ \\begin{aligned} \\mathbf{eq\\ } &amp;= x_1[0] \\cdot y_1[0] \\\\ \\mathbf{eq'} &amp;= x_1[0] \\cdot y_1[1] + x_1[1] \\cdot y_1[0] \\end{aligned} \\] <p>But then, the carry generated by \\(\\mathbf{eq}\\) has to be taken into account by \\(\\mathbf{eq'}\\).</p> <p>Going back to our equations; \\(\\text{EQ}_0, \\text{EQ}_1, \\text{EQ}_2, \\text{EQ}_4\\); let's see how the operation is performed in \\(\\text{EQ}_0\\). </p> <p>First, we compute \\(\\mathbf{eq}_0 = (x_1[0] \\cdot y_1[0]) + x_2[0] - y_3[0]\\). </p> <p>Second, we compute \\(\\mathbf{eq}_1 = (x_1[0] \\cdot y_1[1]) + (x_1[1] \\cdot y_1[0]) + x_2[1] - y_3[1]\\). </p> <p>Third, \\(\\mathbf{eq}_2 = (x_1[0] \\cdot y_1[2]) + (x_1[1] \\cdot y_1[1]) + (x_1[2] \\cdot y_1[0]) + x_2[2] - y_3[2]\\).</p> <p>This is continued until one reaches the computation, \\(\\mathbf{eq}_{15} = (x_1[0] \\cdot y_1[15]) + (x_1[1] \\cdot y_1[14]) + \\dots + x_2[15] - y_3[15]\\). </p> <p>This is the time when \\(y_2\\) come into place. </p> <p>Since we have filled the first \\(256\\) bits of the result of the operation (and the result can be made of more than \\(256\\) bits) we need a new register to place the result from this point. We change the addition of \\(x_2[i] - y_3[i]\\) by \\(-y_2[i]\\). </p> <p>Therefore, we obtain that </p> \\[ \\begin{aligned} \\mathbf{eq}_{16} &amp;= (x_1[1] \\cdot y_1[15]) + (x_1[2] \\cdot y_1[14]) + \\dots - y_2[0], \\\\ \\mathbf{eq}_{17} &amp;= (x_1[2] \\cdot y_1[15]) + (x_1[3] \\cdot y_1[14]) + \\dots - y_2[1] \\end{aligned} \\] <p>and so on. </p> <p>Continuing until the last two </p> \\[ \\begin{aligned} \\mathbf{eq}_{30} &amp;= (x_1[15] \\cdot y_1[15]) - y_2[14], \\\\ \\mathbf{eq}_{31} &amp;= -y_2[15].  \\end{aligned} \\] <p>The full list can be found in Appendix A. </p> <p>Now, notice that the \\(\\mathbf{eq}_i\\)'s do not care about the carry they generate. That means, if \\(\\mathbf{eq}_i = 10\\), then what we really want the result to be is \\(0\\) and save \\(1\\) as a carry for the next operation. To express this fact as a constraint, we say that the following has to be satisfied: $$ \\mathbf{eq} + \\text{carry} = \\text{carry}' \\cdot 2^{16}, $$ where \\(\\text{carry}\\) represents the carry taken into account in the actual clock, and \\(\\text{carry}'\\) represents the carry generated by the actual operation.</p> <p>Remark: A technicality is that \\(\\text{carry}\\) is subdivided into two other \\(\\text{carry}_L\\) and \\(\\text{carry}_H\\) such that: $$ \\text{carry} = \\text{carry}_L + \\text{carry}_H \\cdot 2^{18}. $$</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/","title":"Binary State Machine","text":"<p>The Binary State Machine (SM) is one of the six secondary state machines receiving instructions, called Binary Actions, from the Main State Machine Executor.</p> <p>It is responsible for the execution of all binary operations in the zkProver.</p> <p>As a secondary state machine, the Binary State Machine has the executor part (the Binary SM Executor) and an internal Binary PIL (program) which is a set of verification rules, written in the PIL language. The Binary SM Executor is written in two versions; Javascript and C/C++.</p> <p>The Polygon Hermez Repo is here  https://github.com/0xPolygonHermez</p> <p>Binary SM Executor: sm_binary.js</p> <p>Binary SM PIL: binary.pil </p> <p>Test Vectors: binary_test.js</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#binary-operations-on-256-bit-strings","title":"Binary Operations on 256-bit Strings","text":"<p>The zkEVM (zero-knowledge Ethereum Virtual Machine) performs the following binary operations on 256-bit strings,</p> <ul> <li>\\(\\text{ADD }\\) (\\(+\\)), the addition operation adds two 256-bit numbers.</li> <li>\\(\\text{SUB }\\) (\\(-\\)), the subtraction operation computes the difference between two 256-bit numbers.</li> <li>\\(\\text{LT }\\) (\\(&lt;\\)), the less-than operation checks if a 256-bit number is smaller than another 256-bit number, without considering the signs the numbers.</li> <li>\\(\\text{SLT }\\) (\\(&lt;\\)), the signed less-than operation checks if a 256-bit number is smaller than another 256-bit number, but takes into consideration the respective signs of the numbers.</li> <li>\\(\\text{EQ }\\) (\\(=\\)), the 'equal' operation checks if two 256-bit numbers are equal.</li> <li>\\(\\text{AND }\\) (\\(\\land\\)), the operation that computes the bit-wise \"AND\" of two numbers.</li> <li>\\(\\text{OR }\\) (\\(\\lor\\)), the operation computes the bit-wise \"OR\" of two numbers.</li> <li>\\(\\text{XOR }\\)  (\\(\\oplus\\)), the operation computes the bit-wise \"XOR\" of two numbers.</li> <li>\\(\\text{NOT }\\) (\\(\\neg\\)), the operation computes the bit-wise \"NOT\" of a binary number.</li> </ul> <p>In order to understand how the \\(\\text{ADD}\\), \\(\\text{SUB}\\), \\(\\text{LT}\\) and \\(\\text{SLT}\\) operations work, one needs to first understand how the zkEVM codes 256-bit strings to signed and unsigned integers.</p> <p>Figure 1 shows these codifications for 3-bit strings but the idea can be easily extended to 256-bit strings.</p> <p></p>  Figure 1: Codifications of 3-bit strings for signed and unsigned integers as used by the EVM  <p>Adding two strings is performed bit-by-bit using the corresponding carry.</p> <p>For example, add the 3-bit strings \\(\\mathtt{0b001}\\) and \\(\\mathtt{0b101}\\), where \\(\\mathtt{0b}\\) means binary,</p> <ul> <li> <p>Start with an initial \\(carry=0\\) and add the least significant bits,</p> <p>\\(1+1+carry=1+1+0=0\\), so the next carry becomes \\(carry'=1\\).</p> </li> <li> <p>Next, add the the second least-significant bits using the previous carry, </p> <p>\\(0+0+carry = 0+0+1 = 1\\), this time the next carry is \\(carry'=0\\).</p> </li> <li> <p>Finally, add the most significant bits,</p> <p>\\(0+1+carry=0+1+0=1\\), with the final carry being \\(carry'=0\\).</p> </li> <li> <p>As a result: \\(\\mathtt{0b001}+\\mathtt{0b101} = \\mathtt{0b110}\\) with \\(carry=0\\).</p> </li> </ul> <p>The sum \\(\\mathtt{0b001}+\\mathtt{0b101} = \\mathtt{0b110}\\), for unsigned integers is \\(1+5=6\\), while for signed integers encoded with complement to two, this sum is \\(1+(-3) =(-2)\\).</p> <p>In other words, the same binary sum can be done for both signed integers and for unsigned integers.</p> <p>The operations \\(\\text{LT}\\) and \\(\\text{SLT}\\) are different however.</p> <p>When comparing unsigned integers (using \\(\\text{LT}\\)), the natural order for comparisons is applied. For example, \\(010 &lt; 110\\), i.e., \\(2 &lt; 6\\).</p> <p>When comparing signed integers (using \\(\\text{SLT}\\)), one must take into account the most significant bit that acts as the sign.</p> <ul> <li> <p>If the most-significant bits of the two strings being compared is the same, the the natural order applies. For example, \\(101  &lt; 110\\). i.e., \\(-3 &lt; -2\\)</p> </li> <li> <p>However, if the most significant bits of strings being compared are different, then the order must be flipped (bigger numbers start with 0). For example, \\(110 &lt; 001\\). i.e., \\(-2  &lt;  1\\).</p> </li> </ul> <p>Finally, notice that with unsigned integers, there is a caveat since 4 and -4 have the same codification.</p> <p>On the other hand, the \\(\\text{AND}\\), \\(\\text{OR}\\), \\(\\text{XOR}\\) and \\(\\text{NOT}\\) operations are bit-wise operations, that is to say, the operation is done bit-by-bit. As a result, there is no carry to be considered when operating a pair of bits. This makes the checks easier to implement for bit-wise operations.</p> <p>Table 1 depicts the truth tables of \\(\\text{AND}\\), \\(\\text{OR}\\) and \\(\\text{XOR}\\) operators, respectively.</p> <p></p>  Table 1: Truth Tables of bit-wise operations  <p>Notice that we do not consider the \\(\\text{NOT}\\) operation. This is because the \\(\\text{NOT}\\) operation can be easily implemented with the \\(\\text{XOR}\\) operation, by taking an \\(\\text{XOR}\\) of the 256-bit string and \\(\\texttt{0xff...ff}\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#the-design-of-the-binary-sm","title":"The Design Of The Binary SM","text":"<p>The Executor of the Binary SM records the trace of each computation in the state machine, and this computational trace is used to prove correctness of computations.</p> <p>The execution trace is typically in the form of 256-bit strings. And the polynomial constraints, that every correct execution trace must satisfy, are described in a PIL file (or 'code').</p> <p>For the Binary SM, these computations refers to the aforementioned binary operations, and uses special codes for each of the operations.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#codes-for-the-binary-operations","title":"Codes for the Binary Operations","text":"<p>Each operation that the Binary SM checks has a code as shown in Table 2, below. </p> <p>In instances where none of the defined binary operations is carried out, the Binary SM's operation is considered to be a \\(\\text{NOP}\\) (No Operation), in which case any code not in the defined list of codes can be used.</p>  Table 2: All Operations Checked by the Binary SM  <p> \\(\\textbf{Operation Name}\\) \\(\\textbf{Mnemonic}\\) \\(\\textbf{Symbol}\\) \\(\\textbf{BinOpCode}\\) \\(\\text{Addition}\\) \\(\\mathrm{ADD}\\) \\(+\\) \\(0\\) \\(\\text{Subtraction}\\) \\(\\mathrm{SUB}\\) \\(-\\) \\(1\\) \\(\\text{Less Than}\\) \\(\\mathrm{LT}\\) \\(&lt;\\) \\(2\\) \\(\\text{Signed Less Than}\\) \\(\\mathrm{SLT}\\) \\(&lt;\\) \\(3\\) \\(\\text{Equal To}\\) \\(\\mathrm{EQ}\\) \\(=\\) \\(4\\) \\(\\text{Bitwise AND}\\) \\(\\mathrm{AND}\\) \\(\\wedge\\) \\(5\\) \\(\\text{Bitwise OR}\\) \\(\\mathrm{OR}\\) \\(\\vee\\) \\(6\\) \\(\\text{Bitwise XOR}\\) \\(\\mathrm{XOR}\\) \\(\\oplus\\) \\(7\\) \\(\\text{No Operation}\\) \\(\\mathrm{NOP}\\) \\(\\mathrm{NOP}\\) \\(\\star\\) <p></p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#internal-byte-plookups","title":"Internal Byte Plookups","text":"<p>The Binary SM is internally designed to use plookups of bytes for all the binary operations. </p> <p>That is, it uses plookups that contain all the possible input bytes and output byte combinations,</p> \\[ \\text{byte}_{in_0} \\star \\text{byte}_{in_1} = \\text{byte}_{out}, \\] <p>where \\(\\star\\) is one of the possible operations.</p> <p>When executing a binary operation between the 256-bit input strings, an execution trace is generated in cycles of \\(32\\) steps per operation.</p> <p>At each step, the corresponding byte-wise operation and any required extra information, such as 'carries' or auxiliary values, form part of the computation trace.</p> <p>Additionally, each \\(256\\)-bit string (the two inputs and the output) are expressed using \\(8\\) registers of \\(32\\)-bits.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#connection-with-the-main-sm","title":"Connection with the Main SM","text":"<p>The constraint that connects the execution trace of the Main SM with the execution trace of the Binary SM is a Plookup, which is performed at each row of the Binary SM execution trace when the cycle is completed (this is when a register called \\(\\texttt{RESET}\\) is 1).</p> <p>The Plookup checks the operation code, the registries for the input and output 256-bit strings, and the final carry.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#operating-at-byte-level","title":"Operating At Byte-Level","text":"<p>This section provides examples of how the byte-wise operations work. </p> <p>A \\(256\\)-bit integer \\(\\mathbf{a}\\) is herein denoted in vector form as \\((a_{31}, \\dots, a_1, a_0)\\) to indicate that, $$ \\mathbf{a} = a_{31}\\cdot (2^8)^{31} + a_{30}\\cdot (2^8)^{30} + \\cdots + a_1\\cdot2^8 + a_0   = \\sum_{i = {31}}^{0} a_i \\cdot (2^8)^i, $$ where each \\(a_i\\) is a byte that can take values between \\(0\\) and \\(2^8 - 1\\). </p> <p>Example 1.</p> <p>If \\(\\mathbf{a} = 29967\\), its byte decomposition can be written as \\(\\mathbf{a} = (\\mathtt{0x75}, \\mathtt{0x0F})\\), because \\(\\mathbf{a} = 29967 = 117 \\cdot 2^8 + 15\\), and in hexadecimal, \\(117 \\mapsto \\mathtt{0x75}\\) and \\(15 \\mapsto \\mathtt{0x0F}\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#addition","title":"Addition","text":"<p>Here is how the addition operation on two \\(256\\)-bit numbers is reduced to a byte-by-byte addition, and thus ready to use the byte-wise Plookup table.</p> <p>Observe that adding two bytes \\(a\\) and \\(b\\) (i.e., \\(a\\) and \\(b\\) are members of the set \\([0, 2^8-1]\\)), may result in a sum \\(c\\) which cannot be expressed as a single byte. </p> <p>For example, if \\(a = \\mathtt{0xFF}\\) and \\(b = \\mathtt{0x01}\\), then, $$ a + b = \\mathtt{0xFF} + \\mathtt{0x01} = \\mathtt{0x100}. $$ In byte-form, \\(c=\\mathtt{0x00}\\) and with \\(carry'=1\\). This carry has to be taken care of when dealing with bytes.</p> <p>Consider now the process of adding two bytes. </p> <p>Example 2.</p> <p>Take for instance, \\(\\mathbf{a} = (a_1, a_0) = (\\mathtt{0xFF}, \\mathtt{0x01})\\) and \\(\\mathbf{b} = (b_1, b_0) = (\\mathtt{0xF0}, \\mathtt{0xFF})\\).</p> <ul> <li>First add the less significant bytes:</li> </ul> \\[ \\begin{aligned} a_1 + b_1 &amp;= \\mathtt{0x01} + \\mathtt{0xFF} = c_1 = \\mathtt{0x00}, \\\\ carry_1 &amp;= 1. \\end{aligned} \\] <ul> <li>Then, add the next significant byte,</li> </ul> \\[ \\begin{aligned} a_2 + b_2 + carry_1 &amp;= \\mathtt{0xFF} + \\mathtt{0xF0} = c_2 = \\mathtt{0xF0}, \\\\ carry_2 &amp;= 1. \\end{aligned} \\] <p>The previous example shows is scheme depicts several cases that need to be treated separately;</p> <ol> <li>If \\(a_1 + b_1 &lt; 2^8\\) and \\(a_2 + b_2 &lt; 2^8\\), then the sum \\(\\mathbf{a} + \\mathbf{b}\\) is simply,</li> </ol> \\[ \\mathbf{a} + \\mathbf{b} = (a_2 + b_2, a_1 + b_1). \\] <ol> <li>If \\(a_1 + b_1 &lt; 2^8\\) but \\(a_2 + b_2 \\geq 2^8\\), then \\(a_2 + b_2\\) does not fit in a single byte. Hence, the sum of \\(a_2\\) and \\(b_2\\) has to be written as,</li> </ol> \\[ a_2 + b_2 = 1 \\cdot 2^8 + c_2, \\] <p>\u200b    for some byte \\(c_2\\). The addition \\(\\mathbf{a} + \\mathbf{b}\\) is then computed as follows,  $$ \\mathbf{a} + \\mathbf{b} = (1, c_2, a_1 + b_1). $$</p> <ol> <li>If \\(a_1 + b_1 \\geq 2^8\\), then we have that:</li> </ol> \\[ a_1 + b_1 = 1 \\cdot 2^8 + c_1, \\] <p>\u200b   for some byte \\(c_1\\). Then we can write, $$ \\mathbf{a} + \\mathbf{b} = (a_2 + b_2 + 1) \\cdot 2^8 + c_1. $$</p> <p>Consider the following two scenarios:</p> <p>(a) If \\(a_2 + b_2 + 1 \\geq 2^8\\), then the sum will take the form: $$ a_2 + b_2 + 1 = 1 \\cdot 2^8 + c_2. $$ \u200b   Therefore, the byte decomposition of \\(\\mathbf{a} + \\mathbf{b}\\) is, $$ \\mathbf{a} + \\mathbf{b} = (1, c_2, c_1). $$ (b) If \\(a_2 + b_2 + 1 &lt; 2^8\\), then the byte decomposition of \\(\\mathbf{a} + \\mathbf{b}\\) is: $$ \\mathbf{a} + \\mathbf{b} = (c_2, c_1). $$ Observe that addition of \\(256\\)-bit numbers can be reduced to additions at byte-level by operating through the previous cases in an iterative manner. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#subtraction","title":"Subtraction","text":"<p>Reducing Subtraction to byte-level turns out to be trickier than Addition case. </p> <p>Suppose \\(\\mathbf{a} = \\mathtt{0x0101}\\) and \\(\\mathbf{b} = \\mathtt{0x00FF}\\). </p> <p>Observe that \\(\\mathtt{0xFF}\\) cannot be subtracted from \\(\\mathtt{0x01}\\) because \\(\\mathtt{0xFF} &gt; \\mathtt{0x01}\\).</p> <p>However, we know that the result is \\(\\mathbf{a} - \\mathbf{b} = \\mathbf{c} = \\mathtt{0x0002}\\).</p> <p>In order to get this result, notice that the operation can be described as follows,</p> \\[ \\begin{aligned} \\mathbf{a} - \\mathbf{b} &amp; = (\\mathtt{0x01} - \\mathtt{0x00}) \\cdot 2^8 + (\\mathtt{0x01} - \\mathtt{0xFF}) \\\\    &amp; = (\\mathtt{0x01} - \\mathtt{0x00}) \\cdot 2^8  - 2^8 + 2^8 + (\\mathtt{0x01} - \\mathtt{0xFF}) \\\\    &amp; = (\\mathtt{0x01} - \\mathtt{0x00 - 0x01}) \\cdot 2^8  + \\mathtt{0xFF + 0x01} + \\mathtt{0x01} - \\mathtt{0xFF} \\\\    &amp; = ( \\mathtt{0x00} ) \\cdot 2^8  + \\mathtt{0x02} \\end{aligned} \\] <p>The output byte decomposition is \\(\\mathbf{a} = (c_1, c_0)  = (\\mathtt{0x00}, \\mathtt{0x02})\\). </p> <p>Nonetheless, it may be necessary to look at more examples so as to better understand how subtraction works at byte-level in a more general sense.</p> <p>Consider now subtraction of numbers with \\(3\\) bytes. Say, \\(a = \\mathtt{0x0001FE}\\) and \\(b = \\mathtt{0xFEFFFF}\\).</p> <p>First analyse the first two bytes, as in the previous example,</p> \\[ \\begin{aligned} (\\mathtt{0x01} - \\mathtt{0xFF}) \\cdot 2^8 + (\\mathtt{0xFE} - \\mathtt{0xFF}) &amp;= (\\mathtt{0x01} - \\mathtt{0xFF} - \\mathtt{0x01} ) \\cdot 2^8 + (\\mathtt{2^8} + \\mathtt{0xFE} - \\mathtt{0xFF}) \\\\ &amp; = (\\mathtt{0x01} - \\mathtt{0xFF - 0x01}) \\cdot 2^8 + \\mathtt{0xFF} \\end{aligned} \\] <p>But now observe that \\(\\mathtt{0x01} - \\mathtt{0xFF} - \\mathtt{0x01}\\) is also a negative value. Hence, there is a need to repeat the strategy and keep a carry to the next byte,</p> \\[ \\begin{aligned} &amp;(\\mathtt{0x00} - \\mathtt{0xFE}) \\cdot 2^{16} + (\\mathtt{0x01} - \\mathtt{0xFF} - \\mathtt{0x01}) \\cdot 2^8 + \\mathtt{0xFF} = \\\\ &amp;(\\mathtt{0x00} - \\mathtt{0xFE} - \\mathtt{0x01}) \\cdot 2^{16} + (\\mathtt{2^8} + \\mathtt{0x01} - \\mathtt{0xFF} - \\mathtt{0x01}) \\cdot 2^8 + \\mathtt{0xFF} = \\\\ &amp;(\\mathtt{0x00} - \\mathtt{0xFE} - \\mathtt{0x01}) \\cdot 2^{16} + \\mathtt{0x01} \\cdot 2^8 + \\mathtt{0xFF}.  \\end{aligned} \\] <p>Observe that the previous example is included in this case. </p> <p>In general, let \\(a = (a_i)_i\\) and \\(b = (b_i)_i\\), with \\(a_i, b_i\\) bytes, be the byte representations of \\(a\\) and \\(b\\). Instead of checking if we can perform the subtraction \\(a_i - b_i\\) for some bytes \\(i\\), we are checking if \\(a_i - b_i - \\texttt{carry} \\geq 0\\). Equivalently, we are checking if \\(a_i - \\texttt{carry} \\geq b_i\\). The previous case can be recovered by setting \\(\\texttt{carry} = 1\\) and the first case corresponds to setting \\(\\mathtt{carry = 0}\\). </p> <p>We have two possible cases,</p> <ul> <li>If \\(a_i - \\texttt{carry} \\geq b_i\\), then \\(a_i - b_i - \\texttt{carry}\\) provides the corresponding \\(i\\)-th byte of the representation of \\(a - b\\).</li> <li>If \\(a_i - \\texttt{carry} &lt; b_i\\) then we should compute the corresponding \\(i\\)-th byte of the representation of \\(a - b\\) as,</li> </ul> \\[ 2^8 - b_i + a_i - \\texttt{carry} = 255 - b_i + a_i - \\texttt{carry} + 1. \\] <p>However, we need to discuss the last step of our example. Observe that we can not perform the operation \\(\\mathtt{0x00} - \\mathtt{0xFE} - \\mathtt{0x01}\\) since it corresponds to a negative value. But as we are working with unsigned integers, we will do the two's complement and set the last byte to,  $$ 2^8 - \\mathtt{0xFE} + \\mathtt{0x00} - \\mathtt{0x01} = 255 - \\mathtt{0xFE} + \\mathtt{0x00} - \\mathtt{0x01} + 1 = 255 - b_3 + a_3 - \\texttt{carry} + 1. $$</p> <p>Observe that this is also included in the case when \\(a_i - \\texttt{carry} &lt; b_i\\), so we must not treat the last bit in a different manner. To end up with our example, we get the following byte representation of \\(a - b\\), $$ c = (\\mathtt{0x01}, \\mathtt{0x01}, \\mathtt{0xFF}) = \\mathtt{0x01} \\cdot 2^{16} + \\mathtt{0x01} \\cdot 2^8 + \\mathtt{0xFF}. $$</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#less-than","title":"Less Than","text":"<p>We want to describe the less than comparator byte-wise. For \\(256\\)-bits integers, the operation \\(&lt;\\) will output \\(c = 1\\) if \\(a &lt; b\\) and \\(c = 0\\) otherwise. As we are working in the natural integers order, the most significant byte decide and, if they are equal, we should consider the previous one until we can decide. Let us propose the example with \\(a = \\mathtt{0xFF AE 09}\\) and \\(b = \\mathtt{0x FF AE 02}\\). We know that \\(a &gt; b\\). Why? We should start at the most significant byte. We know that $$ a \\mathtt{&gt;&gt; 16} = \\mathtt{0x FF} = \\mathtt{0x FF} = b \\mathtt{&gt;&gt; 16}. $$</p> <p>Hence, we can not decide with this byte. An the same happens with the second byte, they are both equal to \\(\\mathtt{0x AE}\\). Hence, the less significant byte decides,  $$ \\mathtt{0x 09} &gt; \\mathtt{0x 02}. $$</p> <p>However, the problem with our set up is that we must start with the less significant byte and climb up to the most significant byte. The strategy will be to use some kind of a carry in order to \"carry\" the decisions from previous bytes. Let us do an example step by step, now with \\(a = \\mathtt{0x FF AA 02}\\) and \\(b = \\mathtt{0x 01 AA 09}\\). First of all, we will compare the less significant bytes. Since $$ \\mathtt{0x 02} &lt; \\mathtt{0x 09}, $$ we will set up \\(\\mathtt{carry} = 1\\). We will carry this decision until we finish to process all bytes or, alternatively, we should change to the complementary decision. Therefore, since the next two bytes are equal and we are not at the end, we maintain \\(\\mathtt{carry}\\) to \\(1\\). The previous step is the last one. We compare the most significant bytes, $$ \\mathtt{0x FF} \\not &lt; \\mathtt{0x 01}. $$</p> <p>Henceforth, we should output a \\(0\\), independently to the previous carry decision. But, let us suppose now that \\(b = \\mathtt{0x FF AA 09}\\). Then, in this last step, we should output a \\(1\\), since \\(a &lt; b\\). The idea is that, in the last step, if both bytes are equal, we should output the decision carry \\(\\mathtt{carry}\\). In general, in the step \\(i\\), comparing bytes \\(a_i\\) and \\(b_i\\), we have \\(3\\) cases,</p> <ul> <li>If \\(a_i &lt; b_i\\), we set \\(\\mathtt{carry}\\) to \\(1\\). If we are at the most significant byte, we output \\(1\\).</li> <li>If \\(a_i = b_i\\), we let \\(\\mathtt{carry}\\) unchanged in order to maintain the previous decision. If we are at the most significant byte, we output \\(\\mathtt{carry}\\).</li> <li>If \\(a_i &gt; b_i\\), we set \\(\\mathtt{carry}\\) to \\(0\\). If we are at the most significant byte, we output \\(0\\). </li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#signed-less-than","title":"Signed Less Than","text":"<p>In computer science, the most common method of representing signed integers on computers, is called \\textbf{two's complement}. When the most significant bit is a one, the number is signed as negative. The way to express a negative integer \\(x\\) into two's complement form is chosen so that, among integers of the same sign, the lexicographical order is maintained. That is, if \\(a &lt; b\\) are signed integers of the same sign, then its two's complement representations preserve the same order. This will not be true if the signs are different. For example, it is not surprising that $$ 000\\dots0 &gt; 111\\dots1 $$ using the two's complement encoding, because \\(111\\dots1\\) is negative and \\(000\\dots0\\) is positive. The two's complement form of negative integer \\(x\\) in a \\(N\\)-bits system is the binary representation of \\(2^N - x\\). For example, let \\(x = -1\\) and \\(N = 4\\). Then, $$ 10000 - 0001 = 1111. $$ Hence, \\(-1 = 1111\\) in this representation. It is easy to see that \\(-2 = 1110\\) because $$ 10000 - 0010 = 1110. $$</p> <p>Hence, observe that \\(-1 &gt; -2\\) because \\(1111 &gt; 1110\\) and conversely: the order is preserved for integers of the same sign. </p> <p>We will describe a method to compare signed integers byte-wise. First of all, let us analyze the order among all the signed bytes, in order to understand how to compare them. Once we achieve this, the strategy will be very similar to the previous Less Than. </p> <p>Let \\(a = (a_{31}, a_{30}, \\dots, a_0)\\) and \\(b = (b_{31}, b_{30}, \\dots, b_0)\\) be the byte-representation of the 256-bits unsigned integers \\(a\\) and \\(b\\). We will define \\(\\texttt{sgn}(a) = a_{31, 7}\\), where $$ a_{31} = \\sum_{i = 0}^7 a_{31, i} \\cdot 2^i $$ is the binary representation of \\(a_{31}\\). That is, \\(\\texttt{sgn}(a)\\) is the most significant bit of \\(a\\) or, equivalently, the \"sign\" of \\(a\\). In a similar way, we define \\(\\texttt{sgn}(b)\\). Observe that it is easy to compare \\(a\\) and \\(b\\) if \\(\\texttt{sgn}(a) \\neq \\texttt{sgn}(b)\\). For example, $$ a = \\mathtt{0b11111111} = \\mathtt{0xFF} &lt; \\mathtt{0x00} = \\mathtt{0b00000000} = b $$ because \\(\\texttt{sgn}(a) &gt; \\texttt{sgn}(b)\\) i.e. \\(a\\) is negative and \\(b\\) is positive. If \\(\\texttt{sgn}(a) \\neq \\texttt{sgn}(b)\\), we can simply compare \\(a\\) and \\(b\\) using the same strategy as before, because the natural lexicographic order is preserved in this case. Then, we have the following cases when comparing \\(a\\) and \\(b\\):</p> <ol> <li>If \\(\\texttt{sgn}(a) = 1\\) and \\(\\texttt{sgn}(b) = 0\\), then \\(a &lt; b\\).</li> <li>If \\(\\texttt{sgn}(a) = 0\\) and \\(\\texttt{sgn}(b) = 1\\), then \\(a &gt; b\\).</li> <li>If \\(\\texttt{sgn}(a) = \\texttt{sgn}(b)\\), the order is the usual one and hence, we already know how to compare \\(a\\) and \\(b\\). </li> </ol> <p>\u200b   </p> <p>Recall that we are processing the bytes of \\(a\\) and \\(b\\) from the less significant bytes to the most significant bytes. Hence, we need to adapt our strategy following this order. The strategy will be almost the same than in the unsigned operation. </p> <ol> <li>First of all, we start comparing \\(a_0\\) and \\(b_0\\). </li> </ol> <p>\u200b   (a) If \\(a_0 &lt; b_0\\), we set \\(\\texttt{carry} = 1\\).</p> <p>\u200b   (b) Otherwise we set \\(\\texttt{carry} = 0\\).  </p> <ol> <li>For all \\(0 &lt; i &lt; 31\\), we compare \\(a_i\\) and \\(b_i\\).</li> </ol> <p>\u200b   (a) If \\(a_i &lt; b_i\\), we set \\(\\texttt{carry} = 1\\).</p> <p>\u200b   (b) If \\(a_i = b_i\\), we leave \\(\\texttt{carry}\\) unchanged from the previous step.</p> <p>\u200b   (c) Otherwise, we set \\(\\texttt{carry} = 0\\).</p> <ol> <li>Now, we have to compare the last byte. We follow the described strategy of comparing the signs:</li> </ol> <p>\u200b   (a) If \\(\\texttt{sgn}(a) &gt; \\texttt{sgn}(b)\\), we output a \\(1\\), so \\(a &lt; b\\).</p> <p>\u200b   (b) If \\(\\texttt{sgn}(a) &lt; \\texttt{sgn}(b)\\), we output a \\(0\\), so \\(a &lt; b\\).</p> <p>\u200b   (c) If \\(\\texttt{sgn}(a) = \\texttt{sgn}(b)\\), we compare the last bytes \\(a_{31}\\) and \\(b_{31}\\) in the same way we have compare the previous bytes. We output \\(0\\) or \\(1\\) accordingly.</p> <p>\u200b             (i)   If \\(a_{31} &lt; b_{31}\\), we output a \\(1\\), so \\(a &lt; b\\).</p> <p>\u200b            (ii)   If \\(a_{31} = b_{31}\\), we output the previous \\(\\texttt{carry}\\), maintaining the last decision.</p> <p>\u200b           (iii)   Otherwise, we output a \\(0\\), so \\(a \\not &lt; b\\). </p> <p>Let us exemplify the previous procedure setting \\(a = \\mathtt{0xFF FF FF 00}\\) and \\(b = \\mathtt{0x00 FF FF FF}\\). We know that \\(a &lt; b\\), so we should output a \\(1\\). Observe that the less significant byte of \\(a\\) is leaser than the less significant byte of \\(b\\). Hence, we should put \\(\\texttt{carry}\\) equal to \\(1\\). The next two bytes of \\(a\\) and \\(b\\) are both equal to \\(\\mathtt{0xFF FF}\\), therefore we maintain \\(\\texttt{carry}\\) unchanged equal to \\(1\\). However, since \\(a\\) is negative and \\(b\\) is positive, we should change the decision and output a \\(1\\), independently of the \\(\\texttt{carry}\\). </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#equality","title":"Equality","text":"<p>We want to describe the equality comparator byte-wise. For unsigned \\(256\\)-bits integers, the operation \\(=\\) will output \\(c = 1\\) if \\(a = b\\) and \\(c = 0\\) otherwise. This operation is very simple to describe byte-wise, since \\(a = b\\) if and only if all its bytes coincide. </p> <p>Let us compare \\(a = \\mathtt{0xFF 00 a0 10}\\) and \\(b = \\mathtt{0xFF 00 00 10}\\) byte-wise. Observe that the first byte is the same \\(\\mathtt{0x10}\\), however the next byte are different \\(\\mathtt{0xa0} \\neq \\mathtt{0x00}\\). Hence, we can finish here and state that \\(a \\neq b\\). </p> <p>We will describe an algorithm in order to proceed processing all the bytes. We will use a carry to mark up when a difference among bytes has \\(\\textbf{not}\\) been found (i.e. if \\(\\texttt{carry}\\) reach \\(0\\), then \\(a\\) and \\(b\\) should differ). Hence, the algorithm to compare two \\(32\\)-bytes integers \\(a = (a_{31}, a_{30}, \\dots, a_{0})\\) and \\(b = (b_{31}, b_{30}, \\dots, b_0)\\) is the following:</p> <ol> <li> <p>First of all, since no differences have been found up to this point, set \\(\\texttt{carry}\\) equal to \\(1\\).</p> </li> <li> <p>Now, compare \\(a_0\\) and \\(b_0\\),</p> </li> </ol> <p>(a)  If \\(a_0\\) and \\(b_0\\) are equal, then leave \\(\\texttt{carry}\\) unchanged equal to \\(1\\).</p> <p>(b)  If \\(a_0 \\neq b_0\\), then set \\(\\texttt{carry}\\) equal to \\(0\\), which will imply that \\(a \\neq b\\).</p> <ol> <li>When comparing bytes \\(a_i\\) and \\(b_i\\) for \\(0 &lt; i \\leq 31\\).</li> </ol> <p>(a)  If \\(a_i = b_i \\textbf{ and } \\texttt{carry} = 1\\), we should leave \\(\\texttt{carry}\\) unchanged and, if \\(i = 31\\), we should output a \\(1\\) because \\(a = b\\). The reason of demanding \\(\\texttt{carry} = 1\\) in the enter condition is because we should ensure that, if \\(\\texttt{carry} = 0\\) in a previous step, we must never enter to this block and change the non-equality decision. This is because if \\(a_i \\neq b_i\\) for some \\(i\\), then \\(a \\neq b\\).</p> <p>(b)  Hence, if \\(a_i \\neq b_i\\), we should set \\(\\texttt{carry} = 0\\) and output a \\(0\\) if \\(i = 31\\). </p> <p>\u200b   </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#bitwise-operations","title":"Bitwise Operations","text":"<p>We will describe all bitwise operations at once because they are the easiest ones, since we do not need to introduce carries. </p> <p>Now, the idea is to extend this operation bitwise. That is, if we have the following binary representations of \\(a = (a_{31}, a_{30}, \\dots, a_{0})\\) and \\(a = (b_{31}, b_{30}, \\dots, b_{0})\\) where \\(a_i, b_i \\in \\{0, 1\\}\\), then we define,</p> \\[ a \\star b = (a_i \\star b_i)_i = (a_{31} \\star b_{31}, a_{30} \\star b_{30}, \\dots, a_0 \\star b_0) \\] <p>for \\(\\star\\) being \\(\\land, \\lor\\) or \\(\\oplus\\). </p> <p>For example, if \\(a = \\mathtt{0xCB} = \\mathtt{0b11001011}\\) and \\(b = \\mathtt{0xEA} = \\mathtt{0b11101010}\\) then,</p> \\[ \\begin{aligned} a \\land b &amp;= \\mathtt{0b11001010} = \\mathtt{0xCA},\\\\ a \\lor b &amp;= \\mathtt{0b11101011} = \\mathtt{0xEB},\\\\ a \\oplus b &amp;= \\mathtt{0b00100001} = \\mathtt{0x21}. \\end{aligned} \\]"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#the-binary-sm-in-summary","title":"The Binary SM In Summary","text":"<p>The Binary SM has 8 registries, each with an 32-bit Input/Output capacity. i.e., A total of 256 bits.</p> <p>It carries out binary computations in accordance with instructions from the Main SM Executor.</p> <p>The binary operations it executes, together with their specific opcodes, are;</p> <ol> <li>The common operations; the No-Operation <code>NOP</code>, Addition <code>ADD</code> and Subtraction <code>SUB</code>. Their corresponding special opcodes are; <code>0</code>, <code>1</code> and <code>2</code>, respectively.</li> <li>The Boolean operations; \\(\\text{Less Than }\\) <code>LT</code>, \\(\\text{Greater Than }\\) <code>GT</code>, \\(\\text{Signed Less Than }\\) <code>SLT</code>, \\(\\text{Signed Greater Than }\\) <code>SGT</code>, \\(\\text{Equal }\\) <code>EQ</code>  and  \\(\\text{Is-Zero }\\) <code>ISZERO</code>. Their special opcodes are, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code> and <code>7</code>, respectively.</li> <li>The logical operations; <code>AND</code>, <code>OR</code>,  <code>XOR</code> and <code>NOT</code>, each with its special opcode; <code>9</code> ,<code>10</code>, <code>11</code> and <code>12</code>, respectively.</li> </ol>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#the-nutshell","title":"The Nutshell","text":"<p>Firstly, the Binary SM Executor translates the Binary Actions into the PIL language. </p> <p>Secondly, it executes the Binary Actions. </p> <p>And thirdly, it uses the Binary PIL program binary.pil, to check correct execution of the Binary Actions using Plookup.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#translation-to-pil-language","title":"Translation to PIL Language","text":"<p>It builds the constant polynomials, which are generated once-off at the beginning. These are; </p> <ul> <li>the 4 bits long operation code <code>P_OPCODE</code>, </li> <li>the 1-bit Carry-in  <code>P_CIN</code>, </li> <li>the Last-byte <code>P_LAST</code>, </li> <li>the 1 byte input polynomials <code>P_A</code> and <code>P_B</code>, </li> <li>the 16-bit output polynomial <code>P_C</code>, </li> <li>the 1-bit Carry-out <code>P_COUT</code>.</li> </ul> <p>It also creates constants required in the Binary PIL program;</p> <ul> <li><code>RESET</code> is used to reset registry values every time the state machine completes a cycle of state transitions,</li> <li><code>FACTOR</code>, which is an array of size 8, is used for correct placement of output registry values.</li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#execution-of-binary-actions","title":"Execution of Binary Actions","text":"<p>The crux of the Binary SM Executor is in the <code>lines 371 to 636</code> of sm_binary.js. This is where it executes Binary Actions. </p> <ol> <li> <p>It takes the committed polynomials A, B and C, breaks them into bytes (in little-endian form). </p> </li> <li> <p>It sequentially pushes each triplet of bytes (<code>freeInA</code>, <code>freeInB</code>, <code>freeInC</code>) into their corresponding registries (<code>ai</code>, <code>bi</code>, <code>ci</code>).</p> </li> </ol> <p>i.e., It runs one for-loop for all committed polynomials (A, B, C), over all the bytes of the 8 registries, which are altogether 32 bytes per committed polynomial. </p> <p>Recall that <code>LATCH_SIZE = REGISTERS_NUM * BYTES_PER_REGISTER</code> = 8 registries * 4 bytes. It hence amounts to 32 bytes for each committed polynomial.</p> <ol> <li> <p>Once the 256-bit LATCH is built, it checks the opcodes and then computes the required binary operations in accordance with the instructions of the Main SM. </p> </li> <li> <p>It also generates the final registries. </p> </li> </ol>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Binary/Binary/#the-binary-pil-program","title":"The Binary PIL (Program)","text":"<p>There are two types of inputs to the Binary PIL program: the constant polynomials and the committed polynomials.</p> <p>The program operates byte-wise to carry out 256-bit Plookup operations.</p> <p>Each row of the lookup table is a vector of the form; { <code>P_LAST</code>, <code>P_OPCODE</code>, <code>P_A</code>, <code>P_B</code>, <code>P_CIN</code>, <code>P_C</code>, <code>P_COUT</code> },  consisting of the constant polynomials created by the Binary SM Executor. As seen above,</p> <ul> <li><code>P_LAST</code> is the Last-byte, </li> <li><code>P_OPCODE</code> is the 4-bit operation code, </li> <li><code>P_A</code> and <code>P_B</code>, are the 1-byte input polynomials,</li> <li> <p><code>P_CIN</code> is the 1-bit Carry-in,</p> </li> <li> <p><code>P_C</code> is the 16-bit output polynomial, </p> </li> <li><code>P_COUT</code> is the 1-bit Carry-out.</li> </ul> <p>The Binary PIL program takes in byte-size inputs, as in the Binary SM Executor, each 256-bit input committed polynomial is first broken into 32 bytes.</p> <p>For each of the 32 triplets <code>freeInA</code>, <code>freeInB</code> and <code>freeInC</code>, tallying with the three 256-bit committed polynomials  A,B and C, the Binary PIL program,</p> <ol> <li>Prepares a Plookup input vector of the form;  {<code>last</code>, <code>opcode</code>, <code>freeInA</code>, <code>freeInB</code>, <code>cIn</code>, <code>freeInC</code>, <code>cOut</code>}, where each element is a byte.</li> <li>Runs Plookup,</li> </ol> <p><code>{last,opcode,freeInA,freeInB,cIn,freeInC,cOut} in {P_LAST,P_OPCODE,P_A,P_B,P_CIN,P_C,P_COUT};</code></p> <ol> <li>Resets registry values at the end of the 32 cycles using <code>RESET</code>, and utilising <code>FACTOR</code> for correct placement of values. For e.g., <code>a0' = a0 * (1 - RESET) + freeInA * FACTOR[0];</code></li> </ol> <p>Special variables, <code>useCarry</code> and <code>c0Temp</code>, are used for managing updates and assignments of values, particularly for Boolean operations, where the output <code>c0</code> registry value is either <code>TRUE = 1</code> or <code>FALSE = 0</code>. Hence the Lines 104 and 105 of code;</p> <p>Line 104.    <code>c0Temp' = c0Temp * (1 - RESET) + freeInC * FACTOR[0];</code></p> <p>Line 105.    <code>c0' = useCarry * (cOut - c0Temp ) + c0Temp;</code></p> <p>For all non-Boolean operations; the default value for <code>useCarry</code> is zero, making <code>c0' = c0Temp</code>. The value of <code>c0'</code> is therefore of the same form as other <code>ci'</code> update values.</p> <ol> <li>The output of the Binary PIL program is therefore a report of either <code>pass</code> or <code>fail</code>.</li> </ol>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Complementary/Complementary/","title":"Complementary","text":""},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Complementary/Complementary/#global","title":"Global","text":"<p>The Global State Machine is a state machine that computes various constant polynomials used by some of the state machines of the zkEVM. These polynomials are typically used for the distinct lookup arguments that PIL is able to perform.</p> <p>At this moment, the Global SM used by the zkEVM is made of:</p> <pre><code>include \"config.pil\";\n\nnamespace Global(%N);\n    pol constant L1;\n    pol constant BYTE;\n    pol constant BYTE2;\n</code></pre> <p>At this moment, the polynomials computed by the Global SM are showed in Table 1.</p> <p> Row L1 Row BYTE Row BYTE2 1 1 1 0 1 0 2 0 2 1 2 1 3 0 3 2 3 2 \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) 256 0 256 255 65536 65535 257 0 257 0 65537 0 258 0 258 1 65538 1 \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) N 0 N 255 N 65535 <p></p>  Table 1: Description of the polynomials computed by the Global State Machine."},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Complementary/Complementary/#byte4","title":"Byte4","text":"<p>The Byte4 State Machine takes as input two \\(16\\)-bit numbers and generates a \\(32\\)-bit number from them. This generation is obtained through the concatenation of the input numbers. A working example can be find in Table 2.</p> <p> row SET freeIn out out' 1 0 \\(\\textsf{0xba04}\\) \\(\\textsf{0x00000000}\\) \\(\\textsf{0x0000ba04}\\) 2 1 \\(\\textsf{0x3ff2}\\) \\(\\textsf{0x0000ba04}\\) \\(\\textsf{0xba043ff2}\\) 3 0 \\(\\textsf{0x4443}\\) \\(\\textsf{0xba043ff2}\\) \\(\\textsf{0x00004443}\\) 4 1 \\(\\textsf{0xc1d1}\\) \\(\\textsf{0x00004443}\\) \\(\\textsf{0x4443c1d1}\\) 5 0 \\(\\textsf{0xd11e}\\) \\(\\textsf{0x4443c1d1}\\) \\(\\textsf{0x0000d11e}\\) 6 1 \\(\\textsf{0x6ab9}\\) \\(\\textsf{0x0000d11e}\\) \\(\\textsf{0xd11e6ab9}\\) 7 0 \\(\\vdots\\) \\(\\textsf{0xd11e6ab9}\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) <p></p>  Table 2: Example of they Byte4 SM.  <p>The Byte4 SM works as follows. In one clock, the first input \\(x\\) is moved to the \\(\\textsf{out}\\) column. In the following clock, \\(x\\) is concatenated to the second input \\(y\\) and moved to the \\(\\textsf{out}\\) column. In order to make this \"moving\" possible, we introduce a constant polynomial, called \\(\\textsf{SET}\\), defined as follows:</p> \\[\\begin{aligned} \\textsf{SET} = \\begin{cases} 1, &amp; \\text{if } \\textsf{row} \\text{ is even}\\\\ 0, &amp; \\text{if } \\textsf{row} \\text{ is odd} \\end{cases} . \\end{aligned}\\] <p>Once \\(\\textsf{SET}\\) is defined, the moving action is naturally enforced with the following constraint:</p> \\[ \\textsf{out}' = (1 - \\textsf{SET}) \\cdot \\textsf{freeIn} + \\textsf{SET} \\cdot (2^{16} \\cdot \\textsf{out} + \\textsf{freeIn}). \\] <p>Notice that when \\(\\textsf{SET} = 0\\), then \\(\\textsf{out}' = \\textsf{freeIn}\\), i.e., \\(\\textsf{out}\\) is set to be the first input. In contrast, when \\(\\textsf{SET} = 1\\), then \\(\\textsf{out}' = 2^{16} \\cdot \\textsf{out} + \\textsf{freeIn}\\), i.e., the previous input (stored in \\(\\textsf{out}\\)) is set to be the upper part of \\(\\textsf{out}\\), while the second input is set to be the lower part of \\(\\textsf{out}\\). To achieve soundness, we must also check that both inputs are elements made at most of \\(2\\) bytes.</p> <p>The previous constraints are reflected in the PIL code for this SM:</p> <pre><code>include \"config.pil\";\ninclude \"global.pil\";\n\nnamespace Byte4(%N);\n  // Constant Polynomials\n  pol constant SET; // 0, 1, 0, 1, 0, 1, ...\n\n  // Input Polynomials\n  pol committed freeIn;\n\n  // State Variables\n  pol committed out;\n\n  // Constraints\n  freeIn in Global.Byte2; // Check that input is in [0,1,...,65535]\n  out' = (1 - SET)*freeIn + SET*(2**16*out + freeIn);\n</code></pre>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Complementary/Configuration-File/","title":"Configuration File","text":"<p>The main purpose of this file is to provide configuration (e.g. global parameters) used across the different state machines that compose the same project. It is typically called <code>config.pil</code> and it is equivalent to the global configuration that is typically used in other languages and stored in the source directory of user's projects.</p> <p>For the shake of building the zkEVM, the configuration file is composed by:</p> <pre><code>constant %N = 2**21;\n</code></pre> <p>Here, \\(N\\) is the upper bound on the number of rows that the distinct state machines that give form to the zkEVM are limited to.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/01-Intro-SMs-for-Hashing/","title":"Introduction","text":"<p>The zkEVM utilises two state machines for hashing purposes; The Keccak State Machine and the \\(\\text{POSEIDON}\\) State Machine. The Keccak-256 hash function is used for seamless compatibility with the EVM, while \\(\\text{POSEIDON}\\) is most suitable in the zkProver context because it is a STARK-friendly hash function.</p> <p>Keccak and \\(\\text{POSEIDON}\\) are both sponge constructions by design.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/01-Intro-SMs-for-Hashing/#the-sponge-construction","title":"The Sponge Construction","text":"<p>A generic sponge construction is a simple iterated construction for building a function  $$ F: \\mathbb{Z}^* \\to \\mathbb{Z}^l $$</p> <p>with an input of variable-length and arbitrary output length based on a fixed-length permutation $$ f: \\mathbb{Z}^b \\to \\mathbb{Z}^b $$</p> <p>operating on a fixed number \\(b\\) of bits.</p> <p>The array of \\(b\\) bits that \\(f\\) keeps transforming is called the state, and \\(b\\) is called the width of the state.</p> <p>The state array is split into two chunks, one with \\(r\\) bits and the other with \\(c\\) bits. So that the width \\(b = r + c\\)  where \\(r\\) is called the bitrate (or simply rate) and \\(c\\) is called the capacity.</p> <p>The sponge construction can also be described in terms of phases;</p> <ul> <li>The Init Phase: In this phase the input string is either padded to reach the \\(r\\)-bit length (if the input string was shorter than \\(r\\) bits), or it is split into \\(r\\)-bit long chunks with the last one being padded to reach the \\(r\\)-bit length (if the input string was longer than \\(r\\) bits). A reversible padding rule, specific to a hash function, is applied.</li> </ul> <p>The hash function's state is initialised to a \\(b\\)-bit vector (or array) of zeros.</p> <ul> <li>The Absorbing Phase: In this phase, the \\(r\\)-bit input blocks are XORed sequentially with the first \\(r\\) bits of the state, interleaved with applications of the permutation function \\(f\\). This continues until all input blocks have been XORed with the state. </li> </ul> <p>Observe that the last \\(c\\) bits corresponding to the capacity value does not absorb any input from the outside. </p> <ul> <li>The Squeezing Phase: In this phase, the first \\(r\\) bits of the state are returned as output blocks, interleaved with applications of the function \\(f\\). The number of output blocks is chosen at will by the user. Observe that the last \\(c\\) bits corresponding to the capacity value are never output during this phase. Actually, if the output exceeds the specified length, then it gets truncated to the required size.</li> </ul> <p>A schema of the sponge construction is shown in the Figure below.</p> <p></p>  Figure 1: A Sponge Function Construction  <p>The elements that completely describe a single instance of a sponge construction are: the fixed-length permutation \\(f\\), the padding rule pad, the bitrate value \\(r\\) and the capacity \\(c\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/02-Keccak-Framework/","title":"Keccak Hashing Framework","text":"<p>The zkEVM, as a L2 zk-rollup for Ethereum, utilises the Keccak hash function in order to achieve seamless compatibility with the Layer 1, the Ethereum blockchain.</p> <p>However, instead of implementing the Keccak-256 hash function as one state machine, the zkEVM does this in a framework consisting of four state machines. And these are;</p> <ol> <li> <p>The Padding-KK SM sm_paddingkk.cpp is used for padding purposes, as well as validation of hash-related computations pertaining to the Main SM's queries.</p> </li> <li> <p>The Padding-KK-Bit SM sm_padding_kkbit.cpp converts between two string formats, the bytes of the Padding-KK SM to the bits of the Keccak-f Hashing SM, and vice-versa.</p> </li> <li> <p>The Bits2Field SM, sm_bits2field.cpp, is used specifically for parallelizing implementation of the Keccak-f SM. It operates like a multiplexer of sorts between the Padding-KK-Bit SM and the Keccak-f SM. This state machine is named Bits2Field because it initially ensured correct packing of bits from \\(44\\) different blocks of the Padding-KK-Bit SM into a single field element.</p> </li> </ol> <p>Although the name \"Bits2Field SM\" has been retained in the Mango testnet release, the Bits2Field SM now packs bits from \\(44\\) different blocks of the Padding-KK-Bit SM into a single field element. That is, it currently functions as a \"\\(44\\)-bits-to-\\(1\\)-field-element\" multiplexer.</p> <ol> <li>The Keccak-f SM, sm_keccakf.cpp, computes hashes of strings at the request of the Main SM. Although the Keccak-f SM is a binary circuit, instead of executing on a bit-by-bit basis, it executes on a 44bits-by-44bits basis. This is tantamount to running \\(44\\) hashing circuits in parallel.</li> </ol> <p>As depicted in the below figure, the Padding-KK SM is the Main SM's gateway to the Keccak hashing state machines.</p> <p></p>  Figure 1: Keccak State Machine Design Schema"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/","title":"Padding-KK State Machine","text":"<p>The Padding-KK state machine serves as the gateway to all Keccak-related state machines. It is therefore responsible for handling queries from the Main state machine. The common queries are requests for digests of messages, together with validation of these digests.</p> <p>This document presents an explanation of how the Padding-KK SM operates. How it checks that padding rules are adhered to, as well as validating correctness of hash values, lengths of input strings, and that input strings are properly read.</p> <p>Firstly, note that operations of the Padding-KK SM are byte-wise based, while the Keccak-f SM's operations are bit-wise based. The Padding-KK-Bit SM takes care of this disparity in string formats.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#padding-and-the-keccak-f-sm","title":"Padding And The Keccak-f SM","text":"<p>Although the hashing of messages is carried out by the Keccak-f SM, the padding happens in the Padding-KK SM. Messages are presented to the Padding-KK SM as byte-strings in hexadecimal form. But the Padding-KK-Bit SM ensures that these are presented as bit-strings to the Keccak-f SM.</p> <p>Even though Keccak-f SM receives strings of any length as inputs, each input-message to the Keccak-f SM is first split into blocks of 1088 bits (i.e., 136 bytes), called the bit rate (or rate). If the tail-end of the splits is shorter than 136 bytes, or if the original message is shorter than 136 bytes, a specific string is appended to it in order to form a full 136-byte string. The appended bits (or bytes) are referred to as the padding.</p> <p>Keccak's first padding-rule is to append the string \\(\\mathtt{100^*1}\\) of the appropriate length. That is, the padding always consists of two 1's and a string of 0's between them.</p> <p>The second padding rule: If the input-message is exactly 136 bytes long, or a multiple of 136 bytes, then a block of 136 bytes consisting of just the padding \\(\\mathtt{100^*1}\\), must be appended.</p> <p>It is crucial to emphasise that the Polygon zkEVM follows the Keccak construction used in the Ethereum. So then the Padding-KK SM does not append any other 'fixed' bits to the padding, such as appending \"\\(\\mathtt{01}\\)\" as it is done in the FIPS's SHA-3. Therefore, as far as the Keccak-f hash function is concerned, the Polygon zkEVM does not follow the FIPS.202 Standard.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#input-strings-and-padding","title":"Input Strings And Padding","text":"<p>Consider the strings \\(\\mathtt{s_1, s_2, \\dots , s_n}\\) that need to be hashed.</p> <p>Note that the bits (or bytes) of these strings cannot be simply combined and presented as one stream of bits (or bytes) as though they belong to one long string. But each string \\(\\mathtt{s_i}\\) need to be treated as an individual string, and thus must first be separately padded in line with the above-mentioned padding rules. Only thereafter, depending on the SM involved, can the bytes or the bits be fed into the relevant SM. </p> <p>The idea here is to map each string to one or several blocks of 136 bytes (1088 bits), and include the proper padding at the tail-end part. See Figure below.</p> <p></p>  Figure 1 : Schema of input strings allocation in Keccak  <p>Observe that, as shown in the first string in the Figure above; Whenever the length of a certain string is a multiple of the block length of 136 bytes, a new block containing only the padding must be appended. Once this is done, the new resulting string can be provided to the Keccak-f SM for hashing. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#dealing-with-main-sm-queries","title":"Dealing With Main SM Queries","text":"<p>The Padding-KK SM is in charge of validating that the padding rule is correctly performed, as well as validating each of the prescribed operations;</p> <ol> <li>Validate the lengths of given strings \\(\\{\\mathtt{s_i}\\}\\). (i.e., length check),</li> <li>Validate the hashes of certain strings \\(\\{\\mathtt{s_i}\\}\\). (i.e., digest check), </li> <li>Validate reads from 1 to 32 bytes of string \\(\\mathtt{s_i}\\). (i.e., read check).</li> </ol> <p>Next is to prepare the machinery that will enable the Padding-KK SM achieve these three checks. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#setting-up-columns-for-verification-purposes","title":"Setting Up Columns For Verification Purposes","text":"<p>We now design a series of columns that will enable us to completely verify correctness of every state transitions.</p> <ul> <li>\\(\\texttt{freeIn}\\): This register will store every byte of the padded input (as commented before), one byte per row.</li> <li> <p>\\(\\texttt{address}\\): This register will store an increasing sequence of integers starting from 0, changing its value at the beginning of a new string. Of course, an address completely determines the corresponding string of a certain byte.</p> </li> <li> <p>\\(\\texttt{connected}\\): This register represents the connection between two blocks. If \\(\\texttt{connected}\\) is 1, the actual block is in the same string with the previous block. Otherwise, the last block is in the previous string.</p> </li> <li> <p>\\(\\texttt{lastBlock}\\): This register flags the last row of every block. If \\(\\texttt{lastBlock}\\) is 1, the next block will start in the next row of the table.</p> </li> <li> <p>\\(\\texttt{rem}\\): For each string, this register is a decreasing sequence of signed integers. Starting at the length of the current string and it keeps decreasing until the last block of the string is reached. Observe that this value can be negative since a padding may be present in the string. (\\(\\texttt{rem}\\) is short for 'remaining'.)</p> </li> <li> <p>\\(\\texttt{len}\\): For each string, this register stores original length (i.e., the length of the string before padding was appended). Therefore, this register remains constant for all rows of each string. Observe that, at the first row of each string, \\(\\texttt{len}\\) coincides with \\(\\texttt{rem}\\).</p> </li> <li> <p>\\(\\texttt{remIsZero}\\): A computed register which is 1 whenever \\(\\texttt{rem}\\) is zero, and 0 otherwise.</p> </li> <li> <p>\\(\\texttt{spare}\\): The \\(\\texttt{spare}\\) register is 1 just after the byte \\(\\texttt{0x01}\\), corresponding to the appearance of padding bits. Observe that it can happen that \\(\\texttt{spare}\\) is constantly 0 among a full string. This is because we can have the situation where the padding only consists of the byte \\(\\texttt{0x81}\\).</p> </li> <li> <p>\\(\\texttt{lastHash}\\): This register is actually computed from the registers \\(\\texttt{spare}\\), \\(\\texttt{remIsZero}\\) and \\(\\texttt{lastBlock}\\) as follows,   $$   \\texttt{lastHash = lastBlock \u00b7 (spare + remIsZero)} \\tag{Eqn.1}   $$   This means \\(\\texttt{lastHash}\\) will be 1 whenever two things hold true; First, if \\(\\texttt{lastBlock} = 1\\), and secondly, if the next block to be processed is contained in the next string. </p> </li> </ul> <p>Observe that \\(\\texttt{spare}\\) and \\(\\texttt{remIsZero}\\) cannot simultaneously be \"1\" (i.e., not in the same row). Moreover, it is very important to include \\(\\texttt{remIsZero}\\) in this computation because \\(\\texttt{spare}\\) alone cannot help detect that padding has occurred. For instance, if \\(\\mathtt{pad = 0x81}\\), then \\(\\texttt{spare}\\) would remain constant, continuing to record 0's as if no padding took place.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#example-1-padding-check-using-columns","title":"Example 1. Padding Check Using Columns","text":"<p>Let us illustrate this design with a table, using the columns defined above. Suppose the following strings have been padded and are ready for hashing; $$ \\mathtt{s_0 = 8000\\dots 00016f6c6c6568}\\text{ } \\text{ } \\text{ } \\text{ }\\text{ }\\text{ }\\text{ } \\ \\mathtt{s_1 = 8000012f\\dots 11|616c\\dots 6966} $$ where \"|\" indicates the end of a 136-byte block. In the below table, these 136-byte splits between blocks are indicated with a horizontal line.</p>  Table 1 : Padding Check And Columns Design Example  \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{freeIn} &amp; \\texttt{addr} &amp; \\texttt{connected} &amp; \\texttt{lastBlock} &amp; \\texttt{rem} &amp; \\texttt{len} &amp; \\texttt{remIsZero} &amp; \\texttt{spare} &amp; \\texttt{lastHash} \\\\ \\hline  \\mathtt{0x68} &amp; 0 &amp; 0 &amp; 0 &amp; 5 &amp; 5 &amp; 0 &amp; 0 &amp; 0 \\\\  \\mathtt{0x65} &amp; 0 &amp; 0 &amp; 0 &amp; 4 &amp; 5 &amp; 0 &amp; 0 &amp; 0 \\\\  \\mathtt{0x6c} &amp; 0 &amp; 0 &amp; 0 &amp; 3 &amp; 5 &amp; 0 &amp; 0 &amp; 0 \\\\  \\mathtt{0x6c} &amp; 0 &amp; 0 &amp; 0 &amp; 2 &amp; 5 &amp; 0 &amp; 0 &amp; 0 \\\\  \\mathtt{0x6f} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 5 &amp; 0 &amp; 0 &amp; 0 \\\\ \\mathtt{0x01} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 5 &amp; 1 &amp; 0 &amp; 0 \\\\ \\mathtt{0x00} &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 5 &amp; 0 &amp; 1 &amp; 0 \\\\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\mathtt{0x00} &amp; 0 &amp; 0 &amp; 0 &amp; -129 &amp; 5 &amp; 0 &amp; 1 &amp; 0 \\\\ \\mathtt{0x80} &amp; 0 &amp; 0 &amp; 1 &amp; -130 &amp; 5 &amp; 0 &amp; 1 &amp; 1 \\\\ \\hline \\mathtt{0x66} &amp; 1 &amp; 0 &amp; 0 &amp; 269 &amp; 269 &amp; 0 &amp; 0 &amp; 0 \\\\ \\mathtt{0x69} &amp; 1 &amp; 0 &amp; 0 &amp; 268 &amp; 269 &amp; 0 &amp; 0 &amp; 0 \\\\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\mathtt{0x6c} &amp; 1 &amp; 0 &amp; 0 &amp; 135 &amp; 269 &amp; 0 &amp; 0 &amp; 0 \\\\ \\mathtt{0x61} &amp; 1 &amp; 0 &amp; 1 &amp; 134 &amp; 269 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline \\mathtt{0x11} &amp; 1 &amp; 1 &amp; 0 &amp; 133 &amp; 269 &amp; 0 &amp; 0 &amp; 0 \\\\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\mathtt{0x2f} &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 269 &amp; 0 &amp; 0 &amp; 0 \\\\ \\mathtt{0x01} &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 269 &amp; 1 &amp; 0 &amp; 0 \\\\ \\mathtt{0x00} &amp; 1 &amp; 1 &amp; 0 &amp; -1 &amp; 269 &amp; 0 &amp; 1 &amp; 0 \\\\ \\mathtt{0x80} &amp; 1 &amp; 1 &amp; 1 &amp; -2 &amp; 269 &amp; 0 &amp; 1 &amp; 1 \\\\ \\hline \\end{array} \\] <p>The above table illustrates how the columns can be used to record the executional trace of the Padding-KK State Machine. As it is our general approach, a strategy towards achieving verifiable computations, the next task is to describe the state transitions of the Padding-KK SM in terms of polynomials.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#step-by-step-description-of-state-transitions-in-pil","title":"Step-by-step Description Of State Transitions in PIL","text":"<p>By capturing the relationships between and among the columns (registers defined above) in terms of equations, amounts to translating the execution of the padding into a verification code written in PIL.</p> <p>\\(\\bf{(a)}\\)  In order to guarantee that the value recorded in the \\(\\texttt{rem}\\) register decreases until \\(\\texttt{lastHash}\\) is 1 (that is, the end of the string), use the relation, $$ \\mathtt{rem}'\\cdot \\mathtt{(1 - lastHash)\\ = (rem - 1)(1 - lastHash)} \\tag{Eqn.2} $$</p> <p>\\(\\bf{(b)}\\)  How can we validate the fact that \\(\\texttt{spare}\\) was constructed as expected? </p> <p>First observe that \\(\\texttt{spare}\\) changes to 1 immediately after a 1 was recorded in the \\(\\texttt{remIsZero}\\) register. (i.e., Immediately when the padding starts, and when \\(\\mathtt{pad} \\not= 0x81\\).)</p> <p>Secondly, notice that after this point, \\(\\texttt{spare}\\) remains 1 until (and including when) \\(\\texttt{lastHash}\\) equals 1. After which, \\(\\texttt{spare}\\) becomes 0. </p> <p>Hence, these behaviour can be captured as, $$ \\texttt{spare}' \\mathtt{ = (spare + remIsZero)\\cdot (1 - lastHash)} \\tag{Eqn.3} $$</p> <p>\\(\\bf{(c)}\\)  Verifying correctness of the \\(\\texttt{connected}\\) register requires two constraints;</p> <p>\u200b       (i) Checking that \\(\\texttt{connected}\\) is constant in each block $$ \\mathtt{connected'}\\cdot \\mathtt{(1 - lastBlock) = connected \\cdot (1 - lastBlock)}  \\tag{Eqn.4} $$ \u200b       (ii) Checking two specific situations,</p> <p>\u200b           Firstly, when \\(\\mathtt{lastBlock}\\) is 1 and \\(\\mathtt{lastHash}\\) is 0. In which case the next value of \\(\\texttt{connected}\\) should be 0, because of the block change but within the same string.</p> <p>\u200b           Secondly, when both \\(\\mathtt{lastBlock}\\) and \\(\\mathtt{lastHash}\\) are 1. In which case the next value of \\(\\texttt{connected}\\) should be 0, due to the string change.</p> <p>These two scenarios are verified with the following constraint, $$ \\mathtt{connected' \\cdot lastBlock = ( 1 - lastHash) \\cdot lastBlock} \\tag{Eqn.5} $$</p> <p>\\(\\bf{(d)}\\)  The \\(\\mathtt{len}\\) register is constant within each string. It must therefore satisfy this relationship, $$ \\mathtt{ len'\\cdot firstHash = len\\cdot (1 - lastHash)} \\tag{Eqn.6} $$</p> <p>\\(\\bf{(e)}\\)  Checking that \\(\\mathtt{len}\\) and \\(\\mathtt{rem}\\) coincide at the first state of each string, use the constraint,  $$ \\mathtt{len \\cdot firstHash = rem\\cdot firstHash} \\tag{Eqn.7} $$ \u200b       where \\(\\mathtt{firstHash}\\) is a committed column and it is such that \\(\\mathtt{firstHash' = lastHash}\\).</p> <p>In fact, \\(\\mathtt{firstHash}\\) is a shifted version of \\(\\mathtt{lastHash}\\), which is used to ensure that, when starting a</p> <p>string (and therefore, \\(\\mathtt{firstHash = 1}\\)), then \\(\\mathtt{len = rem}\\).</p>  Table 2 : Comparison Between 'lastHash' and 'firstHash'  \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{lastHash} &amp; \\texttt{firstHash}\\\\ \\hline \\text{ }\\text{ } \\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\cdots &amp; \\cdots\\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }0 &amp; 0 \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\cdots &amp; \\cdots\\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }1 &amp; 0 \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }0 &amp; 1 \\\\ \\text{  }\\text{ }\\text{ }\\text{  }\\text{ }\\text{} \\cdots &amp; \\cdots\\\\ \\hline \\end{array} \\] <p>\\(\\bf{(f)}\\)\u200b Let us now specify the relations that satisfy the \\(\\mathtt{addr}\\) register. As commented on before, \\(\\mathtt{addr}\\) is constant within each string. Hence, \\(\\mathtt{(addr' - addr) = 0}\\)  if and only if  \\(\\mathtt{1 - lastHash \\not= 0}\\). </p> <p>The constraint for the \\(\\mathtt{addr}\\) register is therefore $$ \\mathtt{(addr' - addr) \\cdot (1 - lastHash)  = 0}\\tag{Eqn.8} $$ Note that going from one string to the next, the values of the \\(\\mathtt{addr}\\) register form an increasing sequence (increasing by steps of 1 from one string to the next). </p> <p>However, since the polynomials utilised in this scheme are all cyclic (due to evaluations on roots of unity), there is a need to ensure that the \\(\\mathtt{addr}\\) register resets to \\(0\\) whenever the reading returns to the first row.</p> <p>For this purpose, a register called \\(\\mathtt{lastBlockLatch}\\) is added. And \\(\\mathtt{lastBlockLatch}\\) is 1, if \\(\\mathtt{lastBlock}\\) is 1 and the string, that the last block belongs to, is not the last one.</p> <p>Similarly, another register called \\(\\mathtt{lastHashLatch}\\) is added, and it is defined such that  $$ \\mathtt{ lastHashLatch = lastBlockLatch \\cdot (spare + remIsZero) } \\tag{Eqn.9} $$ See Table 3 below, for a comparison between the \\(\\texttt{latch}\\) and non-\\(\\mathtt{latch}\\) registers.  </p>  Table 3 : Comparison Between Latch and non-Latch registers  \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{lastBlock} &amp; \\texttt{lastBlockLatch} &amp; \\texttt{lastHash} &amp; \\texttt{lastHashLatch}\\\\ \\hline \\text{ }\\text{ } \\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots\\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; 1 &amp; 0 &amp; 0 \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots\\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; 1 &amp; 1 &amp; 1 \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 0 &amp; 0 &amp; 0  \\\\ \\text{  }\\text{ }\\text{ }\\text{  }\\text{ }\\text{} \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots\\\\ \\text{  }\\text{ }\\text{ }\\text{  }\\text{ }\\text{} \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; 0 &amp; 1 &amp; 0  \\\\\\hline \\end{array} \\] <p>\\(\\bf{(g)}\\)  In order to grapple with the increasing but cyclic sequence of \\(\\mathtt{addr}\\), the following constraint is used,  $$ \\mathtt{ ( addr' - 1 - addr)\\cdot lastHashLatch = 0} \\tag{Eqn.10} $$</p> <p>\\(\\bf{(h)}\\)  Now, checking whether \\(\\mathtt{remIsZero}\\) is 1 if and only if \\(\\mathtt{rem}\\) is 0, is done reversely by first committing the column \\(\\mathtt{remInv}\\), the inverse of \\(\\mathtt{rem}\\), and computing \\(\\mathtt{remIsZero}\\) as $$ \\mathtt{remIsZero = 1 \u2212 rem \u00b7 remInv} \\tag{Eqn.11} $$ And then, as usual, check the relation, \\(\\mathtt{remIsZero \\cdot rem = 0}\\).</p> <p>\\(\\bf{(i)}\\)  Next is the \\(\\mathtt{aFreeIn}\\) register which stores the input byte if and only if the current row does not corresponding to the padding. \\(\\mathtt{aFreeIn}\\) is computed from the \\(\\mathtt{remIsZero}\\), \\(\\mathtt{spare}\\) and \\(\\mathtt{lastHash}\\) registers. This ensures loading the padding bytes at their correct positions. </p> <p>In fact, this register will be used in the Plookup of the next state machine.</p> <p>Observe that  \\(\\mathtt{aFreeIn}\\) can be computed as $$ \\mathtt{aFreeIn = (1 \u2212 (remIsZero + spare)) \\cdot freeIn + remIsZero + lastHash \\cdot 0x80} \\tag{Eqn.12} $$</p> <p>Let us carefully analyse this equation;</p> <ul> <li>If \\(\\texttt{remIsZero}\\), \\(\\texttt{spare}\\) and \\(\\texttt{lastHash}\\) are all \\(0\\), then \\(\\texttt{aFreeIn}\\) equals \\(\\texttt{freeIn}\\). As mentioned above, at the non-padding rows, we just store \\(\\texttt{freeIn}\\).</li> <li>If \\(\\texttt{remIsZero}\\) is 1, \\(\\texttt{spare}\\) is 0 and \\(\\texttt{lastHash}\\) is 0, then \\(\\texttt{aFreeIn}\\) equals \\(\\texttt{0x01}\\), which is the first byte of the padding.</li> <li>If \\(\\texttt{remIsZero}\\) is 0, \\(\\texttt{spare}\\) is 1 and \\(\\texttt{lastHash}\\) is 0, then \\(\\texttt{aFreeIn}\\) equals \\(\\texttt{0x00}\\), which are the intermediate bytes of the padding.</li> <li>If \\(\\texttt{remIsZero}\\) is 0, \\(\\texttt{spare}\\) is 1 and \\(\\texttt{lastHash}\\) is 1, then \\(\\texttt{aFreeIn}\\) equals \\(\\texttt{0x80}\\), which is the last byte of the padding.</li> <li>Lastly, we should consider the special case where the padding is only the byte \\(\\texttt{0x81}\\). In this case, \\(\\texttt{spare}\\) is 0 at the last row meanwhile \\(\\texttt{lastHash}\\) and \\(\\texttt{remIsZero}\\) are both 1. Therefore, \\(\\texttt{aFreeIn}\\) equals \\(\\texttt{0x81}\\), as we wanted.</li> </ul> <p>See Table 4 below, for all the above cases when computing \\(\\texttt{aFreeIn}\\).</p>  Table 4 : Computation of aFreeIn cases  \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{remIsZero} &amp; \\texttt{spare} &amp; \\texttt{lastHash} &amp; \\texttt{aFreeIn} \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 0 &amp; 0 &amp; \\texttt{freeIn} \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; 0 &amp; 0 &amp; \\texttt{0x01} \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 1 &amp; 0 &amp; \\texttt{0x00} \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 1 &amp; 1 &amp; \\texttt{0x80} \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; 0 &amp; 1 &amp; \\texttt{0x81} \\\\ \\hline \\end{array} \\]"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#hash-output-check","title":"Hash Output Check","text":"<p>We have thus far only dealt with correct inputs of the padding. Now, we will introduce several columns to deal with the hash itself.</p> <p>Since KECCAK-256's output is 256 bits long, we use eight (8) registers each of 32 bits to store the result of the hash function. Denote these registers by  \\(\\{ \\mathtt{hash}_\\mathtt{i}\\ |\\ \\mathtt{i} \\in \\{0, 1, 2, \\dots , 7\\} \\}\\). </p> <p>As columns, these \\(\\{\\mathtt{hash}_\\mathtt{i}\\}\\) registers will remain constant within a single string, because they represent the hash of a given string. The following constraints are therefore added, $$ \\mathtt{(hash \u2032 \u2212hash )\u00b7(1\u2212lastHash) = 0} \\tag{Eqn.13} $$ A combination of other KECCAK-related state machines will be used to verify correctness of the output hash. The reason for this is that, for compatibility with the KECCAK-256 hash function, we first need to describe all inputs in terms of bits.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#length-and-read-check-operations","title":"Length And Read Check Operations","text":"<p>In this section we give a description of the design that will allow us to verify the lengths of input strings and the read operations.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#length-check","title":"Length Check","text":"<p>The length check is almost trivial because the \\(\\mathtt{len}\\) register has already been introduced. </p> <p>Suppose one is given a length \\(l\\) and an address \\(a\\). And the aim is to check if the string corresponding to the address \\(a\\) has length \\(l\\).</p> <p>The strategy is to use Plookup to verify that the given table contains a row with \\(\\mathtt{len} = l\\) and an address \\(\\mathtt{addr} = a\\) in the last row of the string (i.e., when \\(\\mathtt{lastHash} = 1\\)). That is to say, the table of columns; \\(\\mathtt{len}\\), \\(\\mathtt{addr}\\) and \\(\\mathtt{lastHash}\\); is as displayed in Table 5 below.</p>  Table 5 : Length Check with Plookup  \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{lastHash} &amp; \\texttt{ addr } &amp; \\texttt{ len }\\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 0 &amp; \\cdots \\\\  \\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; 0 &amp; \\cdots \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; 1 &amp; \\cdots \\\\  \\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; 1 &amp; \\cdots \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; \\cdots &amp; \\cdots \\\\  \\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; \\cdots &amp; \\cdots \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; a &amp; l  \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; a &amp; l \\\\  \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 1 &amp; a &amp; l \\\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } 0 &amp; a+1 &amp; \\cdots\\\\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\end{array} \\] <p>The PIL code for this Plookup looks like this: $$ \\mathtt{ hashKLen {\\ addr,\\ op0}\\ }\\quad \\texttt{in} \\quad  \\mathtt{ PaddingKK.lastHashLatch {\\ PaddingKK.addr ,\\ PaddingKK.len\\ }\\ }\\quad $$ where \\(\\texttt{hashKLen}\\) flags whenever the operation is checked and the length is stored in \\(\\mathtt{op0}\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#read-check","title":"Read Check","text":"<p>Checking reads requires more columns to be introduced.</p> <p>Recall that, given given three parameters; the address \\(a\\) of a string, the position \\(p\\) of the starting byte of the string, and  \\(l\\)  the total number of bytes that we want to read; the intention is to read the bytes of the string from the first to thirty second.</p> <p>It takes 8 registers, each of 32 bits, to store the output of the read operation. Let us denote these registers by  $$ {\\ \\mathtt{crV_i}\\ |\\ \\mathtt{i} \\in { 0, 1, 2, \\dots , 7 } } $$ Further 8 factor polynomials \\(\\{ \\mathtt{crF_j} |\\ \\mathtt{j} \\in \\{ 0, 1, 2, \\dots , 7 \\} \\}\\) are needed so as to correctly place the input bytes with respect to their right power of 2. </p> <p>Before looking into the roles of the \\(\\{\\mathtt{crV_i}\\}\\) registers and \\(\\{\\mathtt{crF_i}\\}\\) factor polynomials, three more columns are necessary for describing the verification of the read operations. These registers are; \\(\\texttt{crLen}\\), \\(\\texttt{crOffset}\\) and \\(\\texttt{crLatch}\\); and are defined as follows.</p> <ul> <li> <p>\\(\\mathtt{crLen}\\): A register that specifies the number bytes to be read. It is a number register, containing numbers between 1 and 32, and it remains constant in each of the readings we want to perform.</p> </li> <li> <p>\\(\\mathtt{crOffset}\\): A decreasing sequence of values, starting from the length value of the read minus 1 (i.e., \\(\\mathtt{crLen - 1}\\) ) and ends at 0, for each read. This is important for positioning each byte at the correct power of 2.</p> </li> <li> <p>\\(\\mathtt{crLatch}\\): This is a computed column, using the same inverse technique as before. It records instances when the \\(\\mathtt{crOffset}\\) register is 0. First, the register \\(\\mathtt{crOffsetInv}\\) is committed, allowing  \\(\\mathtt{crLatch}\\) to be expressed as   $$   \\mathtt{crLatch = 1 \u2212 crOffset \\cdot crOffsetInv} \\tag{Eqn.14}   $$    which satisfies the constraint, \\(\\mathtt{crOffsetInv \\cdot crLatch = 0}\\). </p> </li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#example-2-read-check-using-columns","title":"Example 2. Read Check Using Columns","text":"<p>Suppose we want to read the first 10 bytes of the address 6, and once finished, read the next two bytes of the same address thereafter. Here is the correct way of constructing the polynomials; \\(\\texttt{crLen}\\), \\(\\texttt{crOffset}\\) and \\(\\texttt{crLatch}\\). Consider the string, \\(\\mathtt{s = 0x...7355ff00111a6e6e1f02ef10}\\).</p>  Table 6 : Polynomials for a Read Check  \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{aFreeIn} &amp; \\texttt{ addr } &amp; \\texttt{ crLen } &amp; \\texttt{crOffset} &amp; \\texttt{crLatch}\\\\ \\hline \\text{ }\\text{ }\\text{ }\\mathtt{0x10} &amp; 6 &amp; 10 &amp; 9 &amp; 0 \\\\  \\text{ }\\text{ }\\text{ }\\mathtt{0xef} &amp; 6 &amp; 10 &amp; 8 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x02} &amp; 6 &amp; 10 &amp; 7 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x1f} &amp; 6 &amp; 10 &amp; 6 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x6e} &amp; 6 &amp; 10 &amp; 5 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x6e} &amp; 6 &amp; 10 &amp; 4 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x1a} &amp; 6 &amp; 10 &amp; 3 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x11} &amp; 6 &amp; 10 &amp; 2 &amp; 0\\\\ \\hline \\text{ }\\text{ }\\text{ }\\mathtt{0x00} &amp; 6 &amp; 10 &amp; 1 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0xff} &amp; 6 &amp; 10 &amp; 0 &amp; 1\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x55} &amp; 6 &amp; 2 &amp; 1 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x73} &amp; 6 &amp; 2 &amp; 0 &amp; 1\\\\ \\text{ }\\text{ }\\text{ }\\text{ } \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\end{array} \\] <p>Note that the horinzontal line is used to separate every 8 bytes, which are the exact number of bytes stored in a \\(\\mathtt{crV_i}\\) register. We will later on see why this is important.</p> <p>Several Observations</p> <p>Firstly, note that \\(\\mathtt{crLatch}\\) is 1 if and only if \\(\\mathtt{crOffset}\\) is 0. </p> <p>Secondly, if we want to express the two read values as an array, the output will be $$ \\mathtt{[0xff00111a6e6e1f02ef10, 0x7355]} $$ where the first element of the array has 10 bytes, whilst the second has 2 bytes. This coincides with each of the \\(\\mathtt{crLen}\\) defined values.</p> <p>Thirdly, observe the relationships that these registers; \\(\\texttt{crLen}\\), \\(\\texttt{crOffset}\\) and \\(\\texttt{crLatch}\\) ; have to satisfy.</p> <p>\\(\\bf{(a)}\\)  The \\(\\texttt{crOffset}\\) register decreases in every read, so we can express this as $$ \\mathtt{crOffset\u2032 \\cdot (1 \u2212 crLatch) = (crOffset \u2212 1) \\cdot (1 \u2212 crLatch)} \\tag{Eqn.15} $$ \\(\\bf{(b)}\\)  The \\(\\texttt{crLen}\\) register remains constant during each read operation, hence the following constraint applies, $$ \\mathtt{crLen\u2032 \\cdot (1 \u2212 crLatch) = crLen \\cdot (1 \u2212 crLatch)} \\tag{Eqn.16} $$ \\(\\bf{(c)}\\)  The first \\(\\texttt{crOffset}\\) of every read is \\(\\texttt{crLen \u2212 1}\\). Hence, we need to specify the following relationship $$ \\mathtt{crLatch \\cdot crOffset' = crLatch \\cdot (crLen\u2032 \u2212 1)} \\tag{Eqn.17} $$ \\(\\bf{(d)}\\)  In addition, we need to ensure that the address resets immediately after a string ends. Otherwise, we will read from a different string. For this reason, we need to introduce the following constraint $$ \\mathtt{(1 \u2212 crLatch) \\cdot lastHash} \\tag{Eqn.18} $$ which, when combined with the previous constraints enforces the desired results.</p> <p>The registers \\(\\{\\mathtt{crV_i}\\}\\) and polynomial factors \\(\\{\\mathtt{crF_i}\\}\\)</p> <p>Let us now turn to the registers \\(\\mathtt{crV_i}\\) and polynomial factors \\(\\mathtt{crF_i}\\).</p> <p>Consider the previous example, where the first element of the 'output' array is  $$ \\mathtt{0xff00111a6e6e1f02ef10} $$  Obviously, this element does not fit in a 32-bit register. So it needs to be split over three registers; \\(\\mathtt{crV_0}\\), \\(\\mathtt{crV_1}\\) and \\(\\mathtt{crV_2}\\); respectively as,  $$ \\mathtt{0x1f02ef10, 0x111a6e6e} \\text{ and } \\mathtt{0xff00} $$ Moreover, each byte has a corresponding weight \\((2^8)^j\\), for some \\(j \\in \\{0, 1, 2, 3\\}\\), such that, $$ \\mathtt{0x1f02ef10=0x10 \\cdot 2^0 +0xef\\cdot 2^8 +0x02\\cdot 2^{16} + 0x1f\\cdot2^{24}}\\ \\mathtt{0x111a6e6e=0x6e\\cdot2^0 +0x6e\\cdot2^8 +0x1a\\cdot2^{16} +0x11\\cdot2^{24}}\\ \\mathtt{0xff00=0x00\\cdot2^0 +0xff\\cdot2^8}\\quad\\quad\\quad\\qquad\\quad\\quad\\quad \\text{ }\\text{} $$ Henceforth, we should reflect this in our state machine using the columns \\(\\mathtt{crF_i}\\) and \\(\\mathtt{crV_i}\\) for our previous example.</p>  Table 7 : Polynomial factors and Bytes Positioning  \\[ \\begin{array}{|l|c|c|c|c|c|c|} \\hline \\texttt{aFreeIn} &amp; \\texttt{crLatch} &amp; \\mathtt{crV_0} &amp; \\mathtt{crV_1} &amp; \\mathtt{crV_2} &amp; \\mathtt{ crF_0 } &amp; \\mathtt{ crF_1 } &amp; \\mathtt{ crF_2 }\\\\ \\hline \\text{ }\\text{ }\\text{ }\\mathtt{0x10} &amp; 0 &amp; \\mathtt{0x10} &amp; \\mathtt{0x00} &amp; \\mathtt{0x00} &amp; 1 &amp; 0 &amp; 0 \\\\  \\text{ }\\text{ }\\text{ }\\mathtt{0xef} &amp; 0 &amp; \\mathtt{0xef10} &amp; \\mathtt{0x00} &amp; \\mathtt{0x00} &amp; 2^8 &amp; 0 &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x02} &amp; 0 &amp; \\mathtt{0x02ef10} &amp; \\mathtt{0x00} &amp; \\mathtt{0x00} &amp; 2^{16} &amp; 0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x1f} &amp; 0 &amp; \\mathtt{0x1f02ef10} &amp; \\mathtt{0x00} &amp; \\mathtt{0x00} &amp; 2^{24} &amp; 0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x6e} &amp; 0 &amp; \\mathtt{0x1f02ef10} &amp; \\mathtt{0x6e} &amp; \\mathtt{0x00} &amp; 0 &amp; 1 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x6e} &amp; 0 &amp; \\mathtt{0x1f02ef10} &amp; \\mathtt{0x6e6e} &amp; \\mathtt{0x00} &amp; 0 &amp; 2^8 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x1a} &amp; 0 &amp; \\mathtt{0x1f02ef10} &amp; \\mathtt{0x1a6e6e} &amp; \\mathtt{0x00} &amp; 0 &amp; 2^{16} &amp; 0\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x11} &amp; 0 &amp; \\mathtt{0x1f02ef10} &amp; \\mathtt{0x111a6e6e} &amp; \\mathtt{0x00} &amp; 0 &amp; 2^{24} &amp; 0\\\\ \\hline \\text{ }\\text{ }\\text{ }\\mathtt{0x00} &amp; 0 &amp; \\mathtt{0x1f02ef10} &amp; \\mathtt{0x111a6e6e} &amp; \\mathtt{0x00} &amp; 0 &amp; 0 &amp; 1\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0xff} &amp; 1 &amp; \\mathtt{0x1f02ef10} &amp; \\mathtt{0x111a6e6e} &amp; \\mathtt{0xff00} &amp; 0 &amp; 0 &amp; 2^8\\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x55} &amp; 0 &amp; \\mathtt{0x55} &amp; \\mathtt{0x00} &amp; \\mathtt{0x00} &amp; 1 &amp; 0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\mathtt{0x73} &amp; 1 &amp; \\mathtt{0x7355} &amp; \\mathtt{0x00} &amp; \\mathtt{0x00} &amp; 2^8 &amp; 0 &amp; 0 \\\\ \\text{ }\\text{ }\\text{ }\\text{ } \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\end{array} \\] <p>Observe that registers \\(\\{\\mathtt{crV_i}\\}\\) are actually cumulative up to the register's maximal capacity of 4 bytes is reached, in which case the next reads are stored in the next \\(\\mathtt{crV_{i+1}}\\) register.</p> <p>The registers \\(\\{\\mathtt{crF_i}\\}\\) are responsible for correct positioning of each byte with respect to powers \\((2^8)^j\\), for \\(j \\in \\{0, 1, 2, 3\\}\\), providing the decomposition stated above.</p> <p>Lastly, observe that the rows corresponding to \\(\\mathtt{crLatch = 1}\\), store the complete result of the read in the registers \\(\\{\\mathtt{crV_i}\\}\\). These are the rows where validity of the read operation is checked via a Plookup.</p> <p>Constraints Pertaining to \\(\\{\\mathtt{crV_i}\\}\\) and \\(\\{\\mathtt{crF_i}\\}\\) </p> <p>The idea here is to compute a column  \\(\\mathtt{crVC_i}\\) defined by, $$ \\mathtt{crVC_i = crV_i + crF_i \\cdot aFreeIn} \\tag{Eqn.19} $$ and then verify that the next state \\(\\mathtt{crV'_i}\\) coincides with \\(\\mathtt{crVC_i}\\) whenever \\(\\mathtt{crLatch}\\) is not equal to 1. This will confirm that the \\(\\{\\mathtt{crV_i}\\}\\) registers are not only sequentially read, but are also correctly computed from the previous states. Hence, the following constraint needs to be added; $$ \\mathtt{crV' = crVC \\cdot (1 \u2212 crLatch)}  \\tag{Eqn.20} $$ So far so good. </p> <p>Now observe that the tuple \\((\\mathtt{crOffset, crF0, crF1, . . . , crF7})\\) is not totally arbitrary. In fact, it needs to be checked whether \\(\\mathtt{crOffset \\in \\{1,\\dots,32\\}}\\) and \\(\\mathtt{crFi \\in \\{1,2^8,2^{16},2^{24}\\}}\\). This is done via a Plookup. That is, checking if the row corresponding to \\(\\mathtt{crLatch = 1}\\) is contained among the previously computed table of constants having all possible combinations of the previous columns.</p>  PIL Code : Checking correct values of registers  \\[ \\begin{aligned} \\{ \\quad \\text{ }\\text{ }\\text{ }  &amp;  \\text{ }\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad \\\\  &amp; \\mathtt{crOffset,}\\\\ &amp; \\mathtt{crF0,}\\\\ &amp; \\mathtt{crF1,}\\\\ &amp; \\mathtt{crF2,}\\\\ &amp; \\mathtt{crF3,}\\\\ &amp; \\mathtt{crF4,}\\\\ &amp; \\mathtt{crF5,}\\\\  &amp; \\mathtt{crF6,}\\\\  &amp; \\mathtt{crF7}\\\\ \\quad \\}\\text{ }\\text{ } \\mathtt{in}\\\\ \\{ \\quad \\text{ }\\text{ }\\text{} \\\\ &amp; \\mathtt{k\\_crOffset,}\\\\  &amp; \\mathtt{k\\_crF0,}\\\\  &amp; \\mathtt{k\\_crF1,}\\\\ &amp; \\mathtt{k\\_crF2,}\\\\ &amp; \\mathtt{k\\_crF3,}\\\\ &amp; \\mathtt{k\\_crF4,}\\\\ &amp; \\mathtt{k\\_crF5,}\\\\ &amp; \\mathtt{k\\_crF6,}\\\\ &amp; \\mathtt{k\\_crF7}\\\\ \\};\\quad \\text{ }\\text{ }\\text{} \\\\ \\hline \\end{aligned} \\]"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#the-read-operation-and-the-main-state-machine","title":"The Read Operation And The Main State Machine","text":"<p>There are a few subtle details concerning the connection between the Read operation and the Main SM to be taken into account. </p> <p>For instance, in order to avoid problems, reading from the last (probably smaller) block is not allowed. A constant column \\(\\mathtt{crValid}\\) is therefore created specifically for checking if a read is done at the last block. So, \\(\\mathtt{crValid}\\) will be 1 if and only if the current state is not at the last block. Hence, the Plookup in the Main SM's PIL code (main.pil code; lines 452 to 465):</p>  PIL Code : Validity Check for the Read operation  \\[ \\begin{aligned} \\mathtt{hashK}\\text{ } \\{ &amp; \\text{} \\\\ &amp;\\texttt{addr,}\\\\ &amp;\\texttt{HASHPOS,}\\\\ &amp;\\texttt{DO,} \\\\ &amp;\\texttt{op0, op1, op2, op3,}\\\\ &amp;\\texttt{op4, op5, op6, op7}\\\\ \\}\\text{ } \\mathtt{in}\\quad\\text{ } \\\\ &amp;\\mathtt{PaddingKK.crLatch * PaddingKK.crValid}\\text{ } \\{  \\\\ &amp;\\mathtt{PaddingKK.addr,} \\\\ &amp;\\mathtt{PaddingKK.len - PaddingKK.rem - PaddingKK.crLen + 1,}\\\\ &amp;\\mathtt{PaddingKK.crLen,}\\\\ &amp;\\mathtt{PaddingKK.crVC0,\\ PaddingKK.crVC1,\\ PaddingKK.crVC2,\\ PaddingKK.crVC3,}\\\\ &amp;\\mathtt{PaddingKK.crVC4,\\ PaddingKK.crVC5,\\ PaddingKK.crVC6,\\ PaddingKK.crVC7}\\\\ \\};\\qquad\\text{ }\\text{ }\\\\ \\hline  \\end{aligned} \\] <p>Note that \\(\\texttt{HASHPOS}\\) is marking the position in the string of the byte where the reading starts. The Plookup shown above, maps the  committed polynomial \\(\\texttt{HASHPOS}\\) in the Main SM to the linear combination of the commited polynomials; \\(\\mathtt{len}\\), \\(\\mathtt{rem}\\) and \\(\\mathtt{crLen}\\); of the Padding-KK SM as, $$ \\mathtt{len\u2212rem\u2212crLen+1} \\tag{Eqn.20} $$ Let us make use of the following example to clearly see why this linear combination works. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/03-Padding-KK-SM/#example-3-main-sm-and-padding-kk-connection","title":"Example 3. Main SM and Padding-KK Connection","text":"<p>Suppose we want to read bytes 2, 3 and 4 of the string \\(\\mathtt{0x7766554433221100}\\). The table of the reading, reflecting only the relevant columns, is as follows.</p>  Table 8 : Main SM and Padding-KK Example  \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{} &amp;\\texttt{aFreeIn} &amp; \\texttt{len} &amp;\\texttt{rem} &amp;\\texttt{crLen} &amp;\\texttt{len - rem - crLen + 1} &amp; \\mathtt{crV_1} \\\\ \\hline \\texttt{line 0} &amp;\\mathtt{0x00} &amp; 8 &amp; 8 &amp; 0 &amp; 1 &amp; \\mathtt{0x00} \\\\ \\hline \\texttt{line 1} &amp;\\mathtt{0x11} &amp; 8 &amp; 7 &amp; 0 &amp; 2 &amp; \\mathtt{0x00} \\\\ \\hline \\texttt{line 2} &amp;\\mathtt{0x22} &amp; 8 &amp; 6 &amp; 3 &amp; 0 &amp; \\mathtt{0x22} \\\\ \\hline \\texttt{line 3} &amp;\\mathtt{0x33} &amp; 8 &amp; 5 &amp; 3 &amp; 1 &amp; \\mathtt{0x3322} \\\\ \\hline \\texttt{line 4} &amp;\\mathtt{0x44} &amp; 8 &amp; 4 &amp; 3 &amp; 2 &amp; \\mathtt{0x443322} \\\\ \\hline \\texttt{line 5} &amp;\\mathtt{0x55} &amp; 8 &amp; 3 &amp; 0 &amp; 6 &amp; \\mathtt{0x00} \\\\ \\hline \\texttt{line 6} &amp;\\mathtt{0x66} &amp; 8 &amp; 2 &amp; 0 &amp; 7 &amp; \\mathtt{0x00} \\\\ \\hline \\texttt{line 7} &amp;\\mathtt{0x77} &amp; 8 &amp; 1 &amp; 0 &amp; 8 &amp; \\mathtt{0x00} \\\\ \\hline \\end{array} \\] <p>Observe that, among the rows with \\(\\mathtt{crLen = 3}\\) (the ones where the reading happens), only the row in \\(\\texttt{line 6}\\) contains the complete read-result, \\(\\mathtt{0x443322}\\), in the \\(\\mathtt{crV_i}\\) column. That is, although \\(\\texttt{HASHPOS = 2}\\), meaning the reading starts with byte 2 which is in \\(\\texttt{line 2}\\), the reading is only complete in \\(\\texttt{line 6}\\). And that's the exact row where the linear combination works out to be $$ \\mathtt{\\big(len\u2212rem\u2212crLen+1\\big) = 2 = HASHPOS} $$</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/","title":"Padding-KK-Bit State Machine","text":"<p>The 136-byte output of the Padding-KK SM is the input to the KECCAK-f SM, but it must first be converted to bits. This is where the Padding-KK-Bit state machine comes in. One of the roles of the Padding-KK-Bit SM is therefore that of a two-way converter of bytes to bits. And thus stands as a facilitator between the Padding-KK SM which operates byte-wise, and the KECCAK-f SM which operates bit-wise.</p> <p>Other than being a two-way bytes-to-bits converter, the Padding-KK-Bit SM is responsible for validating every operation related to inputs and outputs of the KECCAK-f permutation blocks.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#design-strategies","title":"Design strategies","text":"<p>Here's how this state machine facilitates operations between the Padding-KK SM and the KECCAK-f SM.</p> <p>A block of 136 rows of bytes in the Padding-KK SM corresponds to \\(\\mathtt{1993}\\) rows in the Padding-KK-Bit SM. The picture below, displays the correspondence, also shows three subdivisions of the \\(\\mathtt{1993}\\) rows (corresponding to \\(\\mathtt{1224+512+256+1}\\)).</p> <p></p> Figure 1: Padding-KK block vs. Padding-KK-Bit's 3 subdivisions  <p>The first subdivision consists of \\(\\mathtt{9*136 = 1224}\\) rows, where each of the \\(\\mathtt{136}\\) byte-rows has been expanded into \\(\\mathtt{9}\\) rows (i.e., \\(\\mathtt{8}\\) rows for the \\(\\mathtt{8}\\) bits plus \\(\\mathtt{1}\\) row for the byte that represents the \\(\\mathtt{8}\\) bits). The decomposition of the bytes into the 8 bits (with an extra row, just for the byte), is done for easy implementation in PIL. How this is actually done is explained a little later. Observe that this subdivision of \\(\\mathtt{1224}\\) rows represents the bitrate of the KECCAK-f permutation. Therefore, a strategy to ensure that the bits are accurately and correctly provided, as input to the KECCAK-f SM, needs to be derived.</p> <p>The second subdivision consists of the \\(\\mathtt{512}\\) rows, and represents the capacity input-bits in the \\(\\mathtt{1600}\\)-bit state of the KECCAK-f SM. Observe that, within the KECCAK-f state machine, unlike the bits in the first subdivision of \\(\\mathtt{1224}\\) rows, the capacity bits are not affected by any exterior bits.</p> <p>The third subdivision of \\(\\mathtt{256 + 1}\\) rows represents the 256 bits of the intermediate hash value produced by the KECCAK-f permutation. At the end of hashing each 1088 bits (136-byte) string, this intermediate hash value actually coincides with the final hash of the KECCAK-256 hash function. Each hash value, the final digest, is packed into eight 32-bit registers at the final row of this subdivision.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#bytes-to-bits-correspondence","title":"Bytes To Bits Correspondence","text":"<p>Next is further elaboration on how the Padding-KK-Bit SM handles the correspondence of bytes between state machines, and correct positioning of bits with respect to powers of 2.</p> <p>Starting with the first subdivision, the \\(\\mathtt{1224}\\) rows related with the bit decomposition of each byte, the following registers are utilised: </p> <p>(a) The Padding-KK-Bit state machine has a column named \\(\\texttt{rBit}\\), which records all the bits associated with the decomposition of each of the bytes of the previous state machine, the Padding-KK SM.</p> <p>(b) In order to relate the byte to its bit decompsition between the two states machines, a register called \\(\\texttt{r8Id}\\) is added in both state machines as a bit-to-parent-byte identifier.</p> <p>(c) Also, another register called \\(\\texttt{r8}\\), is added for the sole purpose of sequentially constructing each byte from the bits.</p> <p>(d) Similar to what was done in the Padding-KK SM, a factor register \\(\\texttt{Fr8}\\), is used to correctly place each bit in the parent, with respect to powers of 2.</p> <p>(e) Therefore, each complete byte is recorded at the last row of such a 9-row byte block of the \\(\\texttt{r8}\\) register. This row is flagged with a \"1\" in the same row of another register, called \\(\\texttt{latchR8}\\). So that \\(\\texttt{latchR8}\\) is 0 in all rows except the last row of a 9-row byte block.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#example-1-represention-of-two-bytes","title":"Example 1. (Represention of Two Bytes)","text":"<p>Here's an example of how two bytes, \\(\\mathtt{0xa1}\\) and \\(\\mathtt{0xfe}\\), from the Padding-KK SM look like in the Padding-KK-Bit SM. The horizontal lines mark the end of a byte block. </p>  Table 1: Two Bytes Example from Padding-KK SM to Padding-KK-Bit SM   <p>$$ \\begin{array}{|l|c|} \\hline \\texttt{aFreeIn} &amp; \\texttt{r8Id}\\ \\hline \\mathtt{0xa1} &amp; 1\\ \\hline \\mathtt{0xfe} &amp; 2\\ \\hline \\end{array} \\implies  \\begin{array}{|l|c|c|c|c|c|c|c|c|} \\hline \\texttt{rBit} &amp; \\texttt{r8Id} &amp;\\texttt{r8} &amp; \\texttt{Fr8} &amp; \\texttt{latchR8}\\ \\hline 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\\  0 &amp; 1 &amp; \\mathtt{0b1} &amp; 2 &amp; 0\\  0 &amp; 1 &amp; \\mathtt{0b01} &amp; 2^2 &amp; 0\\  0 &amp; 1 &amp; \\mathtt{0b001} &amp; 2^3 &amp; 0\\  0 &amp; 1 &amp; \\mathtt{0b0001} &amp; 2^4 &amp; 0\\  1 &amp; 1 &amp; \\mathtt{0b00001} &amp; 2^5 &amp; 0\\  0 &amp; 1 &amp; \\mathtt{0b100001} &amp; 2^6 &amp; 0\\  1 &amp; 1 &amp; \\mathtt{0b0100001} &amp; 2^7 &amp; 0\\  \\texttt{X} &amp; 1 &amp; \\mathtt{0b10100001} &amp; 0 &amp; 1\\ \\hline 0 &amp; 2 &amp; 0 &amp; 1 &amp; 0\\  1 &amp; 2 &amp; \\mathtt{0b0} &amp; 2 &amp; 0\\  1 &amp; 2 &amp; \\mathtt{0b10} &amp; 2^2 &amp; 0\\  1 &amp; 2 &amp; \\mathtt{0b110} &amp; 2^3 &amp; 0\\  1 &amp; 2 &amp; \\mathtt{0b1110} &amp; 2^4 &amp; 0\\  1 &amp; 2 &amp; \\mathtt{0b11110} &amp; 2^5 &amp; 0\\  1 &amp; 2 &amp; \\mathtt{0b111110} &amp; 2^6 &amp; 0\\  1 &amp; 2 &amp; \\mathtt{0b1111110} &amp; 2^7 &amp; 0\\  \\texttt{X} &amp; 1 &amp; \\mathtt{0b11111110} &amp; 0 &amp; 1\\ \\hline</p> <p>\\end{array} $$</p> <p>Observe that \\(\\texttt{latchR8}\\) is equal to 1 in the last row of each byte block, and this the same row where the corresponding complete byte is found in the \\(\\texttt{r8}\\) column.</p> <p>Similarly to what was done in the Padding-KK state machine, the following constraint applies to the \\(\\texttt{r8}\\) column, $$ \\mathtt{r8'} \\mathtt{ = r8\\cdot(1\u2212latchR8)+rBit\u00b7Fr8} $$ Observe that it is very important for \\(\\mathtt{Fr8}\\) to be \"\\(0\\)\" when \\(\\mathtt{latchR8}\\) is \"\\(1\\)\". If this is not the case, then there is no guarantee that the \\(\\mathtt{r8}\\) register will reset to \\(0\\) in the next block.</p> <p>It is also necessary to ensure that \\(\\mathtt{rBit}\\) is binary, by using the next the constraint, $$ \\mathtt{rBit \\cdot (1\u2212rBit) = 0} $$</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#validating-transitions-of-bits","title":"Validating Transitions Of Bits","text":"<p>The focus has thus far been on solving the problem of decomposing bytes into bits. The idea here is to validate the transitions of the bits after the KECCAK-f operation, which is done for every block of 136 bytes. A few columns are introduced for this purpose.</p> <p>(a) \\(\\mathtt{sInBit}\\): This register stores the input bit of the current KECCAK-f permutation block.</p> <p>(b) \\(\\mathtt{sOutBit}\\): This register stores the output bit of the current KECCAK-f permutation block.</p> <p>(c) \\(\\mathtt{connected}\\): The same idea as in the Padding-KK state machine applies here. The \\(\\mathtt{connected}\\) register is constant within a block, and reflects that the output of the previous permutation KECCAK-f is connected to the current one. That is, it indicates that the previous 136-byte block belongs to the same string as the current block.</p> <p>(d) \\(\\mathtt{latchSOut}\\): This register records \"\\(1\\)\" in the very last row of each of the \\(\\mathtt{1993}\\)-row block corresponding to a 136-byte block of the Padding-KK SM, and \\(0\\) everywhere else.</p> <p>Figure 2 below depicts a schema of how to relate the above columns with the KECCAK-f sponge construction.</p> <p></p>  Figure 2: A schema relating Padding-KK-Bit to Keccak-f Sponge Construction"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#constraints-for-bit-transitions","title":"Constraints For Bit Transitions","text":"<p>Next are the constraints needed to ensure correct transition between rows.</p> <p>Of course, there is a need to make sure the \\(\\mathtt{connected}\\) register is constant in each block. Hence, the following constraint should be added, $$ \\mathtt{connected\u2032 \\cdot (1 \u2212 latchSOut) = connected \u00b7 (1 \u2212 latchSOut)}  $$</p> <p>Moreover, there is a need to test whether \\(\\mathtt{connected}\\) and \\(\\mathtt{sOutBit}\\) are binary. For these two checks, the following equations are used, $$ \\mathtt{connected \\cdot (1 \u2212 connected) = 0},\\  \\mathtt{sOutBit \\cdot (1 \u2212 sOutBit) = 0}\\qquad\\text{ }  $$</p> <p>The register \\(\\mathtt{sInBit}\\) is actually computed from \\(\\mathtt{sOutBit}\\), \\(\\mathtt{connected}\\) and \\(\\mathtt{rBit}\\) columns. Recall that, at the first block of the sponge function, the input bits to the KECCAK-f permutation actually coincide with \\(\\mathtt{rBit}\\). However, after the first block, an \\(\\text{XOR}\\) of \\(\\mathtt{sOutBit}\\) and \\(\\mathtt{rBit}\\) must be performed, as seen in Figure 2 above.</p> <p>Henceforth, \\(\\mathtt{sInBit}\\) is computed, using an auxiliary register \\(\\mathtt{aux\\_sInBit}\\) as follows, $$ \\mathtt{aux_sInBit = sOutBit \u2212 2 \\cdot sOutBit \\cdot rBit,}\\text{ }\\text{ } \\  \\mathtt{sInBit = connected \\cdot aux_sInBit + rBit }\\qquad  $$</p> <p>A quick analysis of \\(\\mathbf{Eqn. 6}\\) shows the following,</p> <p>(a) If \\(\\mathtt{connected}\\) is \\(0\\), then \\(\\mathtt{sInBit}\\) equals \\(\\texttt{rBit}\\), which is precisely what needs to happen in the first KECCAK-f permutation block.</p> <p>(b) But if \\(\\mathtt{connected}\\) is \\(1\\), then \\(\\mathtt{sInBit}\\) equals \\(\\mathtt{sOutBit \u2212 2 \\cdot sOutBit \\cdot rBit + rBit}\\), which is actually the \\(\\text{XOR}\\) of \\(\\mathtt{sOutBit}\\) and \\(\\mathtt{rBit}\\).</p> <p>Table 2 shows all the cases of the above computation.</p>  Table 2: Illustration of Equation 5  \\[ \\begin{array}{|l|c|c|c|c|c|c|c|c|} \\hline \\texttt{connected} &amp; \\texttt{sOutBit} &amp;\\texttt{rBit} &amp; \\texttt{sInBit} \\\\ \\hline \\text{}\\text{}\\qquad 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\text{}\\text{}\\qquad 0 &amp; 0 &amp; 1 &amp; 1\\\\ \\text{}\\text{}\\qquad 0 &amp; 1 &amp; 0 &amp; 0\\\\ \\text{}\\text{}\\qquad 0 &amp; 1 &amp; 1 &amp; 1\\\\ \\text{}\\text{}\\qquad 1 &amp; 0 &amp; 0 &amp; 0\\\\ \\text{}\\text{}\\qquad 1 &amp; 0 &amp; 1 &amp; 1\\\\ \\text{}\\text{}\\qquad 1 &amp; 1 &amp; 0 &amp; 1\\\\ \\text{}\\text{}\\qquad 1 &amp; 1 &amp; 1 &amp; 0\\\\ \\hline \\end{array} \\]"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#capacity-connection-in-the-512-rows","title":"Capacity Connection In The \\(512\\)-Rows","text":"<p>The second subdivision of the Padding-KK-Bit SM's \\(\\mathtt{1993}\\)-row block consists of the \\(\\mathtt{512}\\) rows, corresponding to KECCAK-f SM's capacity bits. There is a need make certain these capacity bits (the middle subdivision of each \\(\\mathtt{1993}\\)-row block) are not affected by any exterior bit.</p> <p>First, a new register called \\(\\mathtt{rBitValid}\\) is added, and it is defined such that it records \\(1\\) in each of the rows corresponding to the capacity bits, and \\(0\\) everywhere else. Hence, the following relationship is added. $$ \\mathtt{(1 \u2212 rBitValid) \\cdot rBit = 0}  $$</p> <p>This ensures that, in each \\(1993\\)-row block, \\(\\mathtt{rBit}\\) is \\(0\\) everywhere in the rows corresponding to the capacity bits. This results in \\(\\text{XOR}\\)ing \\(\\mathtt{sOutBit}\\) with a \\(0\\). And thus, for the rows corresponding to the capacity bits, computing \\(\\mathtt{sInBit = sOutBit \\bigoplus rBit}\\) as seen in Figure 2, amounts to \\(\\mathtt{sInBit = sOutBit}\\). Therefore, \\(\\mathbf{Eqn. 8}\\) guarantees that the capacity bits are not modified by any exterior bits.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#the-output-calculations-in-the-256-1-rows","title":"The Output Calculations In The \\((256 + 1)\\)-Rows","text":"<p>Now, the last part of the Padding-KK-Bit SM is to keep track of the last subdivision of each \\(1993\\)-row block. Recall that this third subdivision consists of \\(256 + 1\\) rows, and it is in charge of storing each bit of the intermediate hashes of the KECCAK-f permutation blocks. The \\(256\\) bits of the KECCAK-f permutation output are sequentially and cumulatively stored in eight 32-bit registers \\(\\{\\mathtt{sOut_i}|\\ 0 \\leq i \\leq 7 \\}\\). In a similar method used for the read operations in the Padding-KK SM, eight (8) factor columns \\(\\{\\mathtt{FSOut_i} |\\ 0 \\leq i \\leq 7\\}\\) are used to ensure correct positioning (of each of the \\(32\\) bits in \\(\\mathtt{sOut_i}\\)) with respect to powers of \\(2\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#example-2-storing-256-bit-intermediate-hash-outputs","title":"Example 2. (Storing 256-bit intermediate hash outputs)","text":"<p>Consider the 256 bits, \\(\\mathtt{0b|10110011\\dots1010|\\dots|11\\dots11|01\\dots10101101|}\\), where \"\\(|\\)\" separates every set of 32 bits. Table 3 below, displays how the \\(256 + 1\\) rows of a \\(1993\\)-block are stored in the registers \\(\\{\\mathtt{sOut_i}|\\ 0 \\leq i \\leq 7 \\}\\).</p>  Table 3: The (256+1)-row 3rd subdivision of a 1993-row block  <p>$$ \\small \\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\texttt{sOutBit} &amp; \\mathtt{sOut_0} &amp; \\mathtt{sOut_1} &amp; \\mathtt{\\dots} &amp; \\mathtt{sOut_7} &amp; \\mathtt{FSOut_0} &amp; \\mathtt{FSOut_1} &amp; \\mathtt{\\dots}  &amp; \\mathtt{FSOut_7} &amp; \\mathtt{latchSOut}\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ } \\dots &amp; \\dots  &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots\\ \\hline \\quad\\text{ }\\text{ } 1 &amp; \\mathtt{0b1} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 1 &amp; 0&amp; \\dots &amp; 0 &amp; 0\\  \\quad\\text{ }\\text{ }0 &amp; \\mathtt{0b01} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2 &amp; 0&amp; \\dots &amp; 0 &amp; 0 \\  \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^2 &amp; 0&amp;  \\dots &amp; 0 &amp; 0\\  \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b1101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^3 &amp; 0&amp; \\dots &amp; 0 &amp; 0\\  \\quad\\text{ }\\text{ }0 &amp; \\mathtt{0b01101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^6 &amp; 0&amp; \\dots &amp; 0 &amp; 0\\  \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b101101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^6 &amp; 0&amp; \\dots &amp; 0 &amp; 0\\  \\quad\\text{ }\\text{ }0 &amp; \\mathtt{0b0101101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^6 &amp; 0&amp; \\dots &amp; 0 &amp; 0\\  \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b10101101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^7 &amp; 0&amp; \\dots &amp; 0 &amp; 0\\</p> <p>\\text{ }\\text{ }\\text{ }\\text{ } \\dots &amp; \\dots &amp; \\dots &amp;  \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots\\</p> <p>\\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b1\\dots10101101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^{30} &amp; 0 &amp; \\dots &amp; 0 &amp; 0\\  \\quad\\text{ }\\text{ }0 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b0} &amp; \\dots &amp; \\mathtt{0b0} &amp; 2^{31} &amp; 0 &amp; \\dots &amp; 0 &amp; 0\\ \\hline \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b1} &amp; \\dots &amp; \\mathtt{0b0} &amp; 0 &amp; 1 &amp; \\dots &amp; 0 &amp; 0 \\ \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11} &amp; \\dots &amp; \\mathtt{0b0} &amp; 0 &amp; 2 &amp; \\dots &amp; 0 &amp; 0 \\ \\text{ }\\text{ }\\text{ }\\text{ } \\dots &amp; \\dots &amp; \\dots &amp; \\dots&amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots \\ \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b1\\dots 11} &amp; \\dots &amp; \\mathtt{0b0} &amp; 0 &amp; 2^{30} &amp; \\dots &amp; 0 &amp; 0\\ \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11\\dots 11} &amp; \\dots &amp; \\mathtt{0b0} &amp; 0 &amp; 2^{31} &amp; \\dots &amp; 0 &amp; 0\\ \\hline \\text{ }\\text{ }\\text{ }\\text{ } \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots\\ \\text{ }\\text{ }\\text{ }\\text{ } \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots\\ \\hline \\quad\\text{ }\\text{ }0 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11\\dots 11} &amp; \\dots &amp; \\mathtt{0b0} &amp; 0 &amp; 0 &amp; \\dots &amp; 1 &amp; 0\\ \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11\\dots 11} &amp; \\dots &amp; \\mathtt{0b10} &amp; 0 &amp; 0 &amp; \\dots &amp; 2 &amp; 0\\ \\quad\\text{ }\\text{ }0 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11\\dots 11} &amp; \\dots &amp; \\mathtt{0b010} &amp; 0 &amp; 0 &amp;  \\dots &amp; 2^2 &amp; 0\\ \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11\\dots 11} &amp; \\dots &amp; \\mathtt{0b1010} &amp; 0 &amp; 0 &amp;   \\dots &amp; 2^3 &amp; 0\\ \\text{ }\\text{ }\\text{ }\\text{ } \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots &amp; \\dots\\ \\quad\\text{ }\\text{ }0 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11\\dots 11} &amp; \\dots &amp; \\mathtt{0b0110011\\dots 1010} &amp; 0 &amp; 0 &amp; \\dots &amp; 2^{30} &amp; 0\\  \\quad\\text{ }\\text{ }1 &amp; \\mathtt{0b01\\dots10101101} &amp; \\mathtt{0b11\\dots 11} &amp; \\dots &amp; \\mathtt{0b10110011\\dots 1010} &amp; 0 &amp; 0 &amp; \\dots &amp; 2^{31} &amp; 1\\ \\hline</p> <p>\\end{array} $$</p> <p>Observe how factors \\(\\{\\mathtt{FSOut_i} |\\ 0 \\leq i \\leq 7\\}\\), in the above table, are used to construct the \\(32\\)-bit registers \\(\\{\\mathtt{sOut_i}|\\ 0 \\leq \\mathtt{i} \\leq 7 \\}\\). Notice also that the last row contains the complete set of the \\(256\\) bits. The relations that these columns fulfill are the following, $$ \\mathtt{sOut_i' = sOut_i \\cdot (1 \u2212 latchSOut) + sOutBit \\cdot FSOut_i }  $$</p> <p>where \\(0\\leq \\mathtt{i} \\leq 7\\).</p> <p>The \\(\\mathtt{latchSOut}\\) register ensures that \\(\\mathtt{sOutBit}\\) is not constrained at the very beginning of each \\(1993\\)-block, but only until the third subdivision is reached, where the \\(\\mathtt{FSOut_i}\\) begin to attain non-zero values.</p> <p>This concludes our design for creating a state machine for bits, the Padding-KK-Bit SM. What is left to be done is to connect both states machines and, of course, be able to check the validity of the last hash. See next subsection for an explanation this connection.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/04-Padding-KK-Bit-SM/#padding-kk-sm-and-padding-kk-bit-sm-connection","title":"Padding-KK SM and Padding-KK-Bit SM Connection","text":"<p>What follows is a description of how these two state machines, the Padding-KK SM and the Padding-KK-Bit SM, connect via Plookup. </p> <p>First of all, observe that there's a need to check whether the bytes received in one state machine are the same as those in the other. Also, corresponding sequential order of these bytes should be checked. The identifier register \\(\\mathtt{r8Id}\\) is added in both states machines for the very reason. In addition, each byte should have the same value in \\(\\mathtt{connected}\\) register. Hence, the following Plookup is added in the Padding-KK state machine,</p>  PIL Code : Plookup for checking byte correspondence ...  \\[ \\hline \\begin{aligned} \\mathtt{r8valid} &amp; \\text{ } \\{ &amp; \\text{} \\\\ \\text{ } &amp;\\texttt{aFreeIn} ,\\\\ &amp;\\texttt{r8Id} ,\\\\ &amp;\\texttt{connected}\\\\ \\}\\\\ \\text{ } \\mathtt{in}\\text{ } \\text{ }\\\\ \\{  \\\\ &amp;\\mathtt{PaddingKKBit.r8,} \\\\ &amp;\\mathtt{PaddingKKBit.r8Id,}\\\\ &amp;\\mathtt{PaddingKKBit.connected}\\\\  \\text{ }\\text{ }  \\};\\text{ }\\\\ \\hline  \\end{aligned} \\] <p>The Padding KK state machine has the \\(\\{\\mathtt{hash_i}\\}\\) registers while the Padding KK Bit state machine has the \\(\\{\\mathtt{sOut_i}\\}\\) registers, which must be related at some point during the execution. Yet, up this point, the order of the hashes has not been checked in any way. Hence, as previously done, an \\(\\mathtt{sOutId}\\) register is added in both machines in order to identify each of these hashes. </p> <p>In particular, \\(\\mathtt{sOutId}\\) is an increasing sequence of integers which increases by one at each processed block. That is, in the Padding-KK state machine, \\(\\mathtt{sOutId}\\) increases by one in each block of \\(136\\) rows, whilst in the Padding-KK-Bit state machine, it increases by one in each block of \\(1993\\) rows. (This is because a single block of \\(136\\) rows in the Padding-KK SM corresponds to a single block of \\(1993\\) rows in the Padding-KK-Bit SM.)</p> <p>Hence, the following Plookup is added.</p>  PIL Code : Plookup for checking correspondence of hash values  \\[ \\hline \\begin{aligned} \\mathtt{lastHashLatch} &amp; \\text{ } \\{ &amp; \\text{} \\\\ \\text{} &amp;\\texttt{hash0, hash1, hash2, hash3, } \\\\ &amp;\\texttt{hash4, hash5, hash6, hash7, \\quad } \\\\ &amp;\\texttt{sOutId}\\\\ \\} \\\\ \\text{ } \\mathtt{in}\\text{ } \\text{ }\\\\ \\{  \\\\ &amp;\\mathtt{PaddingKKBit.sOut0, PaddingKKBit.sOut1,} \\\\ &amp;\\mathtt{PaddingKKBit.sOut2, PaddingKKBit.sOut3,}\\\\ &amp;\\mathtt{PaddingKKBit.sOut4, PaddingKKBit.sOut5,}\\\\ &amp;\\mathtt{PaddingKKBit.sOut6, PaddingKKBit.sOut7,}\\\\ &amp;\\mathtt{ PaddingKKBit.sOutId}\\\\  \\text{ }\\text{ }  \\};\\quad\\text{}\\text{}\\\\ \\hline  \\end{aligned} \\]"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/05-Bits2Field-SM/","title":"Bits2Field State Machine","text":"<p>The Bits2Field State Machine, sm_Bits2Field.cpp, is one of the auxiliary state machines used specifically for parallelising implementation of the Keccak-f SM.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/05-Bits2Field-SM/#a-multiplexing-machine","title":"A Multiplexing Machine","text":"<p>The state machine ensures correct packing of \\(\\mathtt{44}\\) bits from \\(\\mathtt{44}\\) different \\(\\mathtt{1600}\\)-row blocks of the Padding-KK-Bit SM into a single field element.</p> <p>It operates like a (44 bits to 1 field element) multiplexer between the Padding-KK-Bit SM and the Keccak-f SM. </p> <p>That is, it takes bits from \\(\\mathtt{44}\\) different blocks, places them into the first 44 bit-positions of a single field element, whereupon the Keccak-f circuit runs. </p> <p>The name \\(\\texttt{Bits2Field}\\) State Machine refers to the processing where \\(44\\) bits from \\(44\\) different blocks of the Padding-KK-Bit SM are inserted into a single field element.</p> <p>Therefore, although the Keccak-f SM is a binary circuit, instead of executing on a bit-by-bit basis, it is implemented to execute Keccak-f operations on a \\(\\mathtt{44}\\)bits-by-\\(\\mathtt{44}\\)bits basis. This is tantamount to running \\(\\mathtt{44}\\) Keccak-f hashing circuits in parallel.</p> <p>The Bits2Field SM's multiplexing aimed, at parallelising the Keccak-f circuit sketched, is outlined below. </p> <p></p>  Figure 1: The 44 bits to 1 field-element Multiplexing"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/05-Bits2Field-SM/#mapping-44-bits-to-a-64-bit-field-element","title":"Mapping 44 Bits To A 64-bit Field Element","text":"<p>Suppose operations are carried out in a field \\(\\mathbb{F}_p\\) of \\(\\mathtt{64}\\)-bit numbers. The smallest field used in the zkProver is the Goldilocks Field  \\(\\mathbb{F}_p\\)  where \\(p = 2^{64} - 2^{32}+1\\).</p> <p>After multiplexing, the 44 bits are loaded into the first 44 least significant bit-positions of the field element as depicted in Figure 2 below.</p> <p>A field element as an input to the Keccak-f circuit is of the form,</p> \\[ \\mathtt{0b}\\mathtt{0000\\ 0000\\ 0000\\ 0000\\ 0000}\\ \\mathtt{X}_1 \\mathtt{X}_2 \\mathtt{X}_3 \\mathtt{X}_4\\ \\mathtt{X}_5 \\mathtt{X}_6 \\mathtt{X}_7 \\mathtt{X}_8\\ \\dots \\mathtt{X}_{43} \\mathtt{X}_{44} \\text{ } \\] <p>and it is composed of 20 zeroes and 44 meaningful bits related to the committed polynomials.</p> <p>Given the capacity of \\(2^{23}\\) in terms of the state machine evaluations (i.e., the degree of polynomials) and the Keccak-f's \\(\\texttt{SlotSize} = 155286\\), one obtains \\(2^{23} / 155286 = 54.020375307\\) Keccak-f slots. Therefore, a total of \\(54\\) slots \\(\\times\\) \\(44\\) blocks \\(= 2376\\) Keccak blocks can be processed. This is a big improvement from the previous \\(477\\) blocks of the 9 bits to 1 field element multiplexing (i.e., \\(53 \\times 9 = 477\\).)</p> <p></p>  Figure 2: How 44 Bits are mapped to a 64-bit field element"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/05-Bits2Field-SM/#the-bits2field-pil-code","title":"The Bits2Field PIL Code","text":"<p>The Bits2Field executor, sm_Bits2Field.cpp, executes the multiplexing of forty-four \\(\\mathtt{1600}\\)-bit blocks into \\(\\mathtt{1600}\\) field elements, where each is a \\(\\mathtt{N}\\)-bit field element. See Figure 2 above, where \\(\\mathtt{N = 64}\\).</p> <p>The question here is how to identify each of the original nine bits of the field element, so as to track their corresponding resultant \\(\\mathtt{XOR}\\) values or \\(\\mathtt{ANDP}\\) values? </p> <p>Note that every bit \\(\\mathtt{b_{i,j}}\\) from the \\(\\mathtt{i}\\)-th \\(\\mathtt{1600}\\)-bit block is placed at the \\(\\mathtt{2^{i}}\\)-th position of the \\(\\mathtt{N}\\)-bit field element.</p> <p>The PIL code therefore uses factors denoted by \\(\\mathtt{Factor}\\), such that \\(\\mathtt{Factor \\in \\{ 1, 2, 4, \\dots , 2^{43} \\}}\\), and a \\(\\mathtt{Fieldlatch}\\) after running through forty-four \\(\\mathtt{1600}\\)-bit blocks.</p> <p>Suppose \\(\\mathtt{N = 64}\\). Then the 44 least significant bits of the \\(\\mathtt{64}\\)-bit field element looks like this:</p> \\[ \\mathtt{field44 = X_1 \\cdot 2^{43} + X_{2}*{2}^{42} + X_{3}*{2}^{41} + \\dots + X_{42}*{2}^2 + X_{43}*2 + X_{44}}. \\] <p>The constraint checked is therefore,</p> \\[ \\mathtt{field44' = (1-Fieldlatch)*field44 + bit*Factor} \\] <p>The accumulated field element at the end of the execution (every forty-fourth row of the execution trace) is checked against the Keccak-f input \\(\\mathtt{KeccakF.a}\\) with the boundary constraint,</p> \\[ \\mathtt{Fieldlatch*(field44 - KeccakF.a) = 0} \\] <p>The PIL code is given below.</p>  The Bits2Field PIL Code  <pre><code>include \"keccakf.pil\";\n\nnamespace Bits2Field(%N);\n    pol constant FieldLatch;  // [0:44,1]\n    pol constant Factor;  // 1,2,4,8,...,2**43\n\n    pol commit bit;\n    pol commit field44;\n\n    field44' = (1-FieldLatch)*field44 + bit*Factor;\n    bit *(1-bit) = 0;\n\n    FieldLatch*(field44 - KeccakF.a44) = 0;\n</code></pre>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/","title":"Keccak-f State Machine","text":"<p>The Keccak-f State Machine (SM) is one of the secondary zkProver state machines. It computes hashes of message strings, and proves correctness of computation of these hashes, at the request of the Main SM.</p> <p>Although the original KECCAK hash function has a straight forward architecture, the Keccak-f SM is not a simplistically automated or state machine version of the cryptographic hash function.</p> <p>Firstly, the Keccak-f SM is implemented as a gates state machine. A binary circuit, operating on a bitwise basis.</p> <p>Secondly, as it relates to the Main SM, the Keccak-f SM is realised within a framework encompassing four other, supporting state machines; the Padding-KK SM, the Padding-KK-Bit SM and the Bits2Field SM.</p> <p>Thirdly, especially in the first version of the zkEVM public testnet, the Keccak-f circuit is implemented such that its single run is effectively equivalent to running forty-four (\\(44\\)) hashing circuits at once. See the Bits2Field SM for further details on how this parallelism technique is enforced.</p> <p>This document contains a brief outline of the \\(\\texttt{Keccak-f}\\) circuit, and a detailed description of the known and standard Keccak-256 hash function, with specific parameters as used in the zkEVM implementation.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#keccak-f-circuit","title":"Keccak-f Circuit","text":"<p>The \\(\\texttt{Keccak-f}\\) circuit has two types of gates, types \\(\\mathtt{0}\\) and \\(\\mathtt{1}\\), corresponding to the two binary operations it performs, the \\(\\mathtt{XOR}\\) and \\(\\mathtt{ANDP}\\). </p> <p>The \\(\\texttt{Keccak-f}\\) executor builds the constant polynomials, \\(\\mathtt{ConnA}\\), \\(\\mathtt{ConnB}\\) and \\(\\mathtt{ConnC}\\), and these are to be tested if they match their corresponding polynomials, \\(\\mathtt{kA}\\), \\(\\mathtt{kB}\\) and \\(\\mathtt{kC}\\).</p> <p>Also, for any \\(\\texttt{op} \\in \\{ \\mathtt{XOR}, \\mathtt{ANDP} \\}\\)  we have</p> \\[ \\texttt{op} \\big( \\mathtt{ConnA}, \\mathtt{ConnB}\\big) = \\mathtt{ConnC}, \\text{ } \\\\  \\texttt{op} \\big( \\mathtt{kA}, \\mathtt{kB} \\big) = \\mathtt{kC} \\] <p>The \\(44\\) bits are loaded into the state machine as \\(11\\)-bit chunks. </p> <p>In \\(\\texttt{keccakf.pil}\\), each committed polynomial \\(\\texttt{a[4]}\\) is expressed in terms of 4 chunks, where each is \\(11\\) bits long. The corresponding a \\(44\\)-bit array can be expressed as,  $$ \\texttt{a44} = \\texttt{a}[3] \\cdot 2^{33} + \\texttt{a}[2] \\cdot 2^{22} + \\texttt{a}[1] \\cdot 2^{11} + \\texttt{a}[0] $$ where \\(\\texttt{a}[i]\\) for each \\(i \\in \\{ 0, 1, 2, 3 \\}\\).  </p> <p>The verification involves a copy constraint</p> \\[ \\mathtt{ \\{ a44, b44, c44 \\} }\\ \\texttt{connect}\\ \\mathtt{ \\{ ConnA, ConnB, ConnC \\} }; \\] <p>and a Plook-up as,</p> \\[ \\mathtt{ \\{ GateType, a[i], b[i], c[i] \\} }\\ \\texttt{in} \\ \\mathtt{ \\{ kGateType, kA, kB, kC \\} }; \\] <p>for each \\(i \\in \\{ 0, 1, 2, 3 \\}\\).</p> <p>This covers the \\(\\texttt{Keccak-f}\\) circuit in a nutshell together with its PIL code. See the codes sm_keccakf.js and keccakf.pil.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#keccak-256-hash-function","title":"KECCAK-256 Hash Function","text":"<p>There are seven \\(\\texttt{Keccak}\\)-\\(f\\) permutation functions, each indicated by \\(\\texttt{Keccak}\\)-\\(f[b]\\), where \\(b = 5\\times 5\\times 2^l\\) is the size of the internal state of the hash function, for \\(0 \\leq l \\leq w\\).</p> <p>The zkProver's KECCAK State Machine is a verifiable automisation of a \\(\\texttt{Keccak}\\)-\\(f\\) permutation function, which amounts to an irreversible scrambling of bits of a string \\(\\mathbf{s} \\in \\mathbb{Z}_2^b\\), where \\(b = 5\\times 5\\times 2^6 = 1600\\).</p> <p>The EVM utilises the KECCAK-256 hash function, which is a sponge construction with capacity \\(c = 512\\) bits, and denoted by KECCAK\\([512]\\). That is, the KECCAK-256 notation puts emphasis on the \\(256\\)-bit security level, while the KECCAK\\([512]\\) notation seeks to depict the actual capacity of \\(512\\) bits.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#bitrate-and-capacity","title":"Bitrate and Capacity","text":"<p>Although the internal state is \\(\\mathtt{1600}\\) bits, \\(\\texttt{Keccak}\\)-\\(f\\) intakes a fixed number of bits as input, called the \\(\\texttt{bitrate}\\) (or simply, \\(\\texttt{rate}\\)) and it is denoted by \\(\\texttt{r}\\). In our specific case, the bitrate \\(\\texttt{r} = 1088\\), whilst the capacity, \\(\\texttt{c} = 512\\).</p> <p>The size of a single output is  \\(\\texttt{r} = 1088\\) bits. However, users can choose their required length by truncating the output, which is of length \\(\\texttt{d}\\), where \\(\\texttt{d} = 1088*k\\), for some positive integer \\(k\\).</p> <p>The \\(\\texttt{Keccak}\\)-\\(f\\) permutation used in KECCAK\\([c]\\) is KECCAK-\\(p[1600, 24]\\) (See NIST SHA-3 Standard).</p> <p>Thus, given an input bit string \\(\\mathtt{M}\\) and a output length \\(\\mathtt{d}\\), KECCAK\\([c](M, d)\\) outputs a \\(d\\)-bit string following the previous sponge construction description. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#keccak-f-padding-rule","title":"KECCAK-f Padding Rule","text":"<p>The \\(\\texttt{Keccak}\\)-\\(f\\) permutation operates on a state of width \\(b = 1600\\) bits (or \\(200\\) bytes) and a bitrate $$ \\mathtt{r = b - c = 1600 - 512 = 1088}\\ \\texttt{bits } \\mathtt{= 136}\\ \\texttt{bytes} $$ But not every input string comes with this tailored bit-length.</p> <p>Therefore, every input string is split into \\(\\mathtt{1088}\\)-bit chunks, where padding is applied to the tail-end chunk with \\(\\mathtt{1088}\\) bits or lesser.</p> <p>The last ingredient we need to define in order to completely specify the hash function is the padding rule. </p> <p>In KECCAK\\([c]\\), the padding \\(\\texttt{pad10*1}\\) is used. If we define \\(\\mathtt{j = (-m-2) \\mod{r}}\\), where \\(\\mathtt{m}\\) is the length of the input in bits, then the padding we have to append to the original input message is  $$ \\mathtt{P = 1 \\mid\\mid 0^{1088+j} \\mid\\mid 1}. $$</p> <p>It should be noted that our construction does not follow the FIPS-202 based standard (a.k.a SHA-3). According to the NIST specification, the SHA3 padding has been changed to</p> \\[ \\mathtt{\\text{SHA3-256}(M) = \\text{KECCAK}[512](M \\mid\\mid 01, 256)}. \\] <p>The difference is the additional \\(\\mathtt{01}\\) bits being appended to the original message, which were not present in the orignal KECCAK specification.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#the-keccak-f-internal-state","title":"The Keccak-f Internal State","text":"<p>The \\(\\mathtt{1088}\\)-bit (post-padding) chunks are provided sequentially, and one chunk at a time, into the \\(\\texttt{Keccak}\\)-\\(f\\) permutation function, to be \\(\\texttt{XOR}\\)ed with a given initialisation vector \\(\\texttt{IV}\\) or intermediate states. The capacity bits are typically initialised to zero bits and are not affected by any external bits.</p> <p>However, instead of a plain bit-string of length \\(\\mathtt{1600}\\) bits, a state \\(\\mathbf{s}\\) in the KECCAK SM is best visualised in 3D form as follows;</p> <ul> <li>Firstly, each bit is imagined as a cube,</li> <li>Secondly, the entire \\(\\mathtt{1600}\\)-bit state is thought of as a 3-dimensional array of cubes (bits): \\(\\text{A}[5][5][64]\\). That is, sixty-four (\\(5 \\text{-bit}\\times 5\\text{-bit}\\))-blocks of bits (cubes).</li> </ul> <p>See Figure 1 below, for a \\(\\mathtt{1600}\\)-bit state array, displaying;</p> <p>(a) The 64-bit lane \\(\\{[3,2,z]\\}\\) shown in orange, consisting of \\(64\\) bits, \\(\\mathtt{Bit}[3,2,0]\\) to \\(\\mathtt{Bit}[3,2,63]\\), and</p> <p>(b) The 5-bit column \\(\\{[2,y,63]\\}\\) shown in green, consisting of \\(5\\) bits, \\(\\mathtt{Bit}[2,0,63]\\) to \\(\\mathtt{Bit}[2,4,63]\\). </p> <p></p>   Figure 1: Keccak's 1600-bit State as a 3D Array  <p>A bit in the state \\(\\mathbf{s}\\) can be denoted by \\(\\texttt{Bit}[x][y][z]\\) as an element of the 3D-array state, but as \\(\\texttt{Bit}[x,y,z]\\) to indicate its location in position \\((x,y,z)\\) with respect to the Catersian coordinate system.</p> <p>The mapping between the bits of the state \\(\\mathbf{s}\\), when written as a linear array of \\(\\mathtt{1600}\\) bits, and the bits when \\(\\mathbf{s}\\) is expressed as a 3-dimesnional array, is given by, $$ \\mathbf{s}[64(5y + x) + z] \\mapsto \\mathtt{Bit}[x,y,z] $$ So then, the bit \\(\\mathtt{a} = \\mathtt{Bit}[2,3,3]\\) at coordinate \\((2,3,3)\\) is in fact the one-thousand-and-ninety-second bit of \\(\\mathbf{s}\\), because \\(64(5\\cdot 3 + 2) + 3 = 64(17) + 3 = 1091\\). This bit, \\(\\mathtt{a} = \\mathtt{Bit}[2,3,3]\\), is represented in Figure 1 above, by the blue cube. See more examples of this correspondence in Table 1, below.</p>   Table 1: Mapping Linear State to the 3D-Array  \\[ \\small \\begin{array}{|l|c|c|c|c|c|} \\hline \\textbf{x} &amp; \\textbf{y} &amp; \\textbf{z} &amp; \\textbf{s[ 64x + 320y + z]} &amp; \\textbf{Bit}\\textbf{[x,y,z]} &amp; \\textbf{Cube Colour in Fig.1.} \\\\ \\hline \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{0} &amp; \\mathtt{s[64\\cdot 0 + 320\\cdot 0 + 0]} = \\mathtt{s[0]\\ }\\ \\ \\ \\text{ }\\text{ }   &amp; \\mathtt{Bit[0,0,0]}\\text{ }\\text{ } &amp; \\texttt{Yellow} \\\\ \\hline \\mathtt{2} &amp; \\mathtt{2} &amp; \\mathtt{4} &amp;  \\mathtt{s[64\\cdot 2 + 320\\cdot 2 + 4]} = \\mathtt{s[772]}\\ \\text{ } &amp; \\mathtt{Bit[2,2,4]}\\text{ }\\text{ } &amp; \\texttt{Red} \\\\ \\hline \\mathtt{2} &amp; \\mathtt{3} &amp; \\mathtt{3} &amp; \\text{ } \\mathtt{s[64\\cdot 2 + 320\\cdot 3 + 3]} = \\mathtt{s[1091]}\\text{ } &amp; \\mathtt{Bit[2,3,3]}\\text{ }\\text{ } &amp; \\texttt{Blue} \\\\ \\hline \\mathtt{0} &amp; \\mathtt{2} &amp; \\mathtt{3} &amp; \\mathtt{s[64\\cdot 0 + 320\\cdot 2 + 3]} = \\mathtt{s[643]}\\text{ }\\text{ }  &amp; \\mathtt{Bit[0,2,3]}\\text{ }\\text{ } &amp; \\texttt{Purple} \\\\ \\hline \\mathtt{2} &amp; \\mathtt{2} &amp; \\mathtt{63} &amp; \\text{ } \\mathtt{s[64\\cdot 2 + 320\\cdot 2 + 63]} = \\mathtt{s[831]}\\text{ } &amp; \\mathtt{Bit[2,2,63]} &amp; \\texttt{Green} \\\\ \\hline \\mathtt{2} &amp; \\mathtt{1} &amp; \\mathtt{63} &amp; \\text{ } \\mathtt{s[64\\cdot 2 + 320\\cdot 1 + 63]} = \\mathtt{s[511]}\\text{ } &amp; \\mathtt{Bit[2,1,63]}  &amp; \\texttt{Green} \\\\ \\hline \\mathtt{2} &amp; \\mathtt{0} &amp; \\mathtt{63} &amp; \\text{ } \\mathtt{s[64\\cdot 2 + 320\\cdot 0 + 63]} = \\mathtt{s[191]} \\text{ } &amp; \\mathtt{Bit[2,0,63]} &amp; \\texttt{Green} \\\\ \\hline \\mathtt{2} &amp; \\mathtt{4} &amp; \\mathtt{63} &amp; \\text{ }\\text{ } \\mathtt{s[64\\cdot 2 + 320\\cdot 4 + 63]} = \\mathtt{s[1471]} &amp; \\mathtt{Bit[2,4,63]} &amp; \\texttt{Green} \\\\ \\hline \\mathtt{2} &amp; \\mathtt{3} &amp; \\mathtt{63} &amp; \\text{ }\\text{ } \\mathtt{s[64\\cdot 2 + 320\\cdot 3 + 63]} = \\mathtt{s[1151]} &amp; \\mathtt{Bit[2,3,63]} &amp; \\texttt{Green} \\\\ \\hline \\end{array} \\] <p>Consider computing the \\(\\texttt{XOR}\\) of all the 5 bits in the column \\(\\{[2,y,63]\\}\\) , the green column of Figure 1 above. If its bits are as given below, $$ \\mathtt{Bit[2,2,63]} = 1,\\ \\mathtt{Bit[2,1,63]} = 1,\\ \\mathtt{Bit[2,0,63]} = 0,\\ \\mathtt{Bit[2,4,63]} = 0\\ \\text{ and }\\ \\mathtt{Bit[2,3,63]} = 1 $$ then the \\(\\texttt{XOR}\\) of the column bits, denoted by \\(C[2,63]\\), is \\(C[2,63] = 1 \\oplus 1 \\oplus 0 \\oplus 0 \\oplus 1 = 1\\).</p> <p>In our notation, a column is identified by the fixed \\(x\\)- and \\(z\\)- values. Hence the \\(\\texttt{XOR}\\) of all the 5 bits in a column is denoted by \\(\\mathtt{C[x,z]}\\). That is,  $$ \\mathtt{C[x,z]} = \\mathtt{Bit[x,0,z]} \\oplus \\mathtt{Bit[x,1,z]} \\oplus \\mathtt{Bit[x,2,z]}  \\oplus \\mathtt{Bit[x,3,z]}  \\oplus \\mathtt{Bit[x,4,z]} $$</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#the-keccak-f-rounds","title":"The KECCAK-f Rounds","text":"<p>The \\(\\texttt{Keccak}\\)-\\(f\\) State Machine runs 24 rounds, each of which is but a composition of five step mappings; \\(\\mathtt{\\theta}\\), \\(\\mathtt{\\rho}\\),  \\(\\mathtt{\\pi}\\),  \\(\\mathtt{\\chi}\\) and \\(\\mathtt{\\iota}\\), denoted by $$ \\texttt{Rnd(A, ir)} = \u03b9( \u03c7( \u03c0( \u03c1( \u03b8(A) ) ) ), \\mathtt{ir}) $$ where \\(\\texttt{ir}\\) is the round index, and in our case, \\(0 \\leq \\texttt{ir} \\leq 23\\).</p> <p>These step mappings are individually described in the subsections below. The following table illustrates how the output state of each step mapping is relayed to the next step mapping as its input state.</p>   Table 2: Composition of the Step Mappings  \\[ \\small \\begin{array}{|l|c|c|c|c|c|} \\hline \\textbf{Pseudo-code of the Composition} &amp; \\textbf{The keccak\\_f.cpp Code}\\\\ \\hline  \\text{Run a *for-loop* over bits in a 25-bit slice of the state } \\texttt{S} &amp; \\texttt{for} \\mathtt{(uint64\\_t\\ \\ ir=0; ir&lt;24; ir++ )}\\\\ \\hline \\text{ } &amp;\\{ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\\\ \\hline \\text{Apply step mapping } \\theta \\text{ on current state}\\texttt{ S} &amp;\\text{ } \\mathtt{KeccakTheta(S, ir);} \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline  \\text{Copy output of } \\theta \\text{ and set it as an input state of  } \\rho  &amp; \\text{ } \\mathtt{S.copySoutRefsToSinRefs();} \\\\ \\hline  \\text{Apply step mapping } \\rho \\text{ to the input state. } &amp; \\text{ } \\mathtt{KeccakRho(S);} \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline  \\text{Copy output of } \\rho \\text{ and set it as an input state of  } \\pi &amp; \\text{ } \\mathtt{S.copySoutRefsToSinRefs();} \\\\ \\hline  \\text{Apply step mapping } \\pi \\text{ to the input state.} &amp; \\text{ } \\mathtt{KeccakPi(S);} \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline  \\text{Copy output of } \\pi \\text{ and set it as an input state of  } \\chi  &amp; \\text{ } \\mathtt{S.copySoutRefsToSinRefs();} \\\\ \\hline  \\text{Apply step mapping } \\chi \\text{ to the input state.} &amp; \\text{ } \\mathtt{KeccakChi(S);} \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline  \\text{Copy output of } \\chi \\text{ and set it as an input state of  } \\iota  &amp; \\text{ } \\mathtt{S.copySoutRefsToSinRefs();} \\\\ \\hline  \\text{Apply step mapping } \\iota \\text{ to the input state.} &amp; \\text{ } \\mathtt{KeccakIota(S);} \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\hline  \\text{Set output of } \\iota \\text{ as new state, and reset to } 0 \\text{ for next round } &amp; \\text{ } \\mathtt{S.copySoutRefsToSinRefs();} \\\\ \\hline \\text{ } &amp;\\} \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\\\ \\hline \\end{array} \\] <p>Henceforth, given a state value, the next value of the bit \\(\\text{A}[x,y,z]\\) is denoted by \\(\\text{A}'[x,y,z]\\). The code shown on the right side of Table 2 is keccakf.cpp.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#the-first-step-mapping-theta","title":"The First Step Mapping \\(\\theta\\)","text":"<p>The first step mapping, \\(\\mathtt{\\theta}\\), referred to as \\(\\texttt{KeccakTheta()}\\) in keccak_f.cpp, can be described in three sub-steps;</p> <p>Firstly, compute the \\(\\mathtt{XOR}\\) of the bits in the \\([(x-1)\\text{ mod }5, z]\\)-column,</p> \\[ \\begin{aligned} \\mathtt{C[(x-1)\\text{ mod }5, z]  = } \\text{  } \\mathtt{Bit[(x-1)\\text{ mod }5,0,z]} \\oplus\\\\ \\mathtt{Bit[(x-1)\\text{ mod }5,1,z]} \\oplus\\\\  \\mathtt{Bit[(x-1)\\text{ mod }5,2,z]} \\oplus\\\\ \\mathtt{Bit[(x-1)\\text{ mod }5,3,z]} \\oplus\\\\  \\mathtt{Bit[(x-1)\\text{ mod }5,0,z]}\\text{ }\\text{ }\\text{ }   \\end{aligned} \\] <p>and the \\(\\mathtt{XOR}\\) of the bits in the \\([(x+1)\\text{ mod }5, (z-1)\\text{ mod }64]\\)-column,</p> \\[ \\begin{aligned} \\mathtt{C[(x+1)\\text{ mod }5, (z-1)\\text{ mod } 64] =\\text{ }} \\mathtt{Bit[(x+1)\\text{ mod }5,0,(z-1)\\text{ mod } 64]} \\oplus \\\\ \\mathtt{Bit[(x+1)\\text{ mod }5,1,(z-1)\\text{ mod } 64]}\\text{ }\\oplus\\\\ \\mathtt{Bit[(x+1)\\text{ mod }5,2,(z-1)\\text{ mod } 64]}\\text{ } \\oplus\\\\  \\mathtt{Bit[(x+1)\\text{ mod }5,3,(z-1)\\text{ mod } 64]}\\text{ }\\oplus\\\\ \\mathtt{Bit[(x+1)\\text{ mod }5,0,(z-1)\\text{ mod } 64]}\\quad \\end{aligned} \\] <p>Secondly, calculate the \\(\\mathtt{XOR}\\) of the two column \\(\\mathtt{XOR}\\)s;</p> \\[ \\mathtt{D[x,z]\\text{ } =}\\text{ } \\mathtt{C[(x-1)\\text{ mod }5, z]\\text{ } \\oplus\\text{ } {C}[(x+1)\\text{ mod }5, (z-1)\\text{ mod } 64]} \\] <p>Thirdly, compute the \\(\\mathtt{XOR}\\) of \\(\\mathtt{D[x,z]}\\) and the bit \\(\\mathtt{A[x,y,z]}\\) of the current state value;</p> <p>$$ \\mathtt{A'[x,y,z] = {A}[x,y,z] \\oplus {D}[x,z]} $$ See Figure 2 below, for an illustration of the \\(\\theta\\) step mapping applied on one bit. (The diagram is taken from Keccak Reference 3.0.)</p> <p>The code of the \\(\\theta\\) step mapping is found here keccak_theta.cpp.</p> <p></p>  Figure 2: The Theta Step Mapping On One Bit"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#the-second-step-mapping-rho","title":"The Second Step Mapping \\(\\rho\\)","text":"<p>The step mapping \\(\\rho\\) does not change the value of the input bit, but simply moves it to another position along the \\(z\\)-axis. Since all operations along the \\(z\\)-axis are worked out modulo 64, the mapping \\(\\rho\\) is therefore cyclic, and amounts to rotating each of the 64 bits in the same lane along the \\(z\\)-axis. It does this in three sub-steps;</p> <ol> <li>Set \\(\\mathtt{(x,y) = (0,1)}\\),</li> <li>For  \\(t\\)  ranging from \\(0\\) to \\(23\\), set \\(\\mathtt{{A}'[x,y,z] = {A}\\big[x,y,\\big(z-(t+1)(t+2)/2 \\big)\\text{mod }64\\big]}\\),</li> <li>Set \\(\\mathtt{(x,y) = (y,(2x + 3y)\\text{mod }5)}\\).</li> </ol> <p>Basically, \\(\\rho\\) modifies the \\(z\\) coordinate of each bit, \\(\\mathtt{Bit}[x,y,z]\\), by subtracting a specific offset constant \\(\\mathbf{K}\\) modulo 64, where \\(\\mathbf{K} = (t+1)(t+2)/2\\). See Table 3 for these offset constants used for rotation.</p>   Table 3: The Offset Constants (computed from 't')  \\[ \\begin{array}{|l|c|c|c|c|c|c|} \\hline \\mathbf{t} &amp; \\mathbf{K} &amp; \\mathbf{K} \\textbf{ mod } \\mathbf{64} &amp; \\text{} &amp; \\mathbf{t} &amp; \\mathbf{K} &amp; \\mathbf{K} \\textbf{ mod } \\mathbf{64} \\\\ \\hline 0 &amp; 1 &amp; 1 &amp; \\text{} &amp; 12 &amp; 91 &amp; 27 \\\\ \\hline 1 &amp; 3 &amp; 3 &amp; \\text{} &amp; 13 &amp; 105 &amp; 41 \\\\ \\hline 2 &amp; 6 &amp; 6 &amp; \\text{} &amp; 14 &amp; 120 &amp; 56 \\\\ \\hline 3 &amp; 10 &amp; 10 &amp; \\text{} &amp; 15 &amp; 136 &amp; 8 \\\\ \\hline 4 &amp; 15 &amp; 15 &amp; \\text{} &amp; 16 &amp; 153 &amp; 25 \\\\ \\hline 5 &amp; 21 &amp; 21 &amp; \\text{} &amp; 17 &amp; 171 &amp; 43 \\\\ \\hline 6 &amp; 28 &amp; 28 &amp; \\text{} &amp; 18 &amp; 190 &amp; 62 \\\\ \\hline 7 &amp; 36 &amp; 36 &amp; \\text{} &amp; 19 &amp; 210 &amp; 18 \\\\ \\hline 8 &amp; 45 &amp; 45 &amp; \\text{} &amp; 20 &amp; 231 &amp; 39 \\\\ \\hline 9 &amp; 55 &amp; 55 &amp; \\text{} &amp; 21 &amp; 253 &amp; 61 \\\\ \\hline 10 &amp; 66 &amp; 2 &amp; \\text{} &amp; 22 &amp; 276 &amp; 20 \\\\ \\hline 11 &amp; 78 &amp; 14 &amp; \\text{} &amp; 23 &amp; 300 &amp; 44 \\\\ \\hline \\end{array} \\] <p>The 24 constants in Table 3 above, are first permuted and then set as fixed offsets corresponding to each bit of the 3D state array, as shown in the Table 4.</p>  Table 4: Permuted and Fixed Offset Constants  \\[ \\begin{array}{|l|c|c|c|c|c|c|} \\hline \\texttt{y}\\Big{\\\\} \\texttt{x} &amp; 3 &amp; 4 &amp; 0 &amp; 1 &amp; 2\\\\ \\hline 2 &amp; 25 &amp; 39 &amp; 3 &amp; 10 &amp; 43\\\\ \\hline 1 &amp; 55 &amp; 20 &amp; 36 &amp; 44 &amp; 6\\\\ \\hline 0 &amp; 28 &amp; 27 &amp; 0 &amp; 1 &amp; 62\\\\ \\hline 4 &amp; 56 &amp; 14 &amp; 18 &amp; 2 &amp; 61\\\\ \\hline 3 &amp; 21 &amp; 8 &amp; 41 &amp; 45 &amp; 15\\\\ \\hline \\end{array} \\] <p>Note that all bits \\(\\mathtt{Bit[x,y,z]}\\) such that \\(\\mathtt{x = 0}\\) and \\(\\mathtt{y = 0}\\) correspond to a zero offset constant. Consequently, the origin \\(\\mathtt{Bit}[0,0,0]\\) and all the other 63 bits along the \\(\\{\\mathtt{Bit[0,0,z]}\\}\\) lane remain unmoved by \\(\\rho\\).</p> <p>Although the effect of \\(\\rho\\) is a rotation of bits along the \\(z\\)-axis, it actually operates on each 25-bit \\((x,y)\\)-slice of the state 3D-array. Hence the 25 offset constants (and not 64), including the zero offset of the origin lane \\(\\{\\mathtt{Bit[0,0,z]}\\}\\).</p> <p>Example. </p> <p>Here's an example of how \\(\\rho\\) maps two different lanes, using Table 4.</p> <p>(a) For all \\(z\\), where \\(0\\leq z\\leq63\\), the bits \\(\\{\\mathtt{Bit}[2,4,z]\\}\\) are always off-set by \\(61\\) and mapped as follows,  $$ \\rho\\big(\\mathtt{Bit}[2,4,z]\\big) \\mapsto \\mathtt{Bit}[4,1,(z-61)\\text{mod }64] $$ (b) Similarly, the bits \\(\\{\\mathtt{Bit}[4,1,z]\\}\\) are always off-set by \\(20\\) and mapped as follows, $$ \\rho\\big(\\mathtt{Bit}[4,1,z]\\big) \\mapsto \\mathtt{Bit}[1,1,(z-20)\\text{mod }64] $$</p> <p>The code of the \\(\\rho\\) step mapping is found here keccak_rho.cpp.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#the-third-step-mapping-pi","title":"The Third Step Mapping \\(\\pi\\)","text":"<p>The step mapping \\(\\pi\\) is literally a shuffle of the 25 bits in each \\((x,y)\\)-slice. For each \\(z\\), where \\(0\\leq z\\leq63\\), it is defined as the mapping, $$ \\pi\\big(\\mathtt{Bit}[x,y,z]\\big) \\mapsto \\mathtt{Bit}[(x+3y)\\text{mod }5,x,z] $$</p> <p>Note that \\(\\pi\\) fixes each of the bits \\(\\{\\mathtt{Bit}[0,0,z]\\}\\), including the bit at the origin, \\(\\mathtt{Bit}[0,0,0]\\). Also, for all bits in the 3D-array, \\(\\pi\\) does not change the \\(z\\)-component. That is, all bits remain in their original \\((x,y)\\)-slice. To this extend, it suffices to describe \\(\\pi\\) in terms of the images of the \\((x,y)\\) pairs alone, as in Table 5 below.</p>  Table 5: KeccakPi in terms of its (x,y)-images  \\[ \\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\mathbf{(x,y)} &amp; \\mathbf{x+3y} &amp; \\mathbf{(x+3y)}\\textbf{mod }\\mathbf{5} &amp; \\mathbf{\\pi(x,y)} &amp; \\text{} &amp; \\mathbf{(x,y)} &amp; \\mathbf{x+3y} &amp; \\mathbf{(x+3y)}\\textbf{mod }\\mathbf{5} &amp; \\mathbf{\\pi(x,y)}\\\\ \\hline (2,2) &amp; 8 &amp; 3 &amp; (3,2) &amp; \\text{} &amp; (3,4) &amp; 15 &amp; 0 &amp; (0,3) \\\\ \\hline (1,1) &amp; 4 &amp; 4 &amp; (4,1) &amp; \\text{} &amp; (1,3) &amp; 10 &amp; 0 &amp; (0,1) \\\\ \\hline (4,4) &amp; 16 &amp; 1 &amp; (1,4) &amp; \\text{}  &amp; (4,2) &amp; 10 &amp; 0 &amp; (0,4) \\\\ \\hline (3,3) &amp; 12 &amp; 2 &amp; (2,3) &amp; \\text{} &amp; (2,1) &amp; 5 &amp; 0 &amp; (0,2) \\\\ \\hline (3,0) &amp; 3 &amp; 3 &amp; (3,3) &amp; \\text{} &amp; (1,2) &amp; 7 &amp; 2 &amp; (2,1) \\\\ \\hline (4,0) &amp; 4 &amp; 4 &amp; (4,4) &amp; \\text{} &amp; (2,4) &amp; 14 &amp; 4 &amp; (4,2)  \\\\ \\hline (1,0) &amp; 1 &amp; 1 &amp; (1,1) &amp; \\text{} &amp; (3,1) &amp; 6 &amp; 1 &amp; (1,3) \\\\ \\hline (2,0) &amp; 2 &amp; 2 &amp; (2,2) &amp; \\text{} &amp; (4,3) &amp; 13 &amp; 3 &amp; (3,4) \\\\ \\hline (0,2) &amp; 6 &amp; 1 &amp; (1,2) &amp; \\text{} &amp; (3,2) &amp; 9 &amp; 4 &amp; (4,3) \\\\ \\hline (0,1) &amp; 3 &amp; 3 &amp; (3,0) &amp; \\text{} &amp; (4,1) &amp; 7 &amp; 2 &amp; (2,4) \\\\ \\hline (0,4) &amp; 12 &amp; 2 &amp; (2,0) &amp; \\text{} &amp; (1,4) &amp; 13 &amp; 3 &amp; (3,1) \\\\ \\hline (0,3) &amp; 9 &amp; 4 &amp; (4,0) &amp; \\text{} &amp; (2,3) &amp; 11 &amp; 1 &amp; (1,2) \\\\ \\hline \\end{array} \\] <p>Figure 3 below, showing the \\((x,y)\\)-slices, depicts the shuffling of the bits in accordance with Table 5. Figure 3 is in fact the mapping displayed in Figure 2.3 of the Keccak Reference 3.0 [Page 20; 2011].</p> <p></p>  Figure 3: How KeccakPi() shuffles bits on a 25-bit (x,y)-slice  <p>The code of the \\(\\pi\\) step mapping is found here keccak_pi.cpp.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#the-fourth-step-mapping-chi","title":"The Fourth Step Mapping \\(\\chi\\)","text":"<p>The \\(\\chi\\) step mapping is the non-linear layer of \\(\\texttt{Keccak}\\)-\\(f\\), and it can be thought of as a parallel application of \\(320 = 5*64\\) S-boxes operating on \\(5\\)-bit rows.</p> <p>Here's how \\(\\chi\\) operates on rows. For a fixed \\(y = b\\) and \\(z = c\\), the \\(\\chi\\) step mapping takes as its input the \\(5\\)-bit row, $$ \\mathbf{Row}[b,c] = \\Big(\\mathtt{Bit}[3,b,c],\\mathtt{Bit}[4,b,c],\\mathtt{Bit}[0,b,c],\\mathtt{Bit}[1,b,c],\\mathtt{Bit}[2,b,c]\\Big) $$ It then computes a non-linear combination of each bit \\(\\mathtt{Bit}[x,b,c]\\) in \\(\\mathbf{Row}[b,c]\\), with the next two consecutive bits \\(\\mathtt{Bit}[(x+1)\\text{mod }5,b,c]\\) and \\(\\mathtt{Bit}[(x+2)\\text{mod }5,b,c]\\) also in \\(\\mathbf{Row}[b,c]\\), as follows;</p> <p>\u200b   In order to change the bit, \\(\\mathtt{Bit}[x,b,c]\\),</p> <p>(a) \\(\\chi\\) takes \\(\\mathtt{Bit}[(x+1)\\text{mod }5,b,c]\\) as input to a \\(\\texttt{NOT}\\)-gate.</p> <p>(b) Then takes the output, \\(\\texttt{NOT}\\big(\\mathtt{Bit}[(x+1)\\text{mod }5,b,c]\\big)\\), together with \\(\\mathtt{Bit}[(x+2)\\text{mod }5,b,c]\\), as inputs to an \\(\\texttt{AND}\\)-gate.</p> <p>(c) Finally, it XORes the output of the \\(\\texttt{AND}\\)-gate with the bit being changed, \\(\\mathtt{Bit}[x,b,c]\\).</p> <p>That is, for each 5-bit row, \\(\\mathbf{Row}[b,c]\\),  \\(\\chi\\) can be summarised as the mapping of each bit, \\(\\mathtt{Bit}[x,b,c]\\), as; $$ \\chi : \\mathtt{Bit}[x,b,c] \\mapsto \\Big(\\big(\\texttt{NOT}\\big(\\mathtt{Bit}[(x+1)\\text{mod }5,b,c]\\big) \\big) \\texttt{ AND }\\big(\\mathtt{Bit}[(x+2)\\text{mod }5]\\big)\\Big)\\ \\oplus\\ \\mathtt{Bit}[x,b,c] $$ where  \\(x \\in \\{3,4,0,1,2\\}\\).  </p> <p>All-in-all, the \\(\\chi\\) step mapping can be depicted as a 'circuit' of gates as in Figure 4 below, taken from FIPS PUB 202, August 2015 (i.e., Figure 6, on Page15).</p> <p></p>  Figure 4: The KeccakChi Gates Circuit  <p>The code of the \\(\\chi\\) step mapping is found here keccak_chi.cpp.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#the-fifth-step-mapping-iota","title":"The Fifth Step Mapping \\(\\iota\\)","text":"<p>The \\(\\large{\\iota}\\) step mapping adds 64-bit round-constants, \\(RC[ir]\\), so as to disrupt any symmetry in the computation of the round outputs. Note that \\(ir\\) is the round index, \\(0\\leq ir \\leq 23\\). Hence, 24 distinct round-constants are required, and are denoted in array notation as,  $$ {RC[ir][z]\\ |\\ 0\\leq ir \\leq 23 \\text{ and } 0\\leq z \\leq 63 } $$ The round-constants are XORed only to a single lane of the state, in particular, the origin lane (i.e., the 64 bits \\(\\{\\mathtt{Bit}[0,0,z]\\}\\) where \\(0\\leq z \\leq 63\\)).</p> <p>Here's how \\(\\large{\\iota}\\) operates on the origin lane, \\(\\{\\mathtt{Bit}[0,0,z]\\ |\\ 0\\leq z \\leq 63\\}\\). </p> <p>Firstly, the derivation of the round-constants \\(RC[ir]\\). As shown in the algorithm of \\(\\large{\\iota}\\), given below, the round-constant \\(RC\\) is initialised to \\(0^{w}\\) at the beginning of each round of \\(\\large{\\iota}\\). After which, 7 specific bit-places \\(\\{2^j \u2013 1\\ |\\ 0 \\leq j \\leq 6 \\}\\) of the round-constant are set to the bits \\(\\{rc[j + 7 ir]\\ |\\ 0 \\leq j \\leq 6 \\}\\). Meanwhile, the rest of the bits remain as zeros. </p>  Table 6: Mapping RC[ir] bit-places to indices of the set 7 bits  \\[ \\begin{array}{|l|c|c|c|c|c|c|} \\hline \\mathtt{j} &amp; \\mathtt{2^j - 1} &amp; \\mathtt{j + 7ir}\\\\ \\hline 0 &amp; 0 &amp; 0 + 7\\mathtt{ir}\\\\ \\hline 1 &amp; 1 &amp; 1 + 7\\mathtt{ir}\\\\ \\hline 2 &amp; 3 &amp; 2 + 7\\mathtt{ir}\\\\ \\hline 3 &amp; 7 &amp; 3 + 7\\mathtt{ir}\\\\ \\hline 4 &amp; 15 &amp; 4 + 7\\mathtt{ir}\\\\ \\hline 5 &amp; 31 &amp; 5 + 7\\mathtt{ir}\\\\ \\hline 6 &amp; 63 &amp; 6 + 7\\mathtt{ir}\\\\ \\hline \\end{array} \\] <p>The derivation of the 7 bits, \\(\\{rc[j + 7 ir]\\}\\), is explained below.</p> <p>Secondly, each round of \\(\\large{\\iota}\\) simply XORes the corresponding 64-bit round-constant to the 64-bit lane, \\(\\{\\mathtt{Bit}[0,0,z]\\ |\\ 0\\leq z \\leq 63 \\}\\). Since only 7 bits of the round-constant are set, each round of \\(\\large{\\iota}\\) therefore alters at most 7 bits of origin lane.</p> \\[ \\textbf{Algorithm: Keccak-f Iota Mapping} \\text{} \\\\ \\textbf{Input: }\\text{ state array }\\mathbf{ A }\\text{, round index } ir \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\textbf{Output:}\\text{ state array }\\mathbf{ A'}\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{} \\\\ \\text{Steps:}\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\text{ 1. For all triples } (x, y, z) \\text{ such that } 0 \u2264 x &lt;5, 0 \u2264 y &lt; 5,\\\\  \\text{ and } 0 \u2264 z &lt; w, \\text{ let } \\mathbf{A'}[x, y, z] = \\mathbf{A}[x, y, z]\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\\\ \\text{2. Let } RC = 0^w. \\text{ } \\ \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\\\ \\text{3. For } j \\text{ from } 0 \\text{ to } l, \\text{ let } RC[2^j \u2013 1] = rc[j + 7 ir]. \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\\\ \\text{4. For all } z \\text{ such that } 0 \u2264 z &lt;w,\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\  \\text{ let } \\mathbf{A'} [0, 0, z] = \\mathbf{A'}[0, 0, z] \\bigoplus RC[z].\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\\\ \\text{5. Return } A' \\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ }\\text{ } \\] <p>In our implementation \\(l = 6\\), and thus \\(w = 2^6 = 64\\). </p> <p>The code of the \\(\\large{\\iota}\\) step mapping is found here keccak_iota.cpp.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/06-KECCAK-f-sm/#generation-of-7-bits-for-round-constants","title":"Generation of 7 Bits for Round-Constants","text":"<p>In order to ensure that these round-constants differ from round-to-round, a linear feedback shift register (LFSR) of maximal length is used to generate them. The algorithm for generating these round-constants is given below.</p> <p>The LFSR can run for 255 clocks before resetting to \\(0\\), and has 8 registers; \\(R[0],R[1],R[2],R[3],R[4],R[5],R[6],R[7]\\). </p> <p>At \\(t = 0\\), it is initialised to \\(\\mathtt{10000000 = 0x80}\\). A state transition (or a shift) consists of;</p> <p>\u200b   (a) A push of a bit \\(0\\) into the first register \\(R[0]\\) while shifting the bit in register \\(R[i]\\) to \\(R[(i+1)\\text{ mod }8]\\) for each \\(i\\) , where \\(0 \\leq i \\leq 7\\).</p> <p>\u200b   (b) XOR of the bit from register \\(R[8]\\) with register \\(R[0]\\).</p> <p>\u200b   (c) XOR of the bit from register \\(R[8]\\) with register \\(R[4]\\).</p> <p>\u200b   (d) XOR of the bit from register \\(R[8]\\) with register \\(R[5]\\).</p> <p>\u200b   (e) XOR of the bit from register \\(R[8]\\) with register \\(R[6]\\).</p> <p>\u200b   (f) Output the bit in the first register \\(R[0]\\) as \\(rc[j+7ir]\\).</p> <p>After every 7 consecutive state transitions the LFSR produces enough bits to form the corresponding round-constant \\(RC[ir]\\). The 7 bits map to their bit places in \\(RC[ir]\\) according to Table 6 above. </p> <p></p> <p> Figure 5: A simplified LFSR for the rc[j+7ir] bits </p> <p>Example 2.</p> <p>Since the LFSR is initialised to \\(\\mathtt{10000000 = 0x80}\\) at \\(t = 0\\), its state at the end of 7 state transitions is \\(|0|0|0|0|0|0|0|1|\\). So \\(rc[7] = 0\\). After the 8-th state transition the state of the LFSR is \\(|1|0|0|0|1|1|1|0|\\), and thus \\(rc[8] = 1\\). The next table displays generation of the 7 bits needed to construct the second round-constant, \\(RC[1]\\). That is, the LFSR's state transitions for \\(t = 7\\) to \\(t = 13\\).</p>  Table 7: Generation of the 7 bits for the second round-constant RC[1]  \\[ \\small \\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\text{ }\\texttt{t} &amp; \\texttt{R[0]} &amp; \\texttt{R[1]} &amp; \\texttt{R[2]} &amp; \\texttt{R[3]} &amp; \\texttt{R[4]} &amp; \\texttt{R[5]} &amp; \\texttt{R[6]}  &amp; \\texttt{R[7]} &amp; \\text{} &amp; \\texttt{j} &amp; \\texttt{rc[j+7]} &amp; \\mathtt{2^j-1} &amp; \\mathtt{RC[1][2^j-1]} \\\\ \\hline \\text{ }7 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; \\text{} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline \\text{ }8 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; \\text{} &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ \\hline \\text{ }9 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; \\text{} &amp; 2 &amp; 0 &amp; 3 &amp; 0 \\\\ \\hline 10 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; \\text{} &amp; 3 &amp; 1 &amp; 7 &amp; 1 \\\\ \\hline 11 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \\text{} &amp; 4 &amp; 1 &amp; 15 &amp; 1 \\\\ \\hline 12 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; \\text{} &amp; 5 &amp; 0 &amp; 31 &amp; 0 \\\\ \\hline 13 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; \\text{} &amp; 6 &amp; 0 &amp; 63 &amp; 0 \\\\ \\hline \\end{array} \\] <p>It can be observed, on the right-hand side of Table 7, that the \\(\\mathtt{rc[j+7]}\\) and \\(\\mathtt{RC[1][2^j - 1]}\\) are the same. That is,</p> \\[ \\begin{aligned} RC[1][63] = 0 = rc[13],\\text{ } RC[1][31] = 0 = rc[12],\\text{ } RC[1][15] = 1 = rc[11],\\\\ RC[1][7] = 1 = rc[10], \\text{ } RC[1][3] = 0 = rc[9], \\text{ } RC[1][1] = 1 = rc[8],\\qquad \\\\  RC[1][0] = 0 = rc[7] \\text{ and }\\ RC[1][l] = 0\\ \\text{ for all }\\ l \\notin \\{ 0, 1, 3, 7, 15, 31, 63 \\}\\text{ }\\\\ \\end{aligned} \\] <p>This results in the round-constant,</p> \\[ \\begin{aligned} RC[1] = RC[1][63]\\ RC[1][62]\\ RC[1][61]\\ \\dots\\ RC[1][3]\\ RC[1][2]\\ RC[1][1]\\ RC[1][0]\\\\ RC[1] = 0b0000 0000\\ 0000 0000\\ \\dots\\ 1000 0000\\ 1000 1010 \\qquad\\qquad\\qquad\\qquad\\quad\\quad\\text{ }\\text{ } \\\\ RC[1] = \\mathtt{0x0000000000008082} \\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\text{ }\\text{ } \\end{aligned} \\] <p>All 24 round constants \\(RC[i]\\), where each is \\(64\\) bits long, are given in their hexadecimal format below.</p> <p></p>  Figure 6: The 24 Round Constants in Hexadecimal  <p>The C++ code for the LFSR is found in the zkEVM prover repository here keccak_rc.cpp. </p> <p>All these step mappings are consolidated in the keccakf.cpp code, which calls them as functions (see Table 2 above).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/07-Poseidon-sm/","title":"Poseidon State Machine","text":"<p>The Poseidon State Machine (SM) is one of the zkProver's fourteen (14) state machines. It is also a secondary state machine taking instructions from the zkProver's Main SM.  </p> <p>It computes hash values, using the Poseidon hash function, as per instruction of the Main SM Executor, as well as requests from the Storage SM. The instructions the Poseidon SM receives, from any of the two SMs, are called Poseidon Actions. As a secondary SM, it not only executes the Poseidon Actions, but it also checks if the output hash values were correctly computed. </p> <p>Therefore the Poseidon State Machine has the executor part (the Poseidon SM Executor) and an internal Poseidon PIL (program) which is a set of verification rules, written in the PIL language. The Poseidon SM Executor is written in two versions; Javascript and C/C++.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/07-Poseidon-sm/#the-poseidon-hash-function","title":"The Poseidon Hash Function","text":"<p>The Poseidon Hash, as used in the zkEVM, is defined over the Goldilocks-like field \\(\\mathbb{F}_p\\) where the prime \\(p = 2^{64} - 2^{32} + 1\\). It operates on \\(\\mathtt{64}\\)-bit field elements. The state width of the Poseidon permutation is \\(8\\) field elements, which amounts to \\(\\mathtt{512}\\) bits, while the capacity is \\(\\mathtt{4}\\) field elements.</p> <p>As a sponge construction, \\(\\text{POSEIDON}^{\\pi}\\) has internal states each of  \\(t\\)  cells (words), and iterates execution of the round function for as many times as it is regarded safe against round-dependent attacks such as Differential or Linear Cryptanalytic attacks. </p> <p>A typical round function consists of three operations; an addition of a round-key (\\(ARC\\)), a non-linear function \\(S\\)  (i.e., a substitution box or S-box), and a linear function \\(L\\) which is often an affine transformation (in particular, an MDS matrix \\(M\\)). </p> <p>Some rounds are partial rounds because they use only one S-box instead of the full number of  \\(t\\)  S-boxes. For the specific construction given in [GKR+20], a full round means the round function utilizes  \\(t\\)  instances of the same S-box. For security purposes against certain cryptanalytic attacks, outer rounds are full rounds, while the inner rounds are partial rounds. </p> <p>Denote the number of rounds by  \\(\\mathtt{R = R_F + R_P}\\)  where  \\(\\mathtt{R_F}\\)  is the number of full rounds and  \\(\\mathtt{R_P}\\)  is the number of partial rounds. Also, let  \\(\\mathbf{M}(\\cdot)\\)  denote the linear diffusion layer.</p> <p>Figure 1 below, depicts a HADES-based \\(\\text{POSEIDON}^{\\pi}\\) permutation.</p> <p></p>  Figure 1 : Simplified HADES-based POSEIDON permutation  <p>The Poseidon S-box, \\(S\\), is defined over a finite field as the power map  $ x \\mapsto x^d $, where \\(d \\geq 3\\)  is chosen as the smallest integer that guarantees invertibility and provides non-linearity.</p> <p>The commonly used S-box is the cubic, \\(f(x) = x^3\\). However, for fields where the cubic is not bijective, either  \\(f(x) = x^5\\)  or  \\(f(x) = x^{-1}\\)  is used as an alternative permutation.</p> <p>The Poseidon S-box layer used in the zkProver is specified as $$ f(x) = x^7. $$ Maximum distance separable (MDS) matrices are used as the Linear Diffusion Layer in Poseidon, where an MDS matrix $\\mathbf{M} \\in \\mathbb{F}^{t \\times t} $ is characterised by the following known result; $$ \\text{A matrix } \\mathbf{M} \\text{ is an MDS matrix } \\text{ iff } \\text{ every submatrix of } \\mathbf{M} \\text{ is non-singular. } $$ There are various ways to construct an MDS matrix. Some are secure while some are not so secure. However, algorithms exist that can be used to test whether a given MDS is secure against certain cryptanalytic attacks, such as Differential Cryptanalysis Attacks.</p> <p>The number of full and partial rounds of the permutation, guaranteed to make Poseidon secure, is specified as follows,  $$ \\mathtt{R_F = 8 \\text{ (number of full rounds) }, \\quad R_P = 22 \\text{ (number of partial rounds)}} $$</p> <p>Only one squeezing iteration is enforced, with an output of the first \\(4\\) field elements of the state (which consists of approximately \\(256\\)-bits, but no more than that). </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/07-Poseidon-sm/#description-of-the-poseidon-sm","title":"Description Of The Poseidon SM","text":"<p>Poseidon SM is the most straight forward once one understands the internal mechanism of the original Poseidon hash function. The hash function's permutation process translates readily to the Poseidon SM states. </p> <p>The Poseidon State Machine carries out Poseidon Actions in accordance with instructions from the Main SM Executor and requests from the Storage SM. That is, it computes hashes of messages sent from any of the two SMs, and also checks if the hashes were correctly computed.</p> <p>The zkProver uses the Goldilocks-like Poseidon defined over the field  \\(\\mathbb{F}_p\\), where  \\(p = 2^{64} - 2^{32} + 1\\).</p> <p>The states of the Poseidon SM coincide with the twelve (12) internal states of the \\(\\text{POSEIDON}^{\\pi}\\) permutation function. These are;  <code>in0</code>, <code>in1</code>, ... , <code>in7</code>, <code>hashType</code>, <code>cap1</code>, <code>cap2</code> and <code>cap3</code>. </p> <p></p>  Figure 2 : Simplified Diagram of the POSEIDON HASH  <p>The parameters of the \\(\\text{POSEIDON}^{\\pi}\\) permutation are as follows; </p> <ul> <li>The number of internal states (or cells/words) is  \\(t = 12\\). That is, twelve  \\(\\mathbb{F}_p\\)  elements consisting of; the eight (8) input words <code>in0</code>, <code>in1</code>, ... , <code>in7</code>; the hash type <code>hashType</code>; and three capacity cells.</li> <li>Capacity cells, denoted in the code as  <code>cap1</code>, <code>cap2</code> and <code>cap3</code>. That is,  \\(c = 3\\).</li> <li>S-box used is the mapping,  \\(f(x) = x^7\\).</li> <li>It has 8 full rounds. A full round means applying the same S-box on each of the 12 words.</li> <li>It has 22 partial rounds. A partial round means the S-box is applied only to the first input word, <code>in0</code>.</li> <li>The MDS matrix used is a \\((t\\times t)\\) Cauchy matrix, with \\(2t + 1 \\leq p\\)  and where each \\((i,j)\\)-entry is of the form \\(\\dfrac{1}{x_i + y_i}\\), where the two pairwise distinct sets \\(\\{ x_i \\}\\) and \\(\\{ y_i \\}\\) are defined as <code>MCIRC</code> and <code>MDIAG</code>, respectively. The linear diffusion layer is defined in lines 104 to 116 of the code sm_poseidon.js, and it is explicitly used in lines 99 to 110 of poseidon.pil code.</li> </ul> <p>\\(\\text{POSEIDON}^{\\pi}\\) runs 30 rounds, 3 times. Adding up to a total of 90 rounds. It outputs four (4) hash values; <code>hash0</code>, <code>hash1</code>, <code>hash2</code> and <code>hash3</code>.</p> <p>The Poseidon MDS matrix is constructed as shown below.</p> <pre><code>// definition of the MDS in sm_poseidong.js\n\n\nconst MCIRC = [17n, 15n, 41n, 16n, 2n, 28n, 13n, 13n, 39n, 18n, 34n, 20n];\nconst MDIAG = [8n, 0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n, 0n];\n\nconst M = [];\nfor (let i = 0; i &lt; 12; i++) {\n    M[i] = [];\n    for (let j = 0; j &lt; 12; j++) {\n        M[i][j] = F.e(MCIRC[(-i + j + 12) % 12]);\n        if (i === j) M[i][j] = F.add(M[i][j], MDIAG[i]);\n    }\n}\n\n</code></pre>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/07-Poseidon-sm/#in-a-nutshell","title":"In A Nutshell","text":"<p>Firstly, the Poseidon SM Executor translates the Poseidon Actions into the PIL language.</p> <p>Secondly, it executes the Poseidon Actions (i.e., hashing). </p> <p>And thirdly, it uses the Poseidon PIL (program) poseidon.pil, to check execution correctness of the Poseidon Actions.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/07-Poseidon-sm/#translation-to-pil","title":"Translation To PIL","text":"<p>It builds the constant polynomials, which are generated once-off at the beginning. These are; </p> <ul> <li>Three (3) arrays of Add-Round Constants (ARCs), each an array of size 12, denoted by  <code>C[12]</code>. </li> <li>The <code>LAST</code> constant polynomial, can either be <code>0</code> or <code>1</code>. It is used for resetting register values to <code>0</code>.</li> <li>The <code>LATCH</code> constant polynomial, can either be <code>0</code> or <code>1</code>. </li> <li>The <code>LASTBLOCK</code> constant polynomial, can either be <code>0</code> or <code>1</code>. It is used for resetting hash values.</li> <li>The <code>PARTIAL</code> constant polynomial, can either be <code>0</code> or <code>1</code>. It is used to set a round to either <code>PARTIAL</code> or <code>FULL</code> round.</li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/07-Poseidon-sm/#execution-of-poseidon-actions","title":"Execution of Poseidon Actions","text":"<p>The main part of the Poseidon SM Executor is found in the <code>lines 138 to 256</code> of sm_poseidong.js. This is where it executes Poseidon Actions. </p> <p>It computes all the committed polynomials;</p> <ol> <li>The input words;  <code>in0</code>, <code>in1</code>, ... , <code>in7</code>.  </li> <li>The type of the hash used and the values representing the capacity ;  <code>hashType</code>, <code>cap1</code>, <code>cap2</code> and <code>cap3</code>.</li> <li>The four hash values;  <code>hash0</code>, <code>hash1</code>, <code>hash2</code> and <code>hash3</code>, which are the outputs of the \\(\\text{POSEIDON}^{\\pi}\\) permutation.</li> </ol> <p>It also exports all these committed polynomials for verification (checking the hash values  <code>hash0</code>, <code>hash1</code>, <code>hash2</code> and <code>hash3</code>), carried out by the poseidon.pil (program).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/07-Poseidon-sm/#the-poseidon-pil-program","title":"The Poseidon PIL Program","text":"<p>The inputs to the Poseidon PIL (program) are; the constant polynomials and all the committed polynomials. </p> <p>Here, the input vector  (<code>in0</code>, <code>in1</code>, ... , <code>in7</code>, <code>hashType</code>, <code>cap1</code>, <code>cap2</code>, <code>cap3</code>)  is taken through the various stages of the  \\(\\text{POSEIDON}^{\\pi}\\) permutation;</p> <ol> <li>The round constants are added to each element of this input vector.</li> <li>The S-box function is applied to each element (i.e., to the result of the addition of the round constant), where the first four (4) rounds and the last four (4) of the 30 rounds are full rounds, while the other 22 rounds are partial rounds.</li> <li>The MDS matrix is applied to the intermediate vector, whose elements are the results of Step 2 above. </li> <li>The final results are checked against the hash values given as input polynomial commitments; <code>hash0</code>, <code>hash1</code>, <code>hash2</code> and <code>hash3</code>.</li> </ol> <p>The Polygon zkEVM Repository is here: Polygon zkEVM Repo</p> <p>Poseidon SM Executor: sm_poseidong.js</p> <p>Poseidon SM PIL:  poseidong.pil </p> <p>Test Vectors: poseidong_test.js</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/Introduction/","title":"The Hashing State Machine","text":""},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/Introduction/#sponge-construction","title":"Sponge Construction","text":"<p>The sponge construction is a simple iterated construction for building a function </p> \\[ F: \\mathbb{Z}^* \\to \\mathbb{Z}^l \\] <p>with variable-length input and arbitrary output length based on a fixed-length permutation $$ f: \\mathbb{Z}^b \\to \\mathbb{Z}^b $$</p> <p>operating on a fixed number \\(b\\) of bits. Here \\(b\\) is called the width. The array of \\(b\\) bits that \\(f\\) keeps transforming is called the state. The state array is split in two chunks of \\(r\\) and \\(c\\) bits respectively. We call \\(r\\) the bitrate (or rate) and \\(c\\) the capacity. We will understand later on the motivation for this splitting. </p> <p>Let us describe how the sponge construction works:</p> <ul> <li> <p>(Init Phase) First of all, the input string is padded with a reversible padding rule, in order to achieve a length divisible by \\(r\\). Subsequently, it is cut into blocks of \\(r\\) bits. We also initialize the \\(b\\) bits of the state to zero. </p> </li> <li> <p>(Absorbing Phase) In this phase, the \\(r\\)-bit input blocks are XORed into the first \\(r\\) bits of the state, interleaved with applications of the function \\(f\\). We proceed until processing all blocks of \\(r\\)-bits. Observe that the last \\(c\\) bits corresponding to the capacity value does not absorb any input from the outside. </p> </li> <li> <p>(Squeezing Phase) In this phase, the first \\(r\\) bits of the state are returned as output blocks, interleaved with applications of the function \\(f\\). The number of output blocks is chosen at will by the user. Observe that the last \\(c\\) bits corresponding to the capacity value are never output during this phase. Actually, if the output exceeds the specified length, we will just truncate it in order to fit. </p> </li> </ul> <p>We depict an schema of the sponge construction in the Figure 1 below:</p> <p></p>  Figure 1: Sponge Function Construction  <p>The elements that completely describe a single instance of a sponge construction are: the fixed-length permutation \\(f\\), the padding rule pad and the rate value \\(r\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/Introduction/#zkevm-specific-constructions","title":"zkEVM Specific Constructions","text":"<p>The zkEVM uses two different hash functions. The main reason to do so is because the Storage of the EVM uses KECCAK-256 as the hash function used for constructing the corresponding Merkle Trees. However, for zkEVM internal hashes, a Poseidon hash will be used, in order to reduce the proving complexity. In this section, the specific instances of both hash functions will be defined:</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/Introduction/#keccak-256","title":"KECCAK-256","text":"<p>The EVM makes use of KECCAK-256 hash function, which is constructed using KECCAK\\([512]\\) sponge construction. Let us, therefore, define the KECCAK\\([c]\\) sponge construction. This sponge operates with a width of \\(1600\\) bits and a rate of \\(1600 - c\\). In the case of KECCAK\\([512]\\), the rate chunk is composed of \\(1088\\) bits (or equivalently, \\(136\\) bytes) and the capacity chunk has \\(512\\) bits (or equivalently, \\(64\\) bytes). The permutation used in KECCAK\\([c]\\) is KECCAK-\\(p[1600, 24]\\) (See NIST SHA-3 Standard). The last ingredient we need to define in order to completely specify the hash function is the padding rule. In KECCAK\\([c]\\), the padding pad10*1 is used. If we define \\(j = (-m-2) \\mod{r}\\), where \\(m\\) is the length of the input in bits, then the padding we have to append to the original input message is </p> \\[ P = 1 \\mid\\mid 0^j \\mid\\mid 1. \\] <p>Thus, given an input bit string \\(M\\) and a output length \\(d\\), KECCAK\\([c](M, d)\\) outputs a \\(d\\) bit string following the previous sponge construction description. </p> <p>It should be noted that this construction does not follow the FIPS-202 based standard (a.k.a SHA-3). According to the NIST specification,the SHA3 padding changed to</p> \\[ \\text{SHA3-256}(M) = \\text{KECCAK}[512](M \\mid\\mid 01, 256). \\] <p>The difference is the additional \\(01\\) bits appended to the original message, which were not present in the orignal KECCAK specification. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Hashing/Introduction/#poseidon","title":"Poseidon","text":"<p>Poseidon (See Poseidon Paper) is a hash function designed to minimize prover and verifier complexities when zero-knowledge proofs are generated and validated. The previously defined KECCAK-256 cryptographic hash require large circuits as they are not tailored to finite fields used in ZK proof systems (actually, KECCAK-256 works well in binary fields, and we will see later on that this fact introduces a lot of complexity in the constrain design). For this reason, zkEVM uses Poseidon hash as the main internal hash function. </p> <p>More concretely, we will now specify the specific instance of Poseidon that zkEVM uses. We will work over the field \\(\\mathbb{F}_p\\) where \\(p = 2^{64} - 2^{32} + 1\\). The state width of the Poseidon permutation is of \\(8\\) field elements (observe that we are changing the paradigm, working with whole field elements instead of working bit-wise) meanwhile we will work with a capacity of \\(4\\)-field elements. The Poseidon S-box layer that we will use is the \\(7\\)-power S-Box, i.e.</p> \\[ SB(x) = x^7, \\] <p>The Poseidon instance also requires to specify the number of full and partial rounds of the permutation. In our case, we will use </p> \\[ R_F = 8 \\text{ (number of full rounds) }, \\quad R_P = 22 \\text{ (number of partial rounds)} \\] <p>Only one squeezing iteration will be effectuated, with an output of the first \\(4\\) field elements of the state (which consists of approximately \\(256\\)-bits, but no more than that). </p> <p>The Round Constants and the MDS matrix are completely specified using the previous parameters. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/","title":"Memory State Machine","text":"<p>As a secondary state machine, the Memory State Machine has the executor part (the Memory SM Executor) and an internal Memory PIL (program) which is a set of verification rules, written in the PIL language. The Memory SM Executor is written in two versions; Javascript and C/C++.</p> <p>The Polygon Hermez Repo is here  https://github.com/0xPolygonHermez</p> <p>Memory SM Executor: sm_mem.js</p> <p>Memory SM PIL: mem.pil </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#evm-memory","title":"EVM Memory","text":"<p>The memory of the EVM (Ethereum Virtual Machine) is a volatile read-write memory, and it is used to store temporary data during the execution of transactions of smart contract functions. That is, data in memory is populated during transaction's execution but it does not persist between transactions. The memory is an array of \\(256\\)-bit (\\(32\\) bytes) words that can be accessed through addresses at byte level, that is to say, each byte in the memory has a different address.</p> <p>Memory has addresses of \\(32\\) bits, and initially, all memory locations are composed by bytes set to zero.</p> <p>Now, let's see the layout in memory of the following two words \\(\\texttt{0xc417...81a7}\\) and \\(\\texttt{0x88d1...b723}\\). Table 1 displays this layout.</p> <p> \\(\\mathbf{ADDRESS}\\) \\(\\mathbf{BYTE}\\) \\(\\mathtt{0}\\) \\(\\mathtt{0xc4}\\) \\(\\mathtt{1}\\) \\(\\mathtt{0x17}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{30}\\) \\(\\mathtt{0x81}\\) \\(\\mathtt{31}\\) \\(\\mathtt{0xa7}\\) \\(\\mathtt{32}\\) \\(\\mathtt{0x88}\\) \\(\\mathtt{33}\\) \\(\\mathtt{0xd1}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{62}\\) \\(\\mathtt{0xb7}\\) \\(\\mathtt{63}\\) \\(\\mathtt{0x23}\\) <p></p>  Table 1: Layout in memory of 0xc417...81a7 and 0x88d1...b723.  <p>Observe that each word has 32 bytes and that the words are stored in Big-Endian form. i.e. The most significant bytes are set in the lower addresses. The EVM provides three opcodes to interact with the memory area. There is an opcode to read, and an opcode to write 32-byte words providing an offset:</p> <ul> <li>\\(\\texttt{MLOAD}\\): It receives an offset and returns the 32 bytes in memory starting at that offset.</li> <li>\\(\\texttt{MSTORE}\\): It receives an offset and saves 32 bytes from the offset address of the memory.</li> </ul> <p>Considering our previous memory contents, if we perform an \\(\\texttt{MLOAD}\\) with an offset of \\(\\texttt{1}\\), we would obtain the following word: \\(\\texttt{0x17...a788}\\). On the other hand, if we do an \\(\\texttt{MSTORE}\\) with an offset of \\(\\texttt{1}\\) with the word \\(\\texttt{0x74f0...ce92}\\), we would modify the content of the memory as shown in Table 2.</p> <p> \\(\\mathbf{ADDRESS}\\) \\(\\mathbf{BYTE}\\) \\(\\mathtt{0}\\) \\(\\mathtt{0xc4}\\) \\(\\mathtt{1}\\) \\(\\mathtt{\\textbf{0x74}}\\) \\(\\mathtt{2}\\) \\(\\mathtt{\\textbf{0xf0}}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{30}\\) \\(\\mathtt{\\textbf{0xce}}\\) \\(\\mathtt{31}\\) \\(\\mathtt{\\textbf{0x92}}\\) \\(\\mathtt{33}\\) \\(\\mathtt{0xd1}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{\\vdots}\\) \\(\\mathtt{62}\\) \\(\\mathtt{0xb7}\\) \\(\\mathtt{63}\\) \\(\\mathtt{0x23}\\) <p></p>  Table 2: Layout in memory after the introduction of 0x74f0...ce92.  <p>When the offset is not a multiple of 32 (or 0x20), as in the previous example, we have to use bytes from two different words when doing \\(\\texttt{MLOAD}\\) or \\(\\texttt{MSTORE}\\).</p> <p>Finally, the EVM provides a write memory operation that just writes a byte:</p> <ul> <li>\\(\\texttt{MSTOREE}\\): It receives an offset and saves one byte on that address of the memory.</li> </ul> <p>Notice that \\(\\texttt{MSTOREE}\\) always uses only one word.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#layout","title":"Layout","text":"<p>The Memory SM is in charge of proving the memory operations in the execution trace. As mentioned, read and write operations use addresses at byte level in the EVM. However, doing the proofs byte-by-byte would consume many values in the trace of this state machine. Instead, in this machine, we operate addressing words (32 bytes). For example, if we have the memory layout from Table 1, then we would have the memory layout of Table 3 with addresses that point to 32-byte words.</p> <p> \\(\\textbf{ADDRESS}\\) \\(\\textbf{32-BYTE WORD}\\) \\(\\mathtt{0}\\) \\(\\mathtt{0xc417...81a7}\\) \\(\\mathtt{1}\\) \\(\\mathtt{0x88d1...b723}\\) <p></p>  Table 3: Layout in the memory state machine.  <p>The Memory SM uses this latter layout, the 32-byte word access, to check reads and writes. However, as previously mentioned, the EVM can read and write with offsets at a byte level. As a result, we will need to check the relationship between byte access and 32-byte word access. For these checks, we have another state machine called Memory Align SM.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#design","title":"Design","text":"<p>As with any state machine, the Memory SM has an executor to compute the trace that proves the correctness of memory reads and writes and a PIL description that enforces that the trace is correct.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#execution-trace-design","title":"Execution Trace Design","text":"<p>The Memory SM defines the design of the trace and the PIL description that checks that memory reads and writes aligned to 32-byte words are correct. The addresses, denoted as \\(\\texttt{addr}\\), are represented through \\(32\\) bits (\\(4\\) bytes) and point to 32-byte words. The value of words stored in memory, denoted as \\(\\texttt{val}\\), are represented through \\(8\\) registers \\(\\texttt{val[0..7]}\\) of \\(4\\) bytes each, making a total of \\(32\\) bytes (\\(256\\) bits).</p> <p>Table 4 shows an example with all the memory operations present at an execution trace of the Main SM.</p> <p> \\(\\texttt{step}\\) \\(\\texttt{mOp}\\) \\(\\texttt{mWr}\\) \\(\\texttt{addr}\\) \\(\\texttt{val[7]}\\) \\(\\texttt{val[6]}\\) \\(\\dots\\) \\(\\texttt{val[0]}\\) 11 1 1 6 2121 3782 \\(\\dots\\) 5432 31 1 1 4 3231 9326 \\(\\dots\\) 8012 55 1 0 6 2121 3782 \\(\\dots\\) 5432 63 1 1 6 4874 1725 \\(\\dots\\) 2074 72 1 0 4 3231 9326 \\(\\dots\\) 8012 89 1 1 2 9167 5291 \\(\\dots\\) 6001 <p></p>  Table 4: Memory Operations and an Execution Trace of the Main SM.  <p>The \\(\\texttt{step}\\) is the execution step number at the Main SM and in this case, we are showing only the steps that are performing a memory operation. The instruction to execute a memory operation is indicated by the \\(\\texttt{mOp}\\) selector. The \\(\\texttt{mWr}\\) is also a selector that shows whether the memory operation is a read or a write. In the previous trace, we can observe that the first memory operation is performed at step 11 and it is the write of the sixth 32-byte word. The eight registers \\(\\texttt{val[0..7]}\\) provide the bytes to be written in that word.</p> <p>It is worth to mention that for a specific word address, the first operation is always a write because it makes no sense to read a position that has not been previously written. Then, in this word address there can be a sequence of reads and writes. In the previous trace, we can observe that for the sixth word, there is a write at step 11, then a read at step \\(55\\) and finally another write at step \\(63\\).</p> <p> \\(\\texttt{step}\\) \\(\\texttt{addr}\\) \\(\\texttt{mOp}\\) \\(\\texttt{mWr}\\) \\(\\texttt{val[7]}\\) \\(\\texttt{val[6]}\\) \\(\\dots\\) \\(\\texttt{val[0]}\\) 89 2 1 1 9167 5291 \\(\\dots\\) 6001 31 4 1 1 3231 9326 \\(\\dots\\) 8012 72 4 1 0 3231 9326 \\(\\dots\\) 8012 11 6 1 1 2121 3782 \\(\\dots\\) 5432 55 6 1 0 2121 3782 \\(\\dots\\) 5432 63 6 1 1 4674 1725 \\(\\dots\\) 2074 <p></p>  Table 5: Corresponding Memory SM Execution Trace.  <p>The trace of the Memory SM must check that the writes are done according to their step and that reads provide the correct words according also to their step.</p> <p>In order to implement these checks, the execution trace of the Memory SM sorts all the memory operations; firstly by \\(\\texttt{addr}\\), and secondly by \\(\\texttt{step}\\), as shown in Table 5. This ordering is referred to as the topology of the Memory SM.</p> <p>Finally, we will need to add a few more columns to ensure that the memory execution trace goes exactly across all the ordered writes and reads of the Main SM, with writes storing the provided values and with reads not changing the previous value of the word.</p> <p>In particular, we add three more columns. One these columns is called \\(\\texttt{INCS}\\) and it is used to provide an order for the values of the columns. Another column called \\(\\texttt{lastAccess}\\) is used to enable an address change when all the memory operations for this address have appeared at the trace. The last column is called \\(\\texttt{ISNOTLAST}\\) and it is used to make the checks pass when there are no more memory accesses.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#list-of-columns","title":"List of Columns","text":"<p>The following columns (polynomials) are used by the Memory SM. We divide them between preprocessed and committed polynomials.</p> <p>Preprocessed:</p> <ul> <li>\\(\\texttt{INCS}\\): Counter that goes from \\(1\\) up to \\(N\\), where \\(N\\) is the number of rows in the computational trace,</li> </ul> \\[ \\texttt{INCS} = (\\underbrace{1, 2, 3, \\dots,N-1, N}_{N}) \\] <p>\u200b It is used to do a range check to prove the incremental order of other columns.</p> <ul> <li>\\(\\texttt{ISNOTLAST}\\): Selector that is \\(1\\) in every row except in the \\(N\\)-th row, in which its value is \\(0\\),</li> </ul> \\[ \\texttt{ISNOTLAST} = (\\underbrace{1, 1, 1, \\dots,1, 0}_{N}) \\] <p>Committed:</p> <ul> <li>\\(\\texttt{step}\\): Position in which the memory operation was called in the Main SM.</li> <li>\\(\\texttt{mOp}\\): Selector indicating whether it is being performed a memory operation or not.</li> <li>\\(\\texttt{mWr}\\): Selector that is \\(1\\) if the memory operation is a write and \\(0\\) if it is a read operation.</li> <li>\\(\\texttt{addr}\\): A \\(4\\)-byte (or \\(32\\) bit) integer indicating the address of a 32-byte word.</li> <li>\\(\\texttt{lastAccess}\\): Selector indicating whether it has been reached the last memory access for a particular address or not.</li> <li>\\(\\texttt{val[0..7]}\\): Vector containing \\(8\\) \\(4\\)-byte integer indicating the \\(256\\)-bit value associated to a given address.</li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#complete-example","title":"Complete Example","text":"<p>Table 6 shows the complete Memory SM trace for our example in which the computational trace size \\(N\\) is \\(2^3\\).</p> <p>There are various important details to remark from the point in which all memory accesses have been completed but the \\(2^3\\)-th row has not been reached yet:</p> <ul> <li>\\(\\texttt{mOp}\\) and \\(\\texttt{mWr}\\) are set to \\(0\\) until the last row.</li> <li>\\(\\texttt{addr}\\) is incremented by \\(1\\) to keep the incremental order of the addresses. This value is maintained until the last row.</li> <li>\\(\\texttt{lastAccess}\\) is also set to \\(0\\) except in the very last row, where it is set back to \\(1\\) to create the ciclycity behavior.</li> <li>\\(\\texttt{step}\\) is incremented by \\(1\\) in each row so that this column fulfills the constraints describing this state machine.</li> <li>\\(\\textbf{Remark}\\). Notice that \\(\\texttt{step}\\) can take values beyond \\(N\\) and that the value of \\(\\texttt{step}\\) after the row of the last address can coincide with a previous value. As we will show in the next section, where we describe the constraints, these facts do not cause any issue.</li> <li>\\(\\texttt{val[0..7]}\\) are all set to \\(0\\) until the last row.</li> </ul> <p></p>  Table 6: Complete Memory SM execution trace for our example."},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#constraints","title":"Constraints","text":""},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#topology","title":"Topology","text":"<p>Let's start with the set of constraints regarding the topology of the state machine.</p> \\[ \\begin{align} &amp;\\texttt{lastAccess} \\cdot (\\texttt{lastAccess} - 1) = 0,  \\label{eq:lastAccessBin}\\tag{1}\\\\ &amp;(1 - \\texttt{lastAccess}) \\cdot (\\texttt{addr}' - \\texttt{addr}) = 0, \\label{eqaddresSame}\\tag{2}\\\\ &amp;\\texttt{ISNOTLAST}~\\left \\{ \\texttt{lastAccess} \\cdot \\left( \\texttt{addr}' - \\texttt{addr} - (\\texttt{step}' - \\texttt{step}) \\right) + (\\texttt{step}' - \\texttt{step}) \\right \\} \\subset \\texttt{INCS}. \\label{eq:topology}\\tag{3} \\end{align} \\] <p>Equations (1) and (2) are straightforward. Equation (1) asserts that \\(\\texttt{lastAccess}\\) is a selector (i.e., a column whose values lie in the set \\(\\{0,1\\}\\)), while Equation (2) confirms that \\(\\texttt{addr}\\) does not change until it is accessed for the last time. Note that Equation (2) implies that addresses are processed one-by-one in the Memory SM, but it does not guarantees that they are ordered incrementally.</p> <p>Equation (3) is a little bit more tricky. Let's do a case analysis on it.</p> <p>The curly braces notation in Equation (3) means that the inclusion is only checked at values such that the corresponding selector \\(\\texttt{ISNOTLAST}\\) is equal to \\(1\\).</p> <p>Then, depending on value of the \\(\\texttt{lastAccess}\\) selector we have two cases:</p> <ul> <li>If \\(\\texttt{lastAccess} = 0\\):</li> </ul> \\[ \\texttt{step}' - \\texttt{step} \\subset \\texttt{INCS}. \\] <ul> <li>Else:</li> </ul> \\[ \\texttt{addr}' - \\texttt{addr} \\subset \\texttt{INCS}. \\] <p>In words, whenever a transition do not change the address in question, verify that \\(\\texttt{step}' &gt; \\texttt{step}\\); otherwise verify that \\(\\texttt{addr}' &gt; \\texttt{addr}\\). Therefore, Equation (3) ensures that both \\(\\texttt{step}\\) and \\(\\texttt{addr}\\) are ordered incrementally (first by \\(\\texttt{addr}\\) and then by \\(\\texttt{step}\\)). A combination of Eqs. (2) and (3) gives the desired topology.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#operation-selectors","title":"Operation Selectors","text":"<p>Let's continue with the operation selectors: \\(\\texttt{mOp}\\) and \\(\\texttt{mWr}\\).</p> \\[ \\begin{align} &amp;\\texttt{mOp} \\cdot (\\texttt{mOp} - 1) = 0, \\tag{4}\\\\ &amp;\\texttt{mWr} \\cdot (\\texttt{mWr} - 1) = 0, \\tag{5}\\\\ &amp;\\left( 1 - \\texttt{mOp} \\right) \\cdot \\texttt{mWr} = 0. \\tag{6} \\end{align} \\] <p>Eqs. (4) and (5) ensure that \\(\\texttt{mOp}\\) and \\(\\texttt{mWr}\\) are, effectively, selectors. Eq. (6) is imposing a restriction to \\(\\texttt{mWr}\\) (and binding it with \\(\\texttt{mOp}\\)) in the following sense: \\(\\texttt{mWr}\\) can be set to \\(1\\) only if \\(\\texttt{mOp}\\) is also set to \\(1\\). Similarly, if \\(\\texttt{mOp}\\) is set to \\(0\\), then \\(\\texttt{mWr}\\) should be set to \\(0\\) as well. This restriction comes naturally from the definition of these selectors.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#updating-the-value","title":"Updating the Value","text":"<p>Finally, we explain the constraints that deal with the value columns \\(\\texttt{val[0..7]}\\).</p> \\[ \\begin{align} &amp;\\left( 1 - \\texttt{mOp}' \\cdot \\texttt{mWr}' \\right) \\cdot \\left(1 - \\texttt{lastAccess}\\right) \\cdot (\\texttt{val[0..7]}' - \\texttt{val[0..7]}) = 0, \\tag{7}\\\\ &amp;\\left( 1 - \\texttt{mOp}' \\cdot \\texttt{mWr}' \\right) \\cdot \\texttt{lastAccess} \\cdot \\texttt{val[0..7]}' = 0. \\tag{8} \\end{align} \\] <p>We analyze both Eqs. (7) and (8) at the same time. Notice that we simply discuss the feasible cases:</p> <ul> <li>\\(\\textbf{Maintain the same value when reading:}\\) If \\(\\texttt{mWr}' = 0\\) and \\(\\texttt{lastAccess} = 0\\), then it should be the case that \\(\\texttt{val[0..7]}' = \\texttt{val[0..7]}\\), since this means that we will perform a read in the next step. Eq. (7) ensures this case.</li> <li>\\(\\textbf{Filling the value with zeros when done:}\\) If \\(\\texttt{mOp}' = 1\\), \\(\\texttt{mWr}' = 0\\) and \\(\\texttt{lastAccess} = 1\\), then it should be the case that \\(\\texttt{val[0..7]}' = 0\\), i.e., the register \\(\\texttt{val[0..7]}\\) is set to \\(0\\) in the forthcoming steps.</li> </ul> <p>More cases are not possible because for an address we always start with a write operation which limits the behavior of these constraints to these cases. For example, it cannot happen that \\(\\texttt{lastAccess = 1}\\) and some of \\(\\texttt{mOp}'\\) or \\(\\texttt{mWr}'\\) is 0; because the first operation that is always performed over a memory address is a write.</p> <p>However, notice that to be able reset \\(\\texttt{addr}\\) to its state in the first row (where it is the case that \\(\\texttt{addr}' &lt; \\texttt{addr}\\)) it should be the case that \\(\\texttt{lastAccess} = 1\\) in the last row of the computational case. If \\(\\texttt{lastAccess}\\) would have not been set to \\(1\\), then Eq. (2) would not be satisfied.</p> <p>We obtain this condition by adding the following constraint:</p> \\[ \\left(1 - \\texttt{lastAccess}\\right) \\cdot \\left(1 - \\texttt{ISNOTLAST}\\right) = 0. \\]"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory/Memory/#connection-with-the-main-sm","title":"Connection with the Main SM","text":"<p>The last constraint that we need to add is to relate the execution trace of the Main SM with the execution trace of the Memory SM.</p> <p>The constraint has to check that all the rows in the trace of the Main SM that make memory operations (i.e. rows where \\(\\texttt{mOp} == 1\\)) are a permutation (any permutation) of the rows of the Memory SM where \\(\\texttt{mOp} == 1\\).</p> <p>The key point is that if both vectors would not be a permutation of each other, then that would mean that the Main SM is performing an incorrect memory action.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory-Align/Memory-Align/","title":"Memory Align SM","text":""},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory-Align/Memory-Align/#introduction","title":"Introduction","text":"<p>As a secondary state machine, the Memory Align State Machine has the executor part (the Memory Align SM Executor) and an internal Memory Align PIL (program) which is a set of verification rules, written in the PIL language. The Memory Align SM Executor is written in two versions; Javascript and C/C++.</p> <p>The Polygon Hermez Repo is here  https://github.com/0xPolygonHermez</p> <p>Memory Align SM Executor: sm_mem_align.js</p> <p>Memory Align SM PIL: mem_align.pil </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Memory-Align/Memory-Align/#purpose-of-the-state-machine","title":"Purpose of the State Machine","text":"<p>The Memory SM checks memory reads and writes using a 32-byte word access, while the EVM can read and write 32-byte words with offsets at a byte level.</p> <p>Table 1 shows an example of possible byte-addressed and 32-byte-addressed memory layouts for the same content (three words).</p>  Table 1: Sample memory layouts for byte and 32-byte access. \\[ \\begin{array}{|c|c|} \\hline \\mathbf{ADDRESS} &amp;\\mathbf{BYTE} \\\\ \\hline \\mathtt{0} &amp;\\mathtt{0xc4} \\\\ \\mathtt{1} &amp;\\mathtt{0x17} \\\\ \\mathtt{\\vdots} &amp;\\mathtt{\\vdots} \\\\ \\mathtt{30} &amp;\\mathtt{0x81} \\\\ \\mathtt{31} &amp;\\mathtt{0xa7} \\\\ \\mathtt{32} &amp;\\mathtt{0x88} \\\\ \\mathtt{33} &amp;\\mathtt{0xd1} \\\\ \\mathtt{\\vdots} &amp;\\mathtt{\\vdots} \\\\ \\mathtt{62} &amp;\\mathtt{0xb7} \\\\ \\mathtt{63} &amp;\\mathtt{0x23} \\\\ \\hline \\end{array} \\] \\[ \\begin{array}{|c|c|} \\hline \\textbf{ADDRESS} &amp; \\textbf{32-BYTE WORD} \\\\ \\hline \\mathtt{0} &amp;\\mathtt{0xc417...81a7} \\\\ \\mathtt{1} &amp;\\mathtt{0x88d1...b723} \\\\ \\hline \\end{array} \\] <p>The relationship between the 32-byte word addressable layout and the byte addressable layout is called \"memory alignment\" and the Memory Align SM is the state machine that checks the correctness of this relationship.</p> <p>In more detail, we have to check the following memory operations:</p> <ul> <li>\\(\\mathtt{MLOAD}\\): It receives an offset and returns the 32 bytes in memory starting at that offset.</li> <li>\\(\\mathtt{MSTORE}\\): It receives an offset and saves 32 bytes from the offset address of the memory.</li> <li>\\(\\mathtt{MSTORE8}\\): It receives an offset and saves one byte on that address of the memory.</li> </ul> <p>Notice that, in the general case, \\(\\mathtt{MLOAD}\\) requires reading bytes of two different words.</p> <p>Considering that the content of the memory is the one shown in Table 1, since the EVM is addressed at a byte level, if we want to check a read from the EVM of a word starting at the address \\(\\mathtt{0x22}\\), the value that we should obtain is the following:</p> \\[ \\mathtt{val} = \\mathtt{0x1f \\cdots b7236e21}. \\] <p>We denote the content of the words affected by an EVM memory read as \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\).</p> <p>In our example, these words are the following:</p> \\[ \\mathtt{m}_0 = \\mathtt{0x} \\mathtt{88d11f} \\cdots \\mathtt{b723}, \\quad \\mathtt{m}_1 = \\mathtt{0x} \\mathtt{6e21ff} \\cdots \\mathtt{54f9}. \\] <p>We define a read block as the string concatenating the content of the words affected by the read: \\(\\mathtt{m}_0 \\mid \\mathtt{m}_1\\).</p> <p>Figure 1 shows the affected read words \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\) that form the affected read block and the read value \\(\\mathtt{val}\\) for a read from the EVM at address \\(\\mathtt{0x22}\\) in our example memory of Table 6.</p> <p></p>  Figure 1: Schema of MLOAD Example  <p>Let us now introduce the flow at the time of validating a read. Suppose that we want to validate that if we perform an \\(\\mathtt{MLOAD}\\) operation at the address \\(\\mathtt{0x22}\\), we get the previous value \\(\\mathtt{0x1f\\dotsb7236e21}\\). At this point, the main state machine will perform several operations. First of all, it will have to query for the values \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\). Henceforth, it must call the Memory SM in order to validate the previous queries.</p> <p>Observe that it is easy to extract the memory positions to query from the address \\(\\mathtt{0x22}\\). In fact, if \\(a\\) is the memory position of the \\(\\mathtt{MLOAD}\\) operation, then \\(\\mathtt{m}_0\\) is always stored at the memory position \\(\\lfloor \\frac{a}{32} \\rfloor\\) and \\(\\mathtt{m}_1\\) is stored at the memory position \\(\\lfloor \\frac{a}{32} \\rfloor + 1\\). In our example, \\(a = \\mathtt{0x22} = 34\\). Hence, \\(\\mathtt{m}_0\\) is stored at the position \\(\\lfloor \\frac{32}{34} \\rfloor = \\mathtt{0x01}\\) and \\(\\mathtt{m}_1\\) is stored at the position \\(\\lfloor \\frac{32}{34} \\rfloor + 1= \\mathtt{0x02}\\).</p> <p>Secondly, we should extract the correct \\(\\mathtt{offset}\\). The \\(\\mathtt{offset}\\) represents an index between \\(0\\) and \\(31\\) indicating the number of bytes we should offset from the starting of \\(\\mathtt{m}_0\\) to correctly place \\(\\mathtt{val}\\) in the block. In our case, the \\(\\mathtt{offset}\\) is \\(2\\). Similarly as before, it is easy to obtain the offset from \\(a\\). In fact, the it is equal to \\(a\\) \\((\\mathrm{mod} \\ 32)\\). Now, the Main SM will check via a Plookup to the Memory Align State Machine that \\val is a correct read given the affected words \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\) and the \\(\\mathtt{offset}\\). That is, we should check that the value \\(\\mathtt{val}\\) can be correctly split into \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\) using the provided \\(\\mathtt{offset}\\).</p> <p>Similarly, \\(\\mathtt{MSTORE}\\) instruction requires, in general, writing bytes in two words.</p> <p>The idea is very similar, but we are provided with a value \\val that we want to write into a specific location of the memory. We will denote by \\(\\mathtt{w}_0\\) and \\(\\mathtt{w}_1\\) the words that arise from \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\) after the corresponding write.</p> <p>Following our previous example, suppose that we want to write</p> \\[ \\mathtt{val} = \\mathtt{0xe201e6\\dots662b} \\] <p>in the address \\(\\mathtt{0x22}\\) of the byte-addressed Ethereum memory. We are using the same \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\) (and since we are writting into the same address as before) and they will transition into (see Figure 2 ):</p> \\[ \\mathtt{w}_0 = \\mathtt{0x88d1}\\color{-red!75}\\mathtt{e201e6\\dots}\\color{black},\\quad \\mathtt{w}_1 = \\mathtt{0x}\\color{-red!75} \\mathtt{662b}\\color{black} \\mathtt{ff\\dots54f9}. \\] <p></p>  Figure 2: Schema of MSTORE example.  <p>Just as before, the main state machine will need to perform several operations. We will be given an address \\(\\mathtt{addr}\\), an offset value \\(\\mathtt{offset}\\) and a value to be wrote \\(\\mathtt{val}\\). Identically as before, the Main SM will be in charge of reading the zkEVM memory to find \\(\\mathtt{m}_0\\) and \\(\\mathtt{m}_1\\) from the given address and offset. Of course, the validity of this query should be performed with a specific Plookup into the Memory SM, just as before.</p> <p>Now, the Main SM can compute \\(\\mathtt{w}_0\\) and \\(\\mathtt{w}_1\\) from all the previous values in a uniquely way. The way of validating that we are providing the correct \\(\\mathtt{w}_0\\) and \\(\\mathtt{w}_1\\) is to perform a Plookup into the Memory Align SM. That is, we will check that the provided values \\(\\mathtt{w}_0\\) and \\(\\mathtt{w}_1\\) are correctly constructed from the provided \\(\\mathtt{val}\\), \\(\\mathtt{m}_0\\), \\(\\mathtt{m}_1\\) and \\(\\mathtt{offset}\\) values.</p> <p>Finally, the last opcode \\(\\mathtt{MSTOREE}\\) works similarly, but it only affects one word \\(\\mathtt{m}_0\\). Moreover, we can only write one byte and hence, only the less significant byte of \\(\\mathtt{val}\\) will be considered into the write. Observe that, in this opcode, \\(\\mathtt{m}_1\\) and \\(\\mathtt{w}_1\\) are unconstrained. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/","title":"The Storage State Machine","text":"<p>The Storage State Machine (SM) is responsible for all operations on data stored in the zkProver's storage. It receives instructions from the Main State Machine, called Storage Actions. These Storage Actions are typical database operations; Create, Read, Update and Delete (CRUD).</p> <p>The Storage SM is in fact a micro-processor with the firm-ware and the hardware parts.</p> <p>It is in the firmware part of the Storage SM where the logic and rules are set up, expressed in JSON format and stored in a ROM. A novel language, called the zero-knowledge Assembly (zkASM), has been developed by the team. It is a language especially designed to map instructions from the zkProver's Main SM to other state machines, in this case, to the Storage SM's Executor. The Main SM's instructions, or Storage Actions, are parsed to the Storage SM Executor for execution in compliance with the rules and logic specified in the JSON-file.</p> <p>The hardware part uses another novel language, called Polynomial Identity Language (PIL), which is especially designed for the zkProver, because almost all state machines express computations in terms of polynomials. State transitions in state machines must satisfy computation-specific polynomial identities.</p> <p>The Storage SM's Executor carries out all Storage Actions (executes these operations), and also generates committed and constant polynomials.</p> <p>PIL codes, in the zkProver, are used to check correct execution of SM-specific Actions. They therefore take as inputs all committed and constant polynomials.</p> <p>In order to achieve zero-knowledge, all data is stored in the form of Merkle Trees, which means the Storage SM often makes requests of another state machine, the Poseidon SM, to perform hashing (referred to as \\(\\text{POSEIDON}\\) Actions).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#about-this-document","title":"About this Document","text":"<p>This document describes the Storage State Machine and the zkProver's Storage, which the Storage SM interacts with, by either reading or altering data stored in it. </p> <p>This document therefore entails; </p> <ul> <li>The basic design of the zkProver's Storage and some preliminaries. i.e., How the Sparse Merkle Trees (SMTs) are built.</li> <li>Explanations of each of the Basic Operations the Storage SM routinely performs.</li> <li>Specific parameters the Storage SM uses, such as, how keys and paths are created, and the two \\(\\text{POSEIDON}\\) Hashes used in the SMTs.</li> <li>As well as, the three main source-codes the Storage SM needs to function effectively. That is, <ul> <li>the Storage Assembly code, </li> <li>the Storage Executor (both in C and JavaScript), and </li> <li>the PIL code, for all the polynomial constraints and proving correctness of execution.</li> </ul> </li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#introduction","title":"Introduction","text":"<p>A generic state machine is characterised by; sets of states (as inputs) stored in registers, instructions to how the states should transition, and the resultant states (as outputs) stored as new values in the same registers. See Figure 1 below, for a standard state machine.</p> <p>A state machine can be monolithic, where it is a prototype of one particular computation, while others may specialise with certain types of computations. Depending on the computational algorithm, a state machine may have to run through a number of state transitions before producing the desired output. Iterations of the same sequence of operations may be required, to the extend that most common state machines are cyclic by nature.</p> <p></p>  Figure 1: A Generic State Machine  <p>The Storage SM performs computations on the key-value data stored in special Merkle Trees, called Sparse Merkle Trees (SMTs). The basic operations it executes are; CREATE, READ, UPDATE and DELETE.</p> <p>In the Storage SM, keys and values are strings of 256 bits and, for convenience, can be interpreted as 256-bit unsigned integers </p> <p>The mechanics of the Storage SM and its basic operations are described in detail later in this document. For now, an example of the UPDATE Operation is given in order to illustrate the various components involved.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#storage-design-preliminaries","title":"Storage Design - Preliminaries","text":"<p>Storage in the zkProver is designed in such a way that aggregators and verifiers can easily and efficiently interact with stored data. This is data needed for providing zero-knowledge proofs, or verifying state.</p> <p>Data is stored in the form of a special Sparse Merkle Tree (SMT), which is a tree that combines the concept of a Merkle Tree and that of a Patricia tree.</p> <p>What follows is an explanation of how the zkProver storage, as a database, is designed. This design is based on how the Sparse Merkle Trees are constructed and how they store keys and values.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#merkle-trees","title":"Merkle Trees","text":"<p>A typical Merkle tree has leaves, branches and a root. A leaf is a node with no child-nodes, while a branch is a node with child-nodes. A root is therefore a node with no parent-node.</p> <p>See Figure 3 below, for an example of how a hash function  \\(\\mathbf{H}\\)  is used to create a Merkle tree to record eight (8) values;   \\(\\text{V}_{\\mathbf{a}}, \\text{V}_{\\mathbf{b}}, \\text{V}_{\\mathbf{c}}, \\text{V}_{\\mathbf{d}}, \\text{V}_{\\mathbf{e}}, \\text{V}_{\\mathbf{f}}, \\text{V}_{\\mathbf{g}}, \\text{V}_{\\mathbf{h}}\\);</p> <ol> <li>Each leaf is nothing but the hash \\(\\mathbf{H}(\\text{V}_{\\mathbf{i}})\\) of a particular value \\(\\text{V}_{\\mathbf{i}}\\), where  \\(\\mathbf{ i} \\in \\{ \\mathbf{a}, \\mathbf{b}, \\mathbf{c}, \\mathbf{d}, \\mathbf{e}, \\mathbf{f}, \\mathbf{g}, \\mathbf{h} \\}\\).</li> <li>The branches;  \\(\\mathbf{B}_{\\mathbf{ab}} = \\mathbf{H} \\big( \\mathbf{H}(\\text{V}_{\\mathbf{a}})\\| \\mathbf{H}(\\text{V}_{\\mathbf{b}}) \\big)\\), \\(\\mathbf{B}_{\\mathbf{cd}} = \\mathbf{H} \\big( \\mathbf{H}(\\text{V}_{\\mathbf{c}})\\| \\mathbf{H}(\\text{V}_{\\mathbf{d}}) \\big)\\),      \\(\\mathbf{B}_{\\mathbf{ef}} = \\mathbf{H} \\big( \\mathbf{H}(\\text{V}_{\\mathbf{e}})\\| \\mathbf{H}(\\text{V}_{\\mathbf{f}}) \\big)\\), \\(\\mathbf{B}_{\\mathbf{gh}} = \\mathbf{H} \\big( \\mathbf{H}(\\text{V}_{\\mathbf{g}})\\| \\mathbf{H}(\\text{V}_{\\mathbf{h}}) \\big)\\), \\(\\mathbf{B}_{\\mathbf{abcd}} = \\mathbf{H} \\big(\\mathbf{B}_{\\mathbf{ab}}\\| \\mathbf{B}_{\\mathbf{cd}} \\big)\\)  and  \\(\\mathbf{B}_{\\mathbf{efgh}} = \\mathbf{H} \\big( \\mathbf{B}_{\\mathbf{ef}}\\| \\mathbf{B}_{\\mathbf{gh}} \\big)\\).</li> <li>The root is  \\(\\mathbf{root}_{\\mathbf{a..h}} = \\mathbf{H} \\big(\\mathbf{B}_{\\mathbf{abcd}}\\| \\mathbf{B}_{\\mathbf{efgh}} \\big)\\).</li> </ol> <p></p>  Figure 3: A Merkle Tree Example  <p>Leaves that share a parent-node are called siblings. The same terminology applies to branches. For example, \\(\\mathbf{B}_{\\mathbf{ab}}\\) and \\(\\mathbf{B}_{\\mathbf{cd}}\\) are siblings because they are branches of the same parent, \\(\\mathbf{B}_{\\mathbf{abcd}}\\). Similarly, \\(\\mathbf{B}_{\\mathbf{efgh}}\\) and \\(\\mathbf{B}_{\\mathbf{abcd}}\\) are siblings. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#using-keys-to-navigate-a-merkle-tree","title":"Using Keys To Navigate A Merkle Tree","text":"<p>Keys are used to navigate from the root to the leaves (and backwards).</p> <p>Reading the key starting from the left to the right, and when traversing the tree from the root downwards,</p> <ul> <li> <p>a zero-key-bit \"\\(0\\)\" means \"follow the edge going to the left\", </p> </li> <li> <p>a key-bit \"\\(1\\)\" means \"follow the edge going to the right\".</p> </li> </ul> <p>Consider the tree in Figure 1 above, as an example. Suppose one is given the key-value pair \\(( K_{\\mathbf{d}} , V_{\\mathbf{d}})\\), where \\(K_{\\mathbf{d}} = 10010110\\).</p> <p>The leaf \\(L_{\\mathbf{d}}\\), storing the value \\(V_{\\mathbf{d}}\\), is located uniquely by using the key, \\(K_{\\mathbf{d} } = 10010110\\), as follows;</p> <ol> <li>Read the least-significant bit of \\(K_{\\mathbf{d}}\\), which is \\(0\\), hence traverse the tree to the left, and reach \\(\\mathbf{B_{abcd}}\\).</li> <li>Then read the second significant key-bit, which is \"\\(1\\)\" in this case. So take the edge going to the right, reaching \\(\\mathbf{B_{cd}}\\).</li> <li>Again, read the next key-bit, which is \"\\(1\\)\", hence follow the edge going to the right, reaching the leaf \\(\\mathbf{H}( V_{\\mathbf{d}} )\\).</li> </ol> <p>Since \\(\\mathbf{H}( V_{\\mathbf{d}})\\) is a leaf and not a branch, and the navigation was correctly done with respect to the given key \\(K_{\\mathbf{d}}\\), the \\(\\mathbf{H}( V_{\\mathbf{d}})\\) must be the leaf storing the value \\(V_{\\mathbf{d}}\\).</p> <p>One can similarly \"climb\" the tree, going in the reverse direction, by using the key-bits of the given key in the reverse order. i.e., Starting with the last key-bit used to reach the leaf and ending with the least-significant bit of the key.</p> <p>The tree-address of the value \\(V_{\\mathbf{x}}\\), herein refers to the position of the leaf \\(L_{\\mathbf{x}} := \\mathbf{H}( V_{\\mathbf{x}})\\), denoted by the key-bits used to reach \\(L_{\\mathbf{d}}\\) but in the reverse order. </p> <p>In the above example (i.e., The tree in Figure 1), the tree-address of \\(V_{\\mathbf{d}}\\)  is <code>011</code>.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#a-merkle-proof-example","title":"A Merkle Proof Example","text":"<p>Merkle Trees can be used as commitment schemes. </p> <p>Here's an example that follows the (key,value)-pair approach used in the zkProver. </p> <p>Consider the Merkle Tree shown in Figure 3 above. </p> <p>If the prover has committed to a value \\(\\text{V}_{\\mathbf{f}}\\) by appending a new leaf \\(\\mathbf{H}(\\text{V}_{\\mathbf{f}})\\) to the Merkle Tree as in Figure 3, he must then avail the following information, to enable verification of his claim; </p> <ol> <li>The Merkle root \\(\\mathbf{root}_{\\mathbf{a..h}}\\),</li> <li>The value \\(\\text{V}_{\\mathbf{f}}\\),</li> <li>The siblings; \\(\\mathbf{H}(\\text{V}_{\\mathbf{e}})\\), \\(\\mathbf{B}_{\\mathbf{gh}}\\) and \\(\\mathbf{B}_{\\mathbf{abcd}}\\).</li> </ol> <p>Instead of searching through all hash values stored in the tree, the verifier uses only a few hash values of relevant siblings. That is, three (3) in this case.</p> <p>The verifier then checks the prover's claim by computing the Merkle root as follows;</p> <p>\u200b   (a) He computes  \\(\\mathbf{H}(\\text{V}_{\\mathbf{f}})\\), which is the hash of the value \\(\\text{V}_{\\mathbf{f}}\\).</p> <p>\u200b   (b) Then uses the sibling  \\(\\mathbf{H}(\\text{V}_{\\mathbf{e}})\\)  to compute  \\(\\mathbf{H} \\big( \\mathbf{H}(\\text{V}_{\\mathbf{e}})\\|\\mathbf{H}(\\text{V}_{\\mathbf{f}}) \\big) =: \\tilde{ \\mathbf{B}}_{\\mathbf{ef}}\\), which should be the same as the branch node \\(\\mathbf{B}_{\\mathbf{ef}}\\).</p> <p>(Note. The symbol, <code>tilde</code> \" \\(\\tilde{ }\\) \", is used throughout the document to indicate that the computed value, \\(\\tilde{\\Box}\\), still needs to be checked, or tested to be true.)</p> <p>\u200b   (c) Next, he computes  \\(\\mathbf{H} \\big( \\tilde{ \\mathbf{B}}_{\\mathbf{ef}}\\|\\mathbf{B}_{\\mathbf{gh}} \\big) =: \\tilde{ \\mathbf{B}}_{\\mathbf{efgh}}\\), corresponding to the branch node \\(\\mathbf{B}_{\\mathbf{efgh}}\\).</p> <p>\u200b   (d) Now, uses \\(\\mathbf{H} \\big( \\mathbf{B}_{\\mathbf{abcd}}\\| \\tilde{ \\mathbf{B}}_{\\mathbf{efgh}} \\big) =: \\tilde{ \\mathbf{root}}_{\\mathbf{a..h}}\\).</p> <p>The Merkle proof is concluded by checking whether \\(\\tilde{ \\mathbf{root}}_{\\mathbf{a\\dots h}}\\) equals to the publicly known root \\(\\mathbf{root}_{\\mathbf{a..h}}\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#building-simplified-binary-sparse-merkle-trees","title":"Building Simplified Binary Sparse Merkle Trees","text":"<p>Consider key-value pair based binary Sparse Merkle Trees (SMTs). </p> <p>The focus here is on explaining how to build an SMT that represents a given set of key-value pairs. And, for simplicity sake, key-lengths of 8 bits are assumed.</p> <p>A NULL or empty SMT has a zero root. That is, no key and no value recorded. Similarly, a zero node or NULL node refers to a node that carry no value.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#a-binary-smt-with-one-key-value-pair","title":"A Binary SMT With One Key-Value Pair","text":"<p>A binary SMT with a single key-value pair \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\), is built as follows. </p> <p>Suppose that the key, \\(K_{\\mathbf{a}} = 11010110\\). In order to build a binary SMT with this single key-value \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\),</p> <p>(a) One computes the hash \\(\\mathbf{H}( \\text{V}_{\\mathbf{a}})\\) of the value \\(\\text{V}_{\\mathbf{a}}\\),</p> <p>(b) Sets the leaf \\(\\mathbf{L}_{\\mathbf{a}} := \\mathbf{H}( \\text{V}_{\\mathbf{a}})\\),</p> <p>(c) Sets the sibling leaf as a NULL leaf, simply represented as \"\\(\\mathbf{0}\\)\", </p> <p>(d) Computes the root as  \\(\\mathbf{root}_{a0} = \\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{0} )\\), with the leaf \\(\\mathbf{L}_{\\mathbf{a}}\\) on the left because the \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\). That is, between the two edges leading up to the root, the leaf \\(\\mathbf{L}_{\\mathbf{a}}\\) is on the left edge, while the NULL leaf \"\\(\\mathbf{0}\\)\" is on the right.</p> <p>See, Figure 4 below, for the SMT representing the single key-value pair \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\), where  \\(K_{\\mathbf{a}} = 11010110\\).</p> <p></p>  Figure 4: A Single key-value pair SMT  <p>Note that the last nodes in binary SMT branches are generally either leaves or zero-nodes. </p> <p>In the case where the least-significant bit, lsb of \\(K_{\\mathbf{a}}\\) is \\(1\\), the SMT with a single key-value pair \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) would be a mirror image of what is seen in Figure 3. And its root,  \\(\\mathbf{root}_{0a} = \\mathbf{H}( \\mathbf{0}\\| \\mathbf{L}_{\\mathbf{a}}  ) \\neq \\mathbf{root}_{a0}\\) because \\(\\mathbf{H}\\) is a collision-resistant hash function.</p> <p>This example also explains why we need a zero node. Since all trees used in our design are binary SMTs, a zero node is used as a default sibling for computing the parent node. This helps to differentiate between roots (also between parent nodes) because a root node actually identifies an SMT. Therefore, it is crucial to distinguish between  \\(\\mathbf{root}_{a0} = \\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{0} )\\) and \\(\\mathbf{root}_{0a} = \\mathbf{H}( \\mathbf{0}\\| \\mathbf{L}_{\\mathbf{a}})\\) because they represent two distinct trees.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#binary-smts-with-two-key-value-pairs","title":"Binary SMTs With Two Key-Value Pairs","text":"<p>Consider now SMTs with two key-value pairs, \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) and \\((K_{\\mathbf{b}}, \\text{V}_{\\mathbf{b}})\\). </p> <p>There are three distinct cases of how corresponding SMTs can be built, each determined by the keys, \\(K_{\\mathbf{a}}\\) and \\(K_{\\mathbf{b}}\\).</p> <p>Case 1: The keys are such that the \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\) and the \\(\\text{lsb}(K_{\\mathbf{b}}) = 1\\).</p> <p>Suppose that the keys are given as, \\(K_{\\mathbf{a}} = 11010110\\) and \\(K_{\\mathbf{b}} = 11010101\\). </p> <p>To build a binary SMT with this two key-values, \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) and \\((K_{\\mathbf{b}}, \\text{V}_{\\mathbf{b}})\\),</p> <p>(a) One computes the hashes, \\(\\mathbf{H}(\\text{V}_{\\mathbf{a}})\\) and \\(\\mathbf{H}( \\text{V}_{\\mathbf{b}})\\) of the values, \\(\\text{V}_{\\mathbf{a}}\\) and \\(\\text{V}_{\\mathbf{b}}\\) , respectively,</p> <p>(b) Sets the leaves, \\(\\mathbf{L}_{\\mathbf{a}} := \\mathbf{H}( \\text{V}_{\\mathbf{a}})\\) and \\(\\mathbf{L}_{\\mathbf{b}} := \\mathbf{H}( \\text{V}_{\\mathbf{b}})\\),</p> <p>(c) Checks if the \\(\\text{lsb}(K_{\\mathbf{a}})\\) differs from the \\(\\text{lsb}(K_{\\mathbf{b}})\\),</p> <p>(d) Since the \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\) and the \\(\\text{lsb}(K_{\\mathbf{b}}) = 1\\), it means the two leaves can be siblings,</p> <p>(e) One can then compute the root as, \\(\\mathbf{root}_{\\mathbf{ab}} = \\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{L}_{\\mathbf{b}})\\). </p> <p>\u200b       Note that, the leaf \\(\\mathbf{L}_{\\mathbf{a}}\\) is on the left because the \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\), but \\(\\mathbf{L}_{\\mathbf{b}}\\) is on the right because the \\(\\text{lsb}(K_{\\mathbf{b}}) = 1\\). That is, between the two edges leading up to the \\(\\mathbf{root}_{\\mathbf{ab}}\\), the leaf \\(\\mathbf{L}_{\\mathbf{a}}\\) must be on the edge from the left, while \\(\\mathbf{L}_{\\mathbf{b}}\\) is on the edge from the right.</p> <p>See, Figure 5(a) below, for the SMT representing the two key-value pairs \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) and \\((K_{\\mathbf{b}}, \\text{V}_{\\mathbf{b}})\\), where  \\(K_{\\mathbf{a}} = 11010110\\) and \\(K_{\\mathbf{b}} = 11010101\\).</p> <p></p>  Figure 5(a): Two key-value pairs SMT - Case 1  <p>Case 2: Both keys end with the same key-bit. That is, the \\(\\text{lsb}(K_{\\mathbf{a}}) = \\text{lsb}(K_{\\mathbf{b}})\\), but their second least-significant bits differ.</p> <p>Suppose that the two keys are given as, \\(K_{\\mathbf{a}} = 11010100\\) and \\(K_{\\mathbf{b}} = 11010110\\). </p> <p>To build a binary SMT with this two key-values, \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) and \\((K_{\\mathbf{b}}, \\text{V}_{\\mathbf{b}})\\);</p> <p>(a) One computes the hashes, \\(\\mathbf{H}(\\text{V}_{\\mathbf{a}})\\) and \\(\\mathbf{H}( \\text{V}_{\\mathbf{b}})\\) of the values, \\(\\text{V}_{\\mathbf{a}}\\) and \\(\\text{V}_{\\mathbf{b}}\\) , respectively.</p> <p>(b) Sets the leaves, \\(\\mathbf{L}_{\\mathbf{a}} := \\mathbf{H}( \\text{V}_{\\mathbf{a}})\\) and \\(\\mathbf{L}_{\\mathbf{b}} := \\mathbf{H}( \\text{V}_{\\mathbf{b}})\\).</p> <p>(c) Checks if the \\(\\text{lsb}(K_{\\mathbf{a}})\\) differs from the \\(\\text{lsb}(K_{\\mathbf{b}})\\). Since the \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\) and the \\(\\text{lsb}(K_{\\mathbf{b}}) = 0\\), it means the two leaves cannot be siblings at this position because it would otherwise mean they share the same tree-address <code>0</code>, which is not allowed.</p> <p>(d) One, therefore, continues to check if the second least-significant bits of  \\(K_{\\mathbf{a}}\\) and \\(K_{\\mathbf{b}}\\) differ. Since the \\(\\text{second lsb}(K_{\\mathbf{a}}) = 0\\) and the \\(\\text{second lsb}(K_{\\mathbf{b}}) = 1\\), it means the two leaves \\(\\mathbf{L}_{\\mathbf{a}}\\) and \\(\\mathbf{L}_{\\mathbf{b}}\\) can be siblings at their respective tree-addresses, <code>00</code> and <code>10</code>.</p> <p>(e) Next is to compute the hash \\(\\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{L}_{\\mathbf{b}})\\) and set it as the branch \\(\\mathbf{B}_{\\mathbf{ab}} := \\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{L}_{\\mathbf{b}})\\) at the tree-address <code>0</code>. Note that the leaf \\(\\mathbf{L}_{\\mathbf{a}}\\) is on the left because the \\(\\text{second  lsb}(K_{\\mathbf{a}}) = 0\\), while \\(\\mathbf{L}_{\\mathbf{b}}\\) is on the right because the \\(\\text{second  lsb}(K_{\\mathbf{b}}) = 1\\).</p> <p>(f) The branch \\(\\mathbf{B}_{\\mathbf{ab}} := \\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{L}_{\\mathbf{b}})\\) needs a sibling. Since all the values, \\(\\text{V}_{\\mathbf{a}}\\) and \\(\\text{V}_{\\mathbf{b}}\\), are already represented in the tree at \\(\\mathbf{L}_{\\mathbf{a}}\\) and \\(\\mathbf{L}_{\\mathbf{b}}\\), respectively, one therefore sets a NULL leaf \"\\(\\mathbf{0}\\)\" as the sibling leaf to \\(\\mathbf{B}_{\\mathbf{ab}}\\).</p> <p>(g) As a result, it is possible to compute the root as, \\(\\mathbf{root}_{\\mathbf{ab0}} = \\mathbf{H}(\\mathbf{B}_{\\mathbf{ab}} \\| \\mathbf{0})\\). Note that, the branch \\(\\mathbf{B}_{\\mathbf{ab}}\\) is on the left because the \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\), and \\(\\mathbf{0}\\) must therefore be on the right. That is, between the two edges leading up to the \\(\\mathbf{root}_{\\mathbf{ab0}}\\), the branch \\(\\mathbf{B}_{\\mathbf{ab}}\\) must be on the edge from the left, while \\(\\mathbf{0}\\) is on the edge from the right.</p> <p>See, Figure 5(b) below, depicting the SMT representing the two key-value pairs \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) and \\((K_{\\mathbf{b}}, \\text{V}_{\\mathbf{b}})\\), where  \\(K_{\\mathbf{a}} = 11010100\\) and \\(K_{\\mathbf{b}} = 11010110\\). </p> <p></p>  Figure 5(b): Two key-value pairs SMT - Case 2  <p>Case 3: The first two least-significant bits of both keys are the same, but their third least-significant bits differ.</p> <p>Suppose that the two keys are given as, \\(K_{\\mathbf{a}} = 11011000\\) and \\(K_{\\mathbf{b}} = 10010100\\). The process for building a binary SMT with this two key-values, \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) and \\((K_{\\mathbf{b}}, \\text{V}_{\\mathbf{b}})\\) is the same as in Case 2;</p> <p>(a) One computes the hashes, \\(\\mathbf{H}(\\text{V}_{\\mathbf{a}})\\) and \\(\\mathbf{H}( \\text{V}_{\\mathbf{b}})\\) of the values, \\(\\text{V}_{\\mathbf{a}}\\) and \\(\\text{V}_{\\mathbf{b}}\\) , respectively.</p> <p>(b) Sets the leaves, \\(\\mathbf{L}_{\\mathbf{a}} := \\mathbf{H}( \\text{V}_{\\mathbf{a}})\\) and \\(\\mathbf{L}_{\\mathbf{b}} := \\mathbf{H}( \\text{V}_{\\mathbf{b}})\\).</p> <p>(c) Checks if the \\(\\text{lsb}(K_{\\mathbf{a}})\\) differs from the \\(\\text{lsb}(K_{\\mathbf{b}})\\). Since the \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\) and the \\(\\text{lsb}(K_{\\mathbf{b}}) = 0\\), it means the two leaves cannot be siblings at this position as it would otherwise mean they share the same tree-address <code>0</code>, which is not allowed.</p> <p>(d) Next verifier coninues to check if the second least-significant bits of \\(K_{\\mathbf{a}}\\) and \\(K_{\\mathbf{b}}\\) differ. Since the \\(\\text{second lsb}(K_{\\mathbf{a}}) = 0\\)  and the \\(\\text{second lsb}(K_{\\mathbf{b}}) = 0\\), it means the two leaves cannot be siblings at this position, because it would otherwise mean they share the same tree-address <code>00</code>, which is not allowed.</p> <p>(e) Once again he checks if the third least-significant bits of \\(K_{\\mathbf{a}}\\) and \\(K_{\\mathbf{b}}\\) differ. Since the \\(\\text{third lsb}(K_{\\mathbf{a}}) = 0\\) and the \\(\\text{third  lsb}(K_{\\mathbf{b}}) = 1\\), it means the two leaves \\(\\mathbf{L}_{\\mathbf{a}}\\) and \\(\\mathbf{L}_{\\mathbf{b}}\\) can be siblings at their respective tree-addresses, <code>000</code> and <code>100</code>.</p> <p>(f) One then computes the hash \\(\\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{L}_{\\mathbf{b}})\\), and sets it as the branch \\(\\mathbf{B}_{\\mathbf{ab}} := \\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{L}_{\\mathbf{b}})\\) at the tree-address <code>00</code>. The leaf \\(\\mathbf{L}_{\\mathbf{a}}\\) is on the left because the third \\(\\text{lsb}(K_{\\mathbf{a}}) = 0\\), while \\(\\mathbf{L}_{\\mathbf{b}}\\) is on the right because the third \\(\\text{lsb}(K_{\\mathbf{b}}) = 1\\).</p> <p>(g) The branch \\(\\mathbf{B}_{\\mathbf{ab}} := \\mathbf{H}(\\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{L}_{\\mathbf{b}})\\) needs a sibling. Since all the values, \\(\\text{V}_{\\mathbf{a}}\\) and \\(\\text{V}_{\\mathbf{b}}\\) , are already represented in the tree at \\(\\mathbf{L}_{\\mathbf{a}}\\) and \\(\\mathbf{L}_{\\mathbf{b}}\\), respectively, one therefore sets a NULL leaf \"\\(\\mathbf{0}\\)\" as the sibling leaf to \\(\\mathbf{B}_{\\mathbf{ab}}\\).</p> <p>(h) One can now compute the hash \\(\\mathbf{H}(\\mathbf{B}_{\\mathbf{ab}} \\| \\mathbf{0})\\), and set it as the branch \\(\\mathbf{B}_{\\mathbf{ab0}} := \\mathbf{H}(\\mathbf{B}_{\\mathbf{ab}} \\| \\mathbf{0})\\) at the tree-address <code>0</code>. The hash is computed with the branch \\(\\mathbf{B}_{\\mathbf{ab}}\\) on the left because the second lsb of both keys, \\(K_{\\mathbf{a}}\\) and \\(K_{\\mathbf{b}}\\), equals \\(0\\). Therefore the NULL leaf \"\\(\\mathbf{0}\\)\" must be on the right as an argument to the hash.</p> <p>(i) The branch \\(\\mathbf{B}_{\\mathbf{ab0}} := \\mathbf{H}(\\mathbf{B}_{\\mathbf{ab}} \\| \\mathbf{0})\\) also needs a sibling. For the same reason given above, one sets a NULL leaf \"\\(\\mathbf{0}\\)\" as the sibling leaf to \\(\\mathbf{B}_{\\mathbf{ab0}}\\). </p> <p>(j) Now, one is able to compute the root as, \\(\\mathbf{root}_{\\mathbf{ab00}} = \\mathbf{H}(\\mathbf{B}_{\\mathbf{ab0}} \\| \\mathbf{0})\\). Note that the hash is computed with the branch \\(\\mathbf{B}_{\\mathbf{ab0}}\\) on the left because the lsb of both keys, \\(K_{\\mathbf{a}}\\) and \\(K_{\\mathbf{b}}\\), equals \\(0\\). That is, between the two edges leading up to the \\(\\mathbf{root}_{\\mathbf{ab00}}\\), the branch \\(\\mathbf{B}_{\\mathbf{ab0}}\\) must be on the edge from the left, while \"\\(\\mathbf{0}\\)\" is on the edge from the right.</p> <p>See, Figure 5(c) below, depicting the SMT representing the two key-value pairs \\((K_{\\mathbf{a}}, \\text{V}_{\\mathbf{a}})\\) and \\((K_{\\mathbf{b}}, \\text{V}_{\\mathbf{b}})\\), where  \\(K_{\\mathbf{a}} = 11011000\\) and \\(K_{\\mathbf{b}} = 10010100\\).</p> <p></p>  Figure 5(c): Two key-value pairs SMT - Case 3  <p>There are several other SMTs of two key-value pairs \\((K_{\\mathbf{x}}, \\text{V}_{\\mathbf{x}})\\) and \\((K_{\\mathbf{z}}, \\text{V}_{\\mathbf{z}})\\) that can be constructed depending on how long are the strings of the common least-significant bits between \\(K_{\\mathbf{x}}\\) and \\(K_{\\mathbf{z}}\\).</p> <p>In general, when building an SMT, leaves of key-value pairs with the same least-significant key-bits share the same \"navigational path\" only until any of the corresponding key-bits differ. These common strings of key-bits dictate where the leaf storing the corresponding value is located in the tree.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#a-few-more-concepts-about-binary-smts","title":"A Few More Concepts About Binary SMTs","text":"<p>In here are a few more concepts needed in understanding our specific design of the zkProver storage using binary SMTs. These concepts also help in elucidating how keys influence the shape of binary SMTs.</p> <p>First is the level of a leaf. </p> <p>The level of a leaf, \\(\\mathbf{L}_{\\mathbf{x}}\\), in a binary SMT is defined as the number of edges one traverses when navigating  from the root to the leaf. Denote the level of the leaf \\(\\mathbf{L_x}\\) by  \\(\\text{lvl}(\\mathbf{L_x})\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-1-leaf-levels","title":"Example 1. Leaf Levels","text":"<p>Consider Figure 6 below, for an SMT storing seven (7) key-value pairs, built by following the principles explained in the foregoing subsection;</p> \\[\\begin{aligned} (\\mathbf{K}_{\\mathbf{a}} , V_{\\mathbf{a}}),\\ \\ (\\mathbf{K}_{\\mathbf{b}} , V_{\\mathbf{b}}),\\ \\  (\\mathbf{K}_{\\mathbf{c}} , V_{\\mathbf{c}}),\\ \\ (\\mathbf{K}_{\\mathbf{c}}, V_{\\mathbf{c}}),\\\\  (\\mathbf{K}_{\\mathbf{d}}, V_{\\mathbf{d}}),\\ \\  (\\mathbf{K}_{\\mathbf{e}}, V_{\\mathbf{e}}),\\ \\  (\\mathbf{K}_{\\mathbf{f}}, V_{\\mathbf{f}})\\ \\ {\\text{and}}\\ \\ (\\mathbf{K}_{\\mathbf{g}} , V_{\\mathbf{g}}) \\end{aligned}\\] <p>where the keys are,</p> \\[\\begin{aligned} K_{\\mathbf{a}} = 10101100, K_{\\mathbf{b}} = 10010010, K_{\\mathbf{c}} = 10001010, &amp;K_{\\mathbf{d}} = 11100110,\\\\ K_{\\mathbf{e}} = 11110101, K_{\\mathbf{f}} = 10001011, K_{\\mathbf{g}} = 00011111. \\end{aligned}\\] <p>The leaf levels are as follows;</p> <p>\\(\\text{lvl}(\\mathbf{L}_{\\mathbf{a}}) = 2\\), \\(\\text{lvl}(\\mathbf{L}_{\\mathbf{b}}) = 4\\), \\(\\text{lvl}(\\mathbf{L}_{\\mathbf{c}}) = 4\\), \\(\\text{lvl}(\\mathbf{L}_{\\mathbf{d}}) = 3\\), \\(\\text{lvl}(\\mathbf{L}_{\\mathbf{e}}) = 2\\), \\(\\text{lvl}(\\mathbf{L}_{\\mathbf{f}}) = 3\\) and \\(\\text{lvl}(\\mathbf{L}_{\\mathbf{g}}) = 3\\).</p> <p></p>  Figure 6: An SMT of 7 key-value pairs  <p>As illustrated, in the above subsections, keys basically determine the shape of the SMT. They dictate where respective leaves must be placed when building the SMT. </p> <p>The main determining factor of the SMT shape is in fact the common key-bits among the keys. For instance, the reason why the leaves \\(\\mathbf{L}_{\\mathbf{b}}\\) and \\(\\mathbf{L}_{\\mathbf{c}}\\) have the largest leaf level \\(4\\) is because the two leaves have the longest string of common key-bits \"\\(010\\)\" in the SMT of Figure 6 above.</p> <p>This explains why different leaves in SMTs can have different levels.</p> <p>The height of a Merkle Tree refers to the largest number of edges traversed when navigating from the root to any leaf. Since all leaves are of the same level in Merkle Trees, the concept of a height coincide with that of the level of a leaf for Merkle Trees.</p> <p>But this is not the case for SMTs. Since leaf levels differ from one leaf to another in SMTs, the height of an SMT is not the same as the leaf level.</p> <p>Rather, the height of an SMT is defined as the largest leaf level among the various leaf levels of leaves on the SMT. For instance, the height of the SMT depicted in Figure 6 above, is \\(4\\). </p> <p>Now, since all keys have the same fixed key-length, they not only influence SMT leaf levels and shapes, but also restrict SMT heights to the fixed key-length. The maximum height of an SMT is the maximum key-length imposed on all keys.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-remaining-key","title":"The Remaining Key","text":"<p>In a general Sparse Merkle Tree (SMT) values are stored at their respective leaf-nodes. </p> <p>But a leaf node \\(\\mathbf{L}_{\\mathbf{x}}\\) not only stores a value, \\(V_{\\mathbf{x}}\\) , but also the key-bits that are left unused in the navigation from the root to \\(\\mathbf{L}_{\\mathbf{x}}\\). These unused key-bits are called the remaining key, and are denoted by \\(\\text{RK}_{\\mathbf{x}}\\) for the leaf node \\(\\mathbf{L}_{\\mathbf{x}}\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-2-remaining-keys","title":"Example 2. Remaining Keys","text":"<p>Consider again the SMT of the 7 key-value pairs depicted in Figure 6 above. </p> <p>The remaining keys of each of the 7 leaves in the SMT are as follows; </p> <p>\\(\\text{RK}_{\\mathbf{a}} = 110101\\),  \\(\\text{RK}_{\\mathbf{b}} = 1001\\),  \\(\\text{RK}_{\\mathbf{c}} = 0001\\),  \\(\\text{RK}_{\\mathbf{d}} = 00111\\),  \\(\\text{RK}_{\\mathbf{e}} = 101111\\),  \\(\\text{RK}_{\\mathbf{f}} = 10001\\)  and  \\(\\text{RK}_{\\mathbf{g}} = 11000\\).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-fake-leaf-attack","title":"The Fake-Leaf Attack","text":"<p>Note that the above simplified design of binary SMTs, based on key-value pairs, presents some problems.</p> <p>The characteristic of binary SMTs having leaves at different levels can be problematic to verifiers, especially when carrying out a simple Merkle proof. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#scenario-a-fake-smt-leaf","title":"Scenario A: Fake SMT Leaf","text":"<p>What if the verifier is presented with a fake leaf?</p> <p>Consider Figure 7 below, showing a binary SMT with a branch \\(\\mathbf{{B}_{ab}}\\) and its children \\(\\mathbf{L_{a}}\\) and \\(\\mathbf{L_{b}}\\) hidden from the verifier's sight.</p> <p>That is, suppose the verifier is provided with the following information;</p> <ul> <li>The key-value \\((K_{\\mathbf{fk}}, V_\\mathbf{{fk}})\\), where \\(K_{\\mathbf{fk}} = 11010100\\) and \\(V_{\\mathbf{fk}} = \\mathbf{L_{a}} \\| \\mathbf{L_{b}}\\).</li> <li>The root  \\(\\mathbf{{root}_{ab..f}}\\) , the number of levels to root, and the siblings \\(\\mathbf{{S}_{\\mathbf{cd}}}\\) and \\(\\mathbf{{S}_{\\mathbf{ef}}}\\).</li> </ul> <p>That is, the Attacker claims that some \\(V_{\\mathbf{fk}}\\) is stored at \\(\\mathbf{L_{fk}} := \\mathbf{{B}_{ab}}\\).</p> <p>Verifier is unaware that \\(V_{\\mathbf{fk}}\\) is in fact the concatenated value of the hidden real leaves, \\(\\mathbf{L_{a}}\\) and \\(\\mathbf{L_{b}}\\), that are children of the supposed leaf \\(\\mathbf{L_{fk}}\\). i.e., Verifier does not know that leaf \\(\\mathbf{L_{fk}}\\) is in fact a branch.</p> <p></p>  Figure 7: MPT - Fake Leaf Attack  <p>So then, the verifier being unaware that \\(\\mathbf{L_{fk}}\\) is not a properly constructed leaf, starts verification as follows; </p> <ol> <li>He uses the key \\(K_{\\mathbf{fk}}\\) to navigate the tree until locating the supposed leaf \\(\\mathbf{L_{fk}}\\).</li> <li>He computes \\(\\mathbf{H}(V_{\\mathbf{fk}})\\) and sets it as      \\(\\tilde{\\mathbf{L}}_{\\mathbf{fk}} := \\mathbf{H}(V_{\\mathbf{fk}})\\). </li> <li>Then takes the sibling \\(\\mathbf{{S}_{\\mathbf{cd}}}\\) and calculates \\(\\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}} = \\mathbf{H} \\big( \\tilde{\\mathbf{L}}_{\\mathbf{fk}} \\| \\mathbf{S}_{\\mathbf{cd}}  \\big)\\). </li> <li>And then, uses \\(\\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}}\\) to compute the root,  \\(\\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}} = \\mathbf{H} \\big( \\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}}\\| \\mathbf{S}_{\\mathbf{ef}} \\big)\\).</li> </ol> <p>The question is: \"Does the fake leaf \\(\\mathbf{L_{fk}}\\) pass the verifier's Merkle proof or not?\" Or, equivalently: \"Is \\(\\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}}\\) equal to \\(\\mathbf{root}_{\\mathbf{ab..f}}\\)?\"</p> <p>Since the actual branch \\(\\mathbf{{B}_{ab}}\\) is by construction the hash,  \\(\\mathbf{H}(\\mathbf{L_{a}} \\| \\mathbf{L_{b}})\\), then  \\(\\mathbf{{B}_{ab}} = \\tilde{\\mathbf{L}}_{\\mathbf{fk}}\\).  The parent branch \\({\\mathbf{B}}_{\\mathbf{abcd}}\\) also, being constructed as the hash,  \\(\\mathbf{H} \\big( \\mathbf{B}_{\\mathbf{ab}}\\| { \\mathbf{S}}_{\\mathbf{cd}} \\big)\\), should be equal to \\(\\mathbf{H} \\big( \\tilde{\\mathbf{L}}_{\\mathbf{fk}} \\| \\mathbf{S}_{\\mathbf{cd}}  \\big)  = \\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}}\\). As a result, \\(\\mathbf{root}_{\\mathbf{ab..f}} = \\mathbf{H} \\big(  {\\mathbf{B}}_{\\mathbf{abcd}} \\| \\mathbf{S}_{\\mathbf{ef}} \\big) = \\mathbf{H} \\big( \\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}}\\| \\mathbf{S}_{\\mathbf{ef}} \\big) = \\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}}\\). </p> <p>Therefore, the fake leaf \\(\\mathbf{L_{fk}}\\) passes the Merkle proof. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#solution-to-the-fake-leaf-attack","title":"Solution To The Fake-Leaf Attack","text":"<p>In order to circumvent the Fake-Leaf Attack we modify how the binary SMTs are built.</p> <p>Here's the trick: When building binary SMTs, differentiate between how leaves are hashed and how branches are hashed.</p> <p>That is, use two different hash functions; one hash function to hash leaves, denote it by \\(\\mathbf{H}_{\\mathbf{leaf}}\\), and the other function for hashing non-leaf nodes, denote it by \\(\\mathbf{H}_{\\mathbf{noleaf}}\\).</p> <p>How does this prevent the Fake-Leaf Attack?</p> <p>Reconsider now, the Scenario A, given above. </p> <p>Recall that the Attacker provides the following;</p> <ul> <li>The key-value \\((K_{\\mathbf{fk}}, V_\\mathbf{{fk}})\\), where \\(K_{\\mathbf{fk}} = 11010100\\) and \\(V_{\\mathbf{fk}} = \\mathbf{L_{a}} \\| \\mathbf{L_{b}}\\).</li> <li>The root  $ \\mathbf{{root}_{ab..f}}$ , the number of levels to root, and the siblings  \\(\\mathbf{{S}_{\\mathbf{cd}}}\\)  and  \\(\\mathbf{{S}_{\\mathbf{ef}}}\\).</li> </ul> <p>The verifier suspecting no foul, uses \\(K_{\\mathbf{fk}} = 11010100\\) to navigate the tree until he finds \\(V_{\\mathbf{fk}}\\) stored at \\(\\mathbf{L_{fk}} := \\mathbf{{B}_{ab}}\\). </p> <p>He subsequently starts the Merkle proof by hashing the value \\(\\tilde{V}_{\\mathbf{fk}}\\) stored at the located leaf. Since, this computation amounts to forming a leaf, he uses the leaf-hash function, \\(\\mathbf{H}_{\\mathbf{leaf}}\\). </p> <ul> <li>He then sets \\(\\tilde{\\mathbf{L}}_{\\mathbf{fk}}  :=  \\mathbf{H}_{\\mathbf{leaf}} \\big( V_{\\mathbf{fk}} \\big) = \\mathbf{H}_{\\mathbf{leaf}} \\big( \\mathbf{L_{a}} \\| \\mathbf{L_{b}} \\big)\\).</li> <li>And further computes  \\(\\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}} = \\mathbf{H}_{\\mathbf{noleaf}} \\big( \\tilde{\\mathbf{L}}_{\\mathbf{fk}} \\| \\mathbf{S}_{\\mathbf{cd}}  \\big)\\). </li> <li>Again, calculates the root,  \\(\\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}} = \\mathbf{H}_{\\mathbf{noleaf}} \\big( \\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}}\\| \\mathbf{S}_{\\mathbf{ef}} \\big)\\).</li> </ul> <p>But the actual branch \\(\\mathbf{{B}_{ab}}\\) was constructed with the no-leaf-hash function,  \\(\\mathbf{H}_{\\mathbf{noleaf}}\\). That is, </p> \\[\\begin{aligned} \\mathbf{{B}_{ab}} = \\mathbf{H}_{\\mathbf{noleaf}} (\\mathbf{L_{a}} \\| \\mathbf{L_{b}}) \\neq \\mathbf{H}_{\\mathbf{leaf}} \\big(\\mathbf{L_{a}} \\| \\mathbf{L_{b}} \\big) = \\tilde{\\mathbf{L}}_{\\mathbf{fk}}. \\end{aligned}\\] <p>The parent branch \\({\\mathbf{B}}_{\\mathbf{abcd}}\\) also, was constructed as, \\({\\mathbf{B}}_{\\mathbf{abcd}} = \\mathbf{H}_{\\mathbf{noleaf}} \\big( \\mathbf{B}_{\\mathbf{ab}}\\| { \\mathbf{S}}_{\\mathbf{cd}} \\big)\\).  Since the hash functions used are collision-resistant,  \\({\\mathbf{B}}_{\\mathbf{abcd}}\\) cannot be equal to  \\(\\mathbf{H}_{\\mathbf{noleaf}} \\big( \\tilde{\\mathbf{L}}_{\\mathbf{fk}} \\| \\mathbf{S}_{\\mathbf{cd}}  \\big)  = \\tilde{ \\mathbf{B}}_{\\mathbf{fkcd}}\\).  Consequently, \\(\\mathbf{root}_{\\mathbf{ab..f}}  \\neq \\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}}\\). Therefore, the Merkle Proof fails. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#non-binding-key-value-pairs","title":"Non-Binding Key-Value Pairs","text":"<p>Whenever the verifier needs to check inclusion of the given key-value pair \\((K_{\\mathbf{x}}, \\text{V}_{\\mathbf{x}})\\) in a binary SMT identified by the \\(\\mathbf{{root}_{a..x}}\\), he first navigates the SMT in order to locate the leaf \\(\\mathbf{{L}_{x}}\\) storing \\(\\text{V}_{\\mathbf{x}}\\), and thereafter carries out two computations. </p> <p>Both computations involve climbing the tree from the located leaf \\(\\mathbf{{L}_{x}}\\) back to the root, \\(\\mathbf{{root}_{a..x}}\\). And the two computations are;</p> <ol> <li>Checking correctness of the key \\(K_{\\mathbf{x}}\\). </li> </ol> <p>That is, verifier takes the Remaining Key, \\(\\text{RK}_{\\mathbf{x}}\\), and reconstructs the key \\(K_{\\mathbf{x}}\\) by concatenating the key bits used to navigate to \\(\\mathbf{{L}_{x}}\\) from \\(\\mathbf{{root}_{a..x}}\\), in the reverse order.</p> <p>Suppose the number of levels to root is 3, and the least-significant bits used for navigation are \\(\\text{kb}_\\mathbf{2}\\), \\(\\text{kb}_\\mathbf{1}\\) and \\(\\text{kb}_\\mathbf{0}\\).</p> <p>In order to check key-correctness, verifier the remaining key \\(\\text{RK}\\) and,</p> <p>(a)  Concatenates \\(\\text{kb}_\\mathbf{2}\\) and gets \\(\\text{ } \\text{RK} \\|  \\text{kb}_\\mathbf{2}\\),</p> <p>(b)  Concatenates \\(\\text{kb}_\\mathbf{1}\\) then gets \\(\\text{ } \\text{RK} \\|  \\text{kb}_\\mathbf{2} \\| \\text{kb}_\\mathbf{1}\\),</p> <p>(c)  Concatenates \\(\\text{kb}_\\mathbf{0}\\) and gets \\(\\text{ }  \\text{RK} \\|  \\text{kb}_\\mathbf{2} \\| \\text{kb}_\\mathbf{1} \\| \\text{kb}_\\mathbf{0}\\).</p> <p>He then sets \\(\\tilde{K}_{\\mathbf{x}} := \\text{RK} \\|  \\text{kb}_\\mathbf{2} \\| \\text{kb}_\\mathbf{1} \\| \\text{kb}_\\mathbf{0}\\), and checks if \\(\\tilde{K}_{\\mathbf{x}}\\) equals \\(K_{\\mathbf{x}}\\). </p> <ol> <li>The Merkle proof: That is, checking whether the value stored at the located leaf \\(\\mathbf{{L}_{x}}\\) was indeed included in computing the root, \\(\\mathbf{{root}_{a..x}}\\). </li> </ol> <p>This computation was illustrated several times in the above discussions. Note that the key-correctness and the Merkle proof are simultaneously carried out. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-3-indistinguishable-leaves","title":"Example 3. (Indistinguishable Leaves)","text":"<p>Suppose a binary SMT contains a key-value pair \\((K_{\\mathbf{d}}, V_\\mathbf{{d}})\\) at the leaf \\(\\mathbf{L_{d}}\\), where \\(K_{\\mathbf{d}} = 11100110\\).  That is, \\(\\mathbf{L_{d}} := \\mathbf{H_{leaf}}(V_\\mathbf{{d}})\\).</p> <p>Note that, when building binary SMTs, it is permissible to have another key-value pair \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\) in the same tree with \\(V_\\mathbf{{x}} = V_\\mathbf{{d}}\\).</p> <p>An Attacker can pick the key-value pair \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\) such that \\(V_\\mathbf{{x}} = V_\\mathbf{{d}}\\) and \\(K_{\\mathbf{x}} = 10100110\\). And, with the above design, it means  \\(\\mathbf{L_{x}} = \\mathbf{H_{leaf}}(V_\\mathbf{{x}}) = \\mathbf{H_{leaf}}(V_\\mathbf{{d}}) =  \\mathbf{L_{d}}\\).</p> <p>Consider Figure 8 below. And suppose the Attacker provides the following data;</p> <ul> <li>The key-value \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\), where    \\(K_{\\mathbf{x}} = 10100110\\) and \\(V_{\\mathbf{x}} = V_\\mathbf{d}\\).</li> <li>The root, \\(\\mathbf{{root}_{a..x}}\\), the number of levels to root = 3, and the siblings  \\(\\mathbf{{B}_{\\mathbf{bc}}}\\), \\(\\mathbf{L_{a}}\\) and  \\(\\mathbf{{S}_{\\mathbf{efg}}}\\). </li> </ul> <p>The verifier uses the least-significant key bits; \\(\\text{kb}_\\mathbf{0} = 0\\),  \\(\\text{kb}_\\mathbf{1} = 0\\) and \\(\\text{kb}_\\mathbf{2} = 1\\);  to navigate the tree and locate the leaf \\(\\mathbf{L_{x}}\\) which is positioned at \\(\\mathbf{L_{d}}\\), see Figure 7 below.</p> <p></p>  Figure 8: Non-binding Key-Value Pairs <p>In order to ensure that \\(\\mathbf{L_{x}}\\) actually stores the value \\(V_\\mathbf{{x}}\\); The verifier first checks key-correctness. He takes the remaining key \\(\\text{RK} = 10100\\) and, </p> <p>(a) Concatenates \\(\\text{kb}_\\mathbf{2} = 1\\), and gets \\(\\text{ } \\text{RK} \\| \\text{kb}_\\mathbf{2} = 10100 \\|1\\),</p> <p>(b) Concatenates \\(\\text{kb}_\\mathbf{1} = 0\\)  to get \\(\\text{ } \\text{RK} \\| \\text{kb}_\\mathbf{2} \\|  \\text{kb}_\\mathbf{1} = 10100 \\|1\\|0\\),</p> <p>(c) Concatenates \\(\\text{kb}_\\mathbf{0} = 0\\), yielding \\(\\text{ }  \\text{RK} \\| \\text{kb}_\\mathbf{2} \\|  \\text{kb}_\\mathbf{1} \\| \\text{kb}_\\mathbf{0} = 10100 \\|1\\|0\\|0\\). </p> <p>He sets \\(\\tilde{K}_{\\mathbf{x}} := 10100 \\|1\\|0\\|0 = 10100100\\).  Since \\(\\tilde{K}_{\\mathbf{x}}\\) equals \\(K_{\\mathbf{x}}\\), the verifier concludes that the supplied key is correct.</p> <p>As the verifier 'climbs' the tree to test key-correctness, he concurrently checks if the value \\(V_\\mathbf{{x}}\\) is included in the SMT identified by the given root, \\(\\mathbf{{root}_{a..x}}\\). That is, he executes the following computations;</p> <p>\u200b   (a) He computes the hash of \\(V_\\mathbf{{x}}\\) and sets it as, \\(\\tilde{\\mathbf{L}}_\\mathbf{x}:= \\mathbf{H_{leaf}}(V_\\mathbf{{x}})\\).</p> <p>\u200b   (b) Then he uses \\(\\mathbf{{B}_{\\mathbf{bc}}}\\) to compute, \\(\\tilde{\\mathbf{B}}_{\\mathbf{bcd}} = \\mathbf{H_{noleaf}}(\\mathbf{{B}_{\\mathbf{bc}}} \\|\\tilde{\\mathbf{L}}_\\mathbf{x})\\).</p> <p>\u200b   (c) He also uses \\(\\mathbf{L_{a}}\\) to compute, \\(\\tilde{\\mathbf{B}}_{\\mathbf{abcd}} = \\mathbf{H_{noleaf}}(\\mathbf{L_{a}} \\| \\tilde{\\mathbf{B}}_{\\mathbf{bcd}})\\).</p> <p>\u200b   (d) He further calculates, \\(\\tilde{\\mathbf{root}}_{\\mathbf{abcd}} = \\mathbf{H_{noleaf}}(\\tilde{\\mathbf{B}}_{\\mathbf{abcd}} \\| \\mathbf{{S}_{\\mathbf{efg}}})\\). </p> <p>Next, the verifier checks if \\(\\tilde{\\mathbf{root}}_{\\mathbf{abcd}}\\) equals \\(\\mathbf{root}_{\\mathbf{abcd}}\\).</p> <p>Since \\(V_\\mathbf{{x}} = V_\\mathbf{{d}}\\), it follows that all the corresponding intermediate values to the root are equal;</p> <ul> <li>\\(\\mathbf{L_{d}} = \\mathbf{H_{leaf}}(V_\\mathbf{{d}}) = \\mathbf{H_{leaf}}(V_\\mathbf{{x}}) = \\tilde{\\mathbf{L}}_\\mathbf{x}\\), </li> <li>\\(\\mathbf{B}_{\\mathbf{bcd}} = \\mathbf{H_{noleaf}}(\\mathbf{{B}_{\\mathbf{bc}}} \\| \\mathbf{L}_\\mathbf{d}) = \\mathbf{H_{noleaf}}(\\mathbf{{B}_{\\mathbf{bc}}} \\|\\tilde{\\mathbf{L}}_\\mathbf{x}) = \\tilde{\\mathbf{B}}_{\\mathbf{bcd}}\\), </li> <li>\\(\\mathbf{B}_{\\mathbf{abcd}} = \\mathbf{H_{noleaf}}(\\mathbf{L_{a}} \\| \\mathbf{B}_{\\mathbf{bcd}} ) = \\mathbf{H_{noleaf}}(\\mathbf{L_{a}} \\| \\tilde{\\mathbf{B}}_{\\mathbf{bcd}} ) = \\tilde{\\mathbf{B}}_{\\mathbf{abcd}}\\),</li> <li>\\(\\mathbf{root}_{\\mathbf{abcd}} = \\mathbf{H_{noleaf}}(\\mathbf{B}_{\\mathbf{abcd}} \\| \\mathbf{{S}_{\\mathbf{efg}}} )  = \\mathbf{H_{noleaf}}(\\tilde{\\mathbf{B}}_{\\mathbf{abcd}} \\| \\mathbf{{S}_{\\mathbf{efg}}} ) = \\tilde{\\mathbf{root}}_{\\mathbf{abcd}}\\).  </li> </ul> <p>The verifier therefore concludes that the key-value pair \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\) is in the SMT, when it is not.</p> <p>Why is this attack successful?</p> <p>Note that equality of values, \\(V_\\mathbf{{x}} = V_\\mathbf{{d}}\\), associated with two distinct keys, has nothing to do with the efficacy of this attack. In fact, for all practical purposes, it should be permissible for distinct leaves to store any value, irrespective of whether other leaves store an equivalent value or not.</p> <p>The downfall of our binary SMTs design, thus far, is that it does not give the verifier any equation that relates or ties the keys to their associated values.</p> <p>In other words, the attack succeeds simply because the key-value pairs (as 'committed' values) are not binding.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#solution-to-the-non-binding-key-value-problem","title":"Solution To The Non-Binding Key-Value Problem","text":"<p>The solution to this problem is straightforward, and it is to build the binary SMTs in such a way that the key-value pairs are binding. </p> <p>This means, create a relationship between the keys and their associated values, so that the verifier can simply check if this relationship holds true.</p> <p>In order to ensure that checking such a relationship blends with the usual proof machinery, one has two options. </p> <p>The na\u00efve solution, which involves the keys, is one option.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-naive-solution","title":"The Na\u00efve Solution","text":"<p>The na\u00efve solution is to simpy include keys in the argument of the hash function, when forming leaves.</p> <p>That is, when building a binary SMT, one includes a key-value pair \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\) by setting the leaf \\(\\mathbf{L_{x}}\\) to be the hash of both the value and the key;</p> \\[\\begin{aligned} \\mathbf{L_{x}} = \\mathbf{H_{leaf}}(K_{\\mathbf{x}} \\| V_\\mathbf{{x}} ) \\end{aligned}\\] <p>Does this change remedy the non-binding problem?</p> <p>Suppose \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\) and \\((K_{\\mathbf{z}}, V_\\mathbf{{z}})\\) are two key-value pairs such that \\(V_\\mathbf{{x}} = V_\\mathbf{{z}}\\) , while \\(K_\\mathbf{{x}}\\) and \\(K_\\mathbf{{z}}\\) differ only in one of the most-significant bits.</p> <p>Since the hash functions used are collision-resistant, it follows that </p> \\[\\begin{aligned} \\mathbf{L_{x}} = \\mathbf{H_{leaf}}(K_{\\mathbf{x}} \\| V_\\mathbf{{x}}) \\neq \\mathbf{H_{leaf}}(K_{\\mathbf{z}} \\| V_\\mathbf{{z}}) = \\mathbf{L_{z}} \\end{aligned}\\] <p>Consequently, although the key-value pairs \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\) and \\((K_{\\mathbf{z}}, V_\\mathbf{{z}})\\) might falsely pass the key-correctness check, they will not pass the Merkle proof test. And this is because, collision-resistance also guarantees that the following series of inequalities hold true;</p> \\[\\begin{aligned} \\mathbf{L_{x}} = \\mathbf{H_{leaf}}(K_{\\mathbf{x}} \\| V_\\mathbf{{x}}) \\neq \\mathbf{H_{leaf}}(K_{\\mathbf{z}} \\| V_\\mathbf{{z}}) = \\mathbf{L_{z}} \\\\  \\\\  \\mathbf{B_{bx}} = \\mathbf{H_{noleaf}}(\\mathbf{S}_\\mathbf{{b}} \\| \\mathbf{L}_{\\mathbf{x}}) \\neq \\mathbf{H_{noleaf}}(\\mathbf{S}'_\\mathbf{{b}} \\| \\mathbf{L}_{\\mathbf{z}}) = \\mathbf{B_{bz}} \\\\  \\\\  \\mathbf{B_{abx}} = \\mathbf{H_{noleaf}}(\\mathbf{S}_\\mathbf{{a}} \\| \\mathbf{B_{bx}} ) \\neq \\mathbf{H_{noleaf}}(\\mathbf{S}'_\\mathbf{{a}} \\| \\mathbf{B_{bz}}) = \\mathbf{B_{abz}} \\end{aligned}\\] <p>where; \\(\\mathbf{S}_\\mathbf{{b}}\\) is a sibling to \\(\\mathbf{L}_{\\mathbf{x}}\\), and \\(\\mathbf{S}_\\mathbf{{a}}\\) is a sibling to \\(\\mathbf{B_{bx}}\\), making \\(\\mathbf{B_{bx}}\\) and \\(\\mathbf{B_{abx}}\\) branches traversed while climbing the tree from \\(\\mathbf{L_{x}}\\) to root; Similarly,  \\(\\mathbf{S}'_\\mathbf{{b}}\\) is a sibling to \\(\\mathbf{L}_{\\mathbf{z}}\\), while \\(\\mathbf{S}'_\\mathbf{{a}}\\) is a sibling to \\(\\mathbf{B_{bx}}\\), also making \\(\\mathbf{B_{bz}}\\) and \\(\\mathbf{B_{abz}}\\) branches traversed while climbing the tree from \\(\\mathbf{L_{z}}\\) to root.</p> <p>The only chance for the Merkle proof to pass is if the key-value pairs \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\) and \\((K_{\\mathbf{z}}, V_\\mathbf{{z}})\\) are distinct and are individually on the same SMT. </p> <p>The inclusion of keys, in the argument of the hash functions, therefore ensures that leaves \\(\\mathbf{L_{x}}\\) and \\(\\mathbf{L_{z}}\\) are distinguishable. And most importantly, that key-value pairs in our SMTs are now binding.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#a-better-solution","title":"A Better Solution","text":"<p>The other solution, which is much more apt than the Na\u00efve option, utilises the remaining keys when forming leaves.</p> <p>Since levels to root is related to the Remaining Key (\\(\\text{RK}\\)) notion, a much more apt solution is to rather include the remaining key, \\(\\text{RK}_\\mathbf{x}\\), as the argument to the hash function, instead of the whole key \\(K_{\\mathbf{x}}\\).</p> <p>That is, for a key-value pair \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\), one sets the leaf \\(\\mathbf{L_{x}}\\) to be the hash of both the value and the remaining key;</p> \\[\\begin{aligned} \\mathbf{L_{x}} = \\mathbf{H_{leaf}}( \\text{RK}_\\mathbf{x}  \\| \\text{V}_\\mathbf{{x}}). \\end{aligned}\\] <p>With this strategy, the verifier needs the remaining key \\(\\text{RK}_\\mathbf{{x}}\\) , instead of the whole key, in order to carry out a Merkle proof. So he adjusts the Merkle proof by; </p> <ul> <li>Firstly, picking the correct hash function \\(\\mathbf{H_{leaf}}\\) for leaves, </li> <li>Secondly, concatenating the value \\(V_{\\mathbf{x}}\\) stored at the leaf \\(L_{\\mathbf{x}}\\) and the remaining key \\(\\text{RK}_\\mathbf{{x}}\\), instead of the whole key \\(K_{\\mathbf{x}}\\),</li> <li>Thirdly, hashing the concatenation \\(\\mathbf{H_{leaf}}( \\text{RK}_\\mathbf{x}  \\| \\text{V}_\\mathbf{{x}}) =: \\mathbf{L_{x}}\\).</li> </ul> <p>This approach not only ensures that key-value pairs in our SMTs are now binding, but also implicitly 'encodes' the levels to root in the leaf.</p> <p>The strategy of using the \\(\\text{RK}_\\mathbf{x}\\) instead of the key \\(K_{\\mathbf{x}}\\), coupled with hashing leaves and branches differently, yields sound verification.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#introducing-zero-knowledge","title":"Introducing Zero-Knowledge","text":"<p>It is often necessary to make sure that a proof-integrity system has the zero-knowledge property. In order to introduce zero-knowledge, instead of storing values as plaintexts in the leaves, one stores hashes of these values.</p> <p>A leaf therefore is henceforth constructed in two steps;</p> <ul> <li>Firstly, for a key-value pair \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\), compute the hash the value \\(V_\\mathbf{{x}}\\), </li> </ul> \\[\\begin{aligned}   \\text{Hashed Value} = \\text{HV}_\\mathbf{{x}} = \\mathbf{H_{noleaf}}(V_\\mathbf{{x}}) \\end{aligned}\\] <ul> <li>Secondly, form the leaf containing \\(V_\\mathbf{{x}}\\), as follows,</li> </ul> \\[\\begin{aligned}   \\mathbf{L_{x}} = \\mathbf{H_{leaf}}(  \\text{RK}_\\mathbf{x}  \\| \\text{HV}_\\mathbf{{x}}) \\end{aligned}\\] <p>Since it is infeasible to compute the preimage of the hash functions, \\(\\mathbf{H_{leaf}}\\) and \\(\\mathbf{H_{noleaf}}\\), computing the hash of the value \\(V_\\mathbf{{x}}\\) amounts to 'encrypting'.</p> <p>The prover therefore achieves zero-knowledge by providing the pair, \\((K_{\\mathbf{x}}, \\text{HV}_\\mathbf{{x}})\\), as the key-value pair instead of the explicit one, \\((K_{\\mathbf{x}}, V_\\mathbf{{x}})\\).</p> <p>The verifier, on the other hand, has to adjust the Merkle proof by starting with; </p> <ul> <li>Firstly, picking the correct hash function \\(\\mathbf{H_{leaf}}\\) for leaf nodes,</li> <li>Secondly, concatenating the hashed-value \\(\\text{HV}_\\mathbf{{x}}\\) and the remaining key \\(\\text{RK}_\\mathbf{{x}}\\),</li> <li>Thirdly, hashing the concatenation in order to form the leaf, \\(\\mathbf{L_{x}} := \\mathbf{H_{leaf}}( \\text{RK}_\\mathbf{x}  \\| \\text{HV}_\\mathbf{{x}})\\).</li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-4-zero-knowledge-merkle-proof","title":"Example 4. (Zero-Knowledge Merkle Proof)","text":"<p>The following example illustrates a Merkle proof when the above strategy is applied.</p> <p>Consider an SMT where the keys are 8-bit long, and the prover commits to the key-value \\(( K_{\\mathbf{c}} , \\text{HV}_{\\mathbf{c}} )\\) with \\(K_{\\mathbf{c}} = 10010100\\). See Figure 9 below. </p> <p></p>  Figure 9 : ZK Merkle Proof Example  <p>Since the levels to root is 3, the prover provides; the least-significant key-bits, \\(\\text{kb}_0 = 0\\), \\(\\text{kb}_1 = 0\\), \\(\\text{kb}_2 = 1\\), the stored hashed-value \\(\\text{HV}_{\\mathbf{c}}\\), the root  \\(\\mathbf{{root}_{a..f}}\\), the Remaining Key \\(\\mathbf{ \\text{RK}_{\\mathbf{c}}} = 10010\\), and the siblings \\(\\mathbf{{S}_{ab}}\\), \\(\\mathbf{{L}_{d}}\\) and \\(\\mathbf{{S}_{\\mathbf{ef}}}\\).</p> <p>The verifier first uses the least-significant bits of the key \\(K_{\\mathbf{c}} = 10010100\\) to navigate the SMT from the root, \\(\\mathbf{{root}_{a..f}}\\), to the leaf \\(\\mathbf{L_c}\\). Then, he executes the following computations;</p> <ol> <li> <p>He computes, \\(\\mathbf{L_c} = \\mathbf{H_{leaf}}\\big( \\mathbf{ \\text{RK}_{\\mathbf{c}}} \\| \\text{HV}_{\\mathbf{c}} \\big) = \\mathbf{H_{leaf}}( 10010 \\| \\text{HV}_{\\mathbf{c}})\\)</p> </li> <li> <p>Then, he uses the sibling \\(\\mathbf{{S}_{ab}}\\) to compute, \\(\\tilde{ \\mathbf{B}}_{\\mathbf{abc}} := \\mathbf{H_{noleaf}} \\big( \\mathbf{{S}_{ab}}\\|\\mathbf{L}_{\\mathbf{c}} \\big)\\).</p> </li> <li> <p>Next, he computes, \\(\\tilde{ \\mathbf{B}}_{\\mathbf{abcd}} := \\mathbf{H_{noleaf}} \\big( \\tilde{ \\mathbf{B}}_{\\mathbf{abc}} \\| \\mathbf{L}_{\\mathbf{d}} \\big)\\).</p> </li> <li> <p>Now, verifier uses \\(\\tilde{ \\mathbf{B}}_{\\mathbf{abcd}}\\) to compute the supposed root,  \\(\\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}}  := \\mathbf{H_{noleaf}} \\big( \\tilde{ \\mathbf{B}}_{\\mathbf{abcd}}\\| \\mathbf{S}_{\\mathbf{ef}} \\big)\\).</p> </li> <li> <p>Checks if \\(\\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}}\\) equals \\({ \\mathbf{root}}_{\\mathbf{ab..f}}\\).</p> </li> </ol> <p>The verifier accepts that the key-value pair \\(( K_{\\mathbf{c}} , V_{\\mathbf{c}} )\\) is in the SMT only if  \\(\\tilde{ \\mathbf{root}}_{\\mathbf{ab..f}} = { \\mathbf{root}}_{\\mathbf{ab..f}}\\). And he does this without any clue about the exact value \\(V_{\\mathbf{c}}\\) which is hidden as \\(\\text{HV}_{\\mathbf{c}}\\). </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#basic-operations-storage-actions","title":"Basic Operations (Storage Actions)","text":"<p>The previous sections have focused on the design of binary SMTs. The problems that cropped up with our initial design have assisted in refining and defining a secure design. While describing the design of binary SMTs, we have extensively utilised the READ or \"Get\" operation. </p> <p>Now that the basic design is established, the other operations can be delineated. The operations that the Storage State Machine performs, as per instructions of the Main SM Executor, are called Storage Actions. As mentioned above, these are; Create, Read, Update and Delete (CRUD).</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-read-operation","title":"The READ Operation","text":"<p>First, we illustrate the READ operation, which is in fact a \"Get\". </p> <p>The prover can commit to a key-value pair \\((K_{\\mathbf{x}}, \\text{HV}_{\\mathbf{x}})\\) where \\(\\text{HV}_{\\mathbf{x}}\\) is the hash of the value \\(V_{\\mathbf{x}}\\). That is, he claims that he created a leaf \\(\\mathbf{L}_{\\mathbf{x}}\\) which contains the value \\(V_{\\mathbf{x}}\\) and it can be located using the key \\(K_{\\mathbf{x}}\\).</p> <p>READ therefore means locating the leaf \\(\\mathbf{L}_{\\mathbf{x}}\\) and verifying that it contains the value \\(V_{\\mathbf{x}}\\) by using a Merkle proof.</p> <p>Hence, in addition to \\((K_{\\mathbf{x}}, \\text{HV}_{\\mathbf{x}})\\), prover has to provide the rest of the information needed for completing the Merkle proof. That is, the root, the key-bits \\(\\text{kb}_\\mathbf{j}\\) for locating the leaf \\(\\mathbf{L}_{\\mathbf{x}}\\), the Remaining Key \\(\\text{RK}_\\mathbf{x}\\)  and all the necessary siblings. </p> <p>What if the key is not set?</p> <p>The next example demostrates the READ operation when a key is not set in the tree. That is, it illustrates how to check whether a value is not on a given SMT. </p> <p>There are two cases that can occur. The given key may lead either to a zero node or to an existing leaf.</p> <p>If the given key leads to a zero-node, then the verifier needs only prove the existence of the zero-node, and this would sufficiently prove that the key is not set.</p> <p>But if the given key leads to an existing leaf, the verifier has to prove the leaf exists in the SMT and show that the given key is not the same as the actual key associated with the value at the leaf.  </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-5-when-the-key-is-not-set","title":"Example 5. When The Key Is Not Set","text":"<p>Suppose the verifier needs to prove that the keys, \\(K_{\\mathbf{x}} = 11010101\\) and \\(K_{\\mathbf{z}} = 10101010\\) are not set in the SMT depicted in Figure 10 below. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#case-1-when-the-key-leads-to-a-zero-node","title":"Case 1: When the key leads to a zero-node","text":"<p>The verifier receives the key \\(K_{\\mathbf{x}}\\), the remaining key \\(\\text{RK}_\\mathbf{x} = 1101010\\), the least-significant key-bit \\(\\text{kb}_0 = 1\\), and the sibling \\(\\mathbf{{S}_{1}} = \\mathbf{{B}_{\\mathbf{ab}}}\\).</p> <p>Since the least-significant key-bit of the given key, \\(\\text{kb}_0 = 1\\), navigation from the root leads to the right-side, to the zero-node. See the node circled in a green colour, in Figure 9 below.</p> <p>The task here is to verify that the node is indeed a zero-node.</p> <p>So the verifier computes the root as follows,  \\(\\mathbf{{\\tilde{root}}_{ab0}} = \\mathbf{H_{noleaf}} (\\mathbf{{S}_{1}} \\| \\mathbf{0} )  = \\mathbf{H}( \\mathbf{{B}_{\\mathbf{ab}}} \\| \\mathbf{0} )\\). </p> <p>Note that he concatenates \\(\\mathbf{{S}_{1}}\\) and \\(\\mathbf{0}\\) in the given ordering, because \\(\\text{kb}_0 = 1\\).</p> <p>He then checks if  \\(\\mathbf{{\\tilde{root}}_{ab0}} = \\mathbf{{root}_{ab0}}\\). If this is true, then he concludes that the given key is not set.</p> <p></p>  Figure 10: Key Not Set Example"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#case-2-when-the-key-leads-to-an-existing-leaf","title":"Case 2: When the key leads to an existing leaf","text":"<p>Consider again the SMT depicted in Figure 10 above, and suppose that the prover claims that the key \\(K_{\\mathbf{z}} = 10101010\\) is set.</p> <p>The verifier is given; the key \\(K_{\\mathbf{z}} = 10101010\\), the Remaining Key \\(\\text{RK}_{\\mathbf{z}} = 101010\\), the least-significant key-bit \\(\\text{kb}_0 = 0\\), the second least-significant key-bit \\(\\text{kb}_{\\mathbf{1}} = 1\\), and the siblings  \\(\\mathbf{{S}_{1}} = \\mathbf{L}_{a}\\)  and  \\(\\mathbf{{S}_{2}} = \\mathbf{0}\\).</p> <p>When navigating the tree from \\(\\mathbf{{root}_{ab0}}\\), using the key-bits \\(\\text{kb}_{\\mathbf{0}} = 0\\) and \\(\\text{kb}_{\\mathbf{1}} = 1\\), and with reference to Figure 10 above,</p> <ul> <li> <p>the key-bit \\(\\text{kb}_{\\mathbf{0}}  = 0\\) leads to the branch \\(\\mathbf{{B}_{\\mathbf{ab}}}\\), </p> </li> <li> <p>then from \\(\\mathbf{{B}_{\\mathbf{ab}}}\\), the key-bit  \\(\\text{kb}_{\\mathbf{1}} = 1\\) leads to the leaf \\(\\mathbf{L}_\\mathbf{b}\\), which is the leaf circled in brown in Figure 9 above.</p> </li> </ul> <p>Since the key navigates to a leaf, the verifier's task is to prove two things simultaneously;</p> <ol> <li>The leaf is in the SMT described in Figure 10, and </li> <li>The Remaining Key at the leaf \\(\\mathbf{L}_\\mathbf{b}\\) is different from the Remaining Key supplied by the prover.</li> </ol> <p>In proving that \\(\\mathbf{L}_{\\mathbf{b}}\\) is indeed in the tree, the verifier does the following;</p> <p>Checks the root:</p> <p>(a) Computes the hash of the hashed-value, \\(\\mathbf{ \\tilde{L} }_{\\mathbf{b}} = \\mathbf{H_{leaf}} ( \\text{RK}_{\\mathbf{b}} \\| \\text{HV}_{\\mathbf{b}} )\\), </p> <p>(b) Uses the first sibling to compute, \\(\\mathbf{{\\tilde{B}}_{\\mathbf{ab}}} = \\mathbf{H_{noleaf}} \\big( \\mathbf{L}_{\\mathbf{a}} \\| \\mathbf{ \\tilde{L}}_{\\mathbf{b}} \\big)\\), </p> <p>(c) Then, uses the second sibling to compute the root, \\(\\mathbf{\\tilde{root}}_{ab0} = \\mathbf{H_{noleaf}} \\big( \\mathbf{{\\tilde{B}}_{\\mathbf{ab}}} \\| \\mathbf{0} \\big)\\). </p> <p>(d) Completes the root-check by testing equality, \\(\\mathbf{\\tilde{root}}_{ab0} = \\mathbf{{root}}_{ab0}\\).  </p> <p>Simultaneously,</p> <p>Checks the keys: </p> <p>The verifier takes the two Remaining Keys \\(\\text{RK}_{\\mathbf{x}}\\) and \\(\\text{RK}_{\\mathbf{b}}\\), and the key-bits \\(\\text{kb}_0\\) and \\(\\text{kb}_{\\mathbf{1}}\\);</p> <p>(a) Concatenates them as, \\(\\tilde{K}_{\\mathbf{x}} = \\text{RK}_{\\mathbf{x}} \\| \\text{kb}_0 \\| \\text{kb}_{\\mathbf{1}}\\) and \\(\\tilde{K}_{\\mathbf{b}} = \\text{RK}_{\\mathbf{b}} \\| \\text{kb}_0 \\| \\text{kb}_{\\mathbf{1}}\\),</p> <p>(b) Checks \\(\\tilde{K}_{\\mathbf{x}} = K_{\\mathbf{x}}\\) and \\(\\tilde{K}_{\\mathbf{b}} = K_{\\mathbf{b}}\\), and</p> <p>(c) Finally shows the inequality, \\(\\tilde{K}_{\\mathbf{x}} \\neq K_{\\mathbf{b}}\\).</p> <p>This proves that the key \\(K_{\\mathbf{x}}\\) is not set.</p> <p>Remark: The last check, where the verifier checks inequality of keys, turns out to be very expensive to implement. A much more smarter method is used in the Storage State Machine. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-update-operation","title":"The UPDATE Operation","text":"<p>The UPDATE operation does not change the topology of the tree. When carrying out the UPDATE, it is therefore important to retain all labels of nodes.</p> <p>The UPDATE process entails the following;</p> <p>First, the verifier needs to be provided with the following data; The remaining key \\(\\text{RK}\\), the least-significant key-bits, the new value, the old value, the old root and the siblings.</p> <p>Step 1. Checking a READ of the current value with the old root. That is, checking that the leaf exists in the tree, and it was included in calculating the old root.</p> <p>Step 2. Recomputing (updating) all nodes along the path, from the leaf to the root, as well as computing the new root with the newly updated nodes.</p> <p>The verifier can continue with Step 2 only if all the checks in Step 1 pass verification.</p> <p>For the UPDATE operation, Step 1 is exactly the same as the READ operation. We therefore focus on illustrating Step 2. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-6-update-step-2","title":"Example 6. UPDATE - Step 2","text":"<p>Suppose the set key is \\(K_{\\mathbf{c}} = 10110100\\) corresponding to the old value \\(V_{\\mathbf{c}}\\), and the new value is \\(V_\\mathbf{new}\\).</p> <p>The verifier is provided with the following data;</p> <p>\u200b   (a) the \\(\\text{RK}_{\\mathbf{c}} = 10110\\), </p> <p>\u200b   (b) the least-significant key-bit \\(\\text{kb}_0 = 0\\), </p> <p>\u200b   (c) the second least-significant key-bit  \\(\\text{kb}_1 = 0\\), </p> <p>\u200b   (d) the third least-significant key-bit  \\(\\text{kb}_2 = 1\\), </p> <p>\u200b   (e) the old hashed value \\(\\text{HV}_{\\mathbf{c}}\\),</p> <p>\u200b   (f) the old root  \\(\\mathbf{{root}_{ab..f }}\\) , and </p> <p>\u200b   (g) the siblings  \\(\\mathbf{{S}_{1}} = \\mathbf{{S}_{\\mathbf{ab}}}\\),   \\(\\mathbf{{S}_{2}} = \\mathbf{{L}_{d}}\\)  and  \\(\\mathbf{{S}_{3}} = \\mathbf{{S}_{\\mathbf{ef}}}\\). </p> <p>Consider the SMT given in Figure 11 below.</p> <p></p>  Figure 11: Value UPDATE Example  <p>The required Step 2 of the UPDATE operation involves, </p> <p>(a) Computing the hash of the new value \\(V_\\mathbf{new}\\) as;  \\(\\text{HV}_{\\mathbf{new}} = \\mathbf{H_{noleaf}}(V_\\mathbf{new})\\),  </p> <p>(b) Forming the new leaf by again hashing the hashed value \\(\\text{HV}_{\\mathbf{new}}\\) as;  \\(\\mathbf{ \\tilde{L} }_{\\mathbf{new}} = \\mathbf{H_{leaf}}( \\text{RK}_{\\mathbf{new}} \\| \\text{HV}_{\\mathbf{new}} )\\), </p> <p>(c) Using the first sibling  \\(\\mathbf{{S}_{1}} = \\mathbf{{S}_{\\mathbf{ab}}}\\)  to compute,  \\(\\mathbf{{\\bar{B}}_{abc}} = \\mathbf{H_{noleaf}} \\big( \\mathbf{{S}_{\\mathbf{ab}}} \\| \\mathbf{ \\tilde{L}}_{\\mathbf{new}} \\big)\\), </p> <p>(d) Again, using the second sibling \\(\\mathbf{{S}_{2}} = \\mathbf{{L}_{d}}\\) to compute, \\(\\mathbf{{\\bar{B}}_{\\mathbf{abcd}}} = \\mathbf{H_{noleaf}} \\big( \\mathbf{{\\bar{B}}_{abc}} \\| \\mathbf{{L}_{d}} \\big)\\), </p> <p>(e) Then, uses the third sibling \\(\\mathbf{{S}_{3}} = \\mathbf{{S}_{\\mathbf{ef}}}\\) to compute the root, \\(\\mathbf{{{root}}_{\\mathbf{new}}} = \\mathbf{H_{noleaf}} \\big( \\mathbf{{\\bar{B}}_{\\mathbf{abcd}}} \\| \\mathbf{{S}_{\\mathbf{ef}}}\\big)\\).</p> <p>Note that the key-bits are not changed. Therefore, replacing the following old values in the SMT,  \\(\\text{HV}_\\mathbf{c}, \\mathbf{{B}_{abc}}, \\mathbf{{B}_{abcb}}, \\mathbf{{root}_{ab..f } }\\), with the new ones, \\(\\text{HV}_\\mathbf{new}, \\mathbf{{\\bar{B}}_{abc}}, \\mathbf{{\\bar{B}}_{abcb}}, \\mathbf{{root}_{new } }\\), respectively, completes the UPDATE operation.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-create-operation","title":"The CREATE Operation","text":"<p>The CREATE Operation adds a new leaf \\(\\mathbf{L_{\\mathbf{new}}}\\) to the SMT in order to insert and store a new key-value pair \\(( \\mathbf{{K_{new}}} , \\mathbf{V_{\\mathbf{new}}} )\\) at \\(\\mathbf{L_{\\mathbf{new}}}\\), where the key \\(\\mathbf{K_{new}}\\) was never used in the SMT and thus is uniquely associated with the leaf \\(\\mathbf{L_{new}}\\).</p> <p>When navigating from the root, the new key \\(\\mathbf{K_{new}}\\) can lead to either a zero node or an existing leaf. This results in two scenarios.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#case-1-new-key-navigates-to-a-zero-node","title":"Case 1: New Key Navigates To A Zero Node","text":"<p>That is, the first  \\(l\\)  least-significant bits of the key \\(\\mathbf{K_{new}}\\) leads to a zero node, where  \\(l\\)  is the levels to root of the zero node.</p> <p>The first step is to double-check that indeed the node is a zero node. That is, the verifier performs a Merkle proof starting with either \\(\\mathbf{H_{noleaf}} ( \\mathbf{S_1} \\| \\mathbf{0} )\\) or \\(\\mathbf{H_{noleaf}} ( \\mathbf{0} \\| \\mathbf{S_1} )\\), depending on whether the sibling of the zero-node is on the right (the edge corresponding to a key-bit \\(1\\)) or on the left (the edge corresponding to a key-bit \\(0\\)), respectively.</p> <p>Once it is established that the new key \\(\\mathbf{K_{new}}\\) has led to a zero node, the verifier simply changes the zero node to the leaf \\(\\mathbf{L_{new}}\\) that stores the value \\(\\mathbf{V_{new}}\\). </p> <p>The CREATE operation, in this case, therefore boils down to an UPDATE operation on the zero node. It amounts to;</p> <ul> <li>Computing the hash of the new value \\(V_\\mathbf{new}\\) as,  \\(\\text{HV}_{\\mathbf{new}} = \\mathbf{H_{noleaf}}(V_\\mathbf{new})\\), </li> <li>Then forming the new leaf, \\(\\mathbf{L_{new}} = \\mathbf{H_{leaf}}( \\text{RK}_{\\mathbf{new}} \\| \\text{HV}_{\\mathbf{new}})\\),</li> <li>Recomputing all the nodes along the path climbing from the leaf \\(\\mathbf{L_{new}}\\) to the root, including computing the new root.</li> </ul>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-7-create-operation-at-a-zero-node","title":"Example 7. CREATE Operation at a Zero Node","text":"<p>Suppose a new leaf with the key-value pair \\(\\big(K_{\\mathbf{new}}, \\text{V}_{\\mathbf{new}}\\big)\\), where \\(K_{\\mathbf{new}} = 11010110\\), needs to be created.</p> <p>As illustrated in Figure 12 below, the two least-significant key-bits \\(\\text{kb}_0 = 0\\) and \\(\\text{kb}_1 = 1\\), lead to a zero node. That is, navigating from the root;</p> <p>\u200b   (a) The lsb, \\(\\text{kb}_{0} = 0\\)  leads to the node \\(\\mathbf{{B}_{ab0}}\\), </p> <p>\u200b   (b) Whilst the second lsb, \\(\\text{kb}_{1} = 1\\)  leads to a zero node. </p> <p>At this stage the verifier checks if this is indeed a zero node;</p> <ol> <li>First he computes  \\(\\mathbf{{\\tilde{B}}_{ab0}} = \\mathbf{H_{noleaf}} \\big( \\mathbf{{S}_{\\mathbf{ab}}} \\| \\mathbf{0} \\big)\\). </li> <li>Then he computes  \\(\\mathbf{{\\tilde{root}}_{ab0c}} = \\mathbf{H_{noleaf}} \\big( \\mathbf{{\\tilde{B}}_{ab0}} \\| \\mathbf{L_{c}} \\big)\\). </li> <li>And, checks if  \\(\\mathbf{{\\tilde{root}}_{ab0c}}\\)  equals  \\(\\mathbf{{root}_{ab0c}}\\). </li> </ol> <p></p>  Figure 12: CREATE Operation - Zero Node  <p>Once the zero-value is checked, the verifier now creates a non-zero leaf with the key-value pair \\(\\big( \\mathbf{K_{new}} , \\text{HV}_{\\mathbf{new}}\\big)\\).</p> <ol> <li>He computes the hash of \\(\\text{V}_{\\mathbf{new}}\\) as, \\(\\text{HV}_{\\mathbf{new}} = \\mathbf{H_{noleaf}}(V_\\mathbf{new})\\), </li> <li>He then forms the leaf  \\(\\mathbf{L_{new}} =  \\mathbf{H_{leaf}}(  \\text{RK}_{\\mathbf{new}} \\| \\text{HV}_{\\mathbf{new}})\\), </li> <li>Also computes  \\(\\mathbf{B_{new}} =  \\mathbf{H_{noleaf}} ( \\mathbf{{S}_{\\mathbf{ab}}} \\| \\mathbf{L_{new}})\\), </li> <li>And computes  \\(\\mathbf{{root}_{new}} =  \\mathbf{H_{noleaf}} ( \\mathbf{B_{new}} \\| \\mathbf{L_{c}} )\\).</li> </ol> <p>An UPDATE of these values; the branch \\(\\mathbf{B_{ab0}}\\) to \\(\\mathbf{B_{new}}\\) and the old root \\(\\mathbf{{root}_{ab0c}}\\) to \\(\\mathbf{{root}_{new}}\\); completes the CREATE operation.</p> <p>Note that inserting a new key-value pair at a zero node does not change the topology of the tree.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#case-2-new-key-navigates-to-a-non-zero-leaf","title":"Case 2: New Key Navigates To A Non-Zero Leaf","text":"<p>That is, the first \\(\\mathbf{l}\\) least-significant bits of the key \\(\\mathbf{K_{new}}\\) leads to a non-zero leaf \\(\\mathbf{L_z}\\), where \\(\\mathbf{l}\\) is \\(\\mathbf{L_z}\\)'s number of levels to root. This means, the keys \\(\\mathbf{K_{new}}\\) and \\(\\mathbf{K_{z}}\\) share a common string of least-significant key-bits, which is \\(\\mathbf{l}\\) bits long.</p> <p>Step 1: Checking Leaf Inclusion</p> <p>The first step is to double-check that indeed the value \\(V_\\mathbf{z}\\) stored at the leaf \\(\\mathbf{L_z}\\) is indeed included in the root. </p> <p>That is, the verifier performs a Merkle proof starting with either \\(\\mathbf{H_{noleaf}} ( \\mathbf{S_1} \\| \\mathbf{L_z} )\\) or \\(\\mathbf{H_{noleaf}} ( \\mathbf{L_z} \\| \\mathbf{S_1} )\\), for some sibling \\(\\mathbf{S_1}\\). The ordering of the hash arguments depends on whether the sibling of the leaf \\(\\mathbf{L_z}\\) is on the left (the edge corresponding to a key-bit \\(0\\)) or on the right (the edge corresponding to a key-bit \\(1\\)), respectively. The check of value-inclusion gets completed by climbing the tree as usual.</p> <p>Once it is established that the value \\(V_\\mathbf{z}\\) stored at the leaf \\(\\mathbf{L_z}\\) is included in the root, the new leaf \\(\\mathbf{L_{new}}\\) storing the key-value pair can now be created. </p> <p>Step 2: Extending The SMT </p> <p>Since it is not permissible for two distinct non-zero leaves, \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_z}\\), to share a tree-address, a CREATE Operation at \\(\\mathbf{L_z}\\) results in extending the tree; by adding a new branch \\(\\mathbf{B_{ext1}}\\) at the tree-address where \\(\\mathbf{L_z}\\) has been positioned.</p> <p>As discussed earlier in this document, when building binary SMTs, the aim is to find a tree-address for the new leaf \\(\\mathbf{L_{new}}\\) which differs from the tree-address of any existing leaf \\(\\mathbf{L_z}\\).</p> <p>So then, for as long as the next corresponding key-bits between \\(\\mathbf{K_{new}}\\) and \\(\\mathbf{K_{z}}\\) coincide, a new extension branch needs to be formed.</p> <p>Here's the general procedure; </p> <ol> <li>Start with the next least-significant key-bits, \\(\\text{kb}_\\mathbf{(l+1)new}\\) and \\(\\text{kb}_\\mathbf{(l+1)z}\\) , and check if  \\(\\text{kb}_\\mathbf{(l+1)new} = \\text{kb}_\\mathbf{(l+1)z}\\) or not.</li> <li>If they are not the same (i.e., if \\(\\text{kb}_\\mathbf{(l+1)new} \\neq \\text{kb}_\\mathbf{(l+1)z}\\)), then one new extension branch \\(\\mathbf{B_{ext1}}\\) with \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{z}}\\) as its child-nodes, suffices.</li> <li>But, if \\(\\text{kb}_\\mathbf{(l+1)new} = \\text{kb}_\\mathbf{(l+1)z}\\) , then another extension branch \\(\\mathbf{B_{ext2}}\\) needs to be formed. And, the first extension branch \\(\\mathbf{B_{ext1}}\\) is made a parent-node to both \\(\\mathbf{B_{ext2}}\\) and a NULL node \"\\(\\mathbf{0}\\)\". The key-bit \\(\\text{kb}_\\mathbf{(l+1)new}\\) determines whether the NULL node \"\\(\\mathbf{0}\\)\" is on the left or the right.</li> <li>One then continues with the next least-significant key-bits, \\(\\text{kb}_\\mathbf{(l+2)new}\\) and \\(\\text{kb}_\\mathbf{(l+2)z}\\), and checks if \\(\\text{kb}_\\mathbf{(l+2)new} = \\text{kb}_\\mathbf{(l+2)z}\\) or not.</li> <li>If \\(\\text{kb}_\\mathbf{(l+2)new} \\neq \\text{kb}_\\mathbf{(l+2)z}\\) , then the second extension branch \\(\\mathbf{B_{ext2}}\\), with \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{z}}\\) as its child-nodes, completes the CREATE operation.</li> <li>However, if \\(\\text{kb}_\\mathbf{(l+2)new} = \\text{kb}_\\mathbf{(l+2)z}\\) , then a third extension branch \\(\\mathbf{B_{ext3}}\\) is formed. And, as before, the second extension branch \\(\\mathbf{B_{ext2}}\\) is made a parent-node to both \\(\\mathbf{B_{ext3}}\\) and a NULL node \"\\(\\mathbf{0}\\)\". And similarly, the key-bit \\(\\text{kb}_\\mathbf{(l+2)new}\\) determines whether the NULL node \"\\(\\mathbf{0}\\)\" is on the left or the right.</li> <li>This procedure (of extending the tree) continues until, \\(\\text{kb}_\\mathbf{(l+j)new} \\neq \\text{kb}_\\mathbf{(l+j)z}\\) for some \\(j &gt; 2\\). In which case, the \\(\\mathbf{(l + j)}\\)-th extension branch \\(\\mathbf{B_{ext(l + j)}}\\), with the  \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{z}}\\) as its child-nodes, completes the CREATE operation.</li> </ol> <p>Step 3: UPDATE of Values</p> <p>The CREATE Operation is actually only complete once all the values on the navigation path from the new root to the new leaf are updated.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-8-create-operation-with-a-single-branch-extension","title":"Example 8. CREATE Operation with a Single Branch Extension","text":"<p>Suppose a leaf needs to be created to store a new key-value pair \\(\\big({K_{\\mathbf{new}}\\ } , V_\\mathbf{{new}}\\big)\\), where \\(K_{\\mathbf{new}} = 11010110\\). </p> <p>Consider the SMT shown in Figure 13(a) below.</p> <p>In this example, navigation using the least-significant key-bits, \\(\\text{kb}_\\mathbf{0} = 0\\) and \\(\\text{kb}_\\mathbf{1} = 1\\), leads to an existing leaf \\(\\mathbf{L_{\\mathbf{c}}}\\). And the key-value pair \\((V_\\mathbf{\\mathbf{c}}, \\text{HV}_\\mathbf{\\mathbf{c}})\\) stored at \\(\\mathbf{L_{\\mathbf{c}}}\\) has the key \\(K_{\\mathbf{c}} = 11010010\\).</p> <p>Value-Inclusion Check</p> <p>A value-inclusion check of \\(V_\\mathbf{\\mathbf{c}}\\) is performed before creating any new leaf. Since this amounts to a READ Operation, which has been illustrated in previous examples, we omit how this is done here. </p> <p>Once \\(V_\\mathbf{\\mathbf{c}}\\) passes the check, the CREATE Operation continues by inserting the new leaf. </p> <p>New Leaf Insertion</p> <p>In this example, the new leaf \\(\\mathbf{L_{new}}\\) cannot be inserted at the key-address <code>01</code> where \\(\\mathbf{L_{\\mathbf{c}}}\\) is positioned. A branch extension \\(\\mathbf{{B}_{ext}}\\) must therefore be done at the address <code>01</code> with the leaves \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{c}}\\) as child-nodes.</p> <p>Since the third least-significant key-bits of \\(K_{\\mathbf{new}}\\) and \\(K_{\\mathbf{c}}\\) are not the same, \\(\\text{kb}_\\mathbf{2new} = 1\\) and \\(\\text{kb}_\\mathbf{2c} = 0\\), the addresses <code>110</code> and <code>010</code> of the leaves \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{c}}\\), respectively, are distinct.</p> <p>Therefore, no further extension is necessary. And the CREATE Operation is complete by updating all the values on the navigation path.</p> <p></p>  Figure 13(a): CREATE Operation - Non-zero Leaf Node  <p>The next process, after forming the branch extension, is to UPDATE all the nodes along the path from the root to the new leaf \\(\\mathbf{L_{new}}\\). The verifier follows the steps of the UPDATE operation to accomplish this. </p> <p>UPDATE of SMT Values </p> <p>The verifier computes the following,</p> <ol> <li>The hashed value, \\(\\text{HV}_{\\mathbf{new}} = \\mathbf{H_{noleaf}}(V_\\mathbf{new})\\), </li> <li>The new leaf,  \\(\\mathbf{L_{new}} = \\mathbf{H_{leaf}} ( \\text{RK}_{\\mathbf{new}} \\| \\text{HV}_{\\mathbf{new}})\\), </li> <li>Then,  \\(\\mathbf{B_{ext}} = \\mathbf{H_{noleaf}} ( \\mathbf{L_{c}} \\| \\mathbf{L_{new}})\\), </li> <li>Again,  \\(\\mathbf{B_{new}} = \\mathbf{H_{noleaf}}( \\mathbf{S_{ab}} \\| \\mathbf{B_{ext}} )\\), </li> <li>And finally computes,  \\(\\mathbf{{root}_{new}} = \\mathbf{H_{noleaf}}( \\mathbf{B_{new}} \\| \\mathbf{L_{d}} )\\).</li> </ol> <p>This illustrates how the CREATE Operation is performed at a non-zero leaf, when only one branch extension is required.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-9-create-operation-with-multiple-branch-extensions","title":"Example 9. CREATE Operation with Multiple Branch Extensions","text":"<p>This example provides an illustration of the CREATE Operation at a non-zero leaf, where more than one branch extensions are required.</p> <p>Suppose a leaf must be created to store a new key-value pair \\(\\big(K_{\\mathbf{new}}, V_\\mathbf{new}\\big)\\), where \\(K_{\\mathbf{new}} = 11010110\\).</p> <p>Consider the SMT shown in Figure 13(b) below.</p> <p>Navigating the tree by using the least-significant key-bits, \\(\\text{kb}_\\mathbf{0} = 0\\) and \\(\\text{kb}_\\mathbf{1} = 1\\), leads to an existing leaf \\(\\mathbf{L_{\\mathbf{c}}}\\). In this example, suppose the key-value pair \\((K_{\\mathbf{c}} , \\text{HV}_\\mathbf{\\mathbf{c}})\\) stored at \\(\\mathbf{L_{\\mathbf{c}}}\\) has the key \\(K_{\\mathbf{c}} = 11100110\\).</p> <p>Value-Inclusion Check</p> <p>Before creating the new leaf, it is important to first check if \\(V_\\mathbf{\\mathbf{c}}\\) is indeed included in the root, \\(\\mathbf{root}_\\mathbf{abcd}\\). Since this amounts to performing a READ Operation, which has been illustrated in previous examples, we omit here how this is done. </p> <p>Once \\(V_\\mathbf{\\mathbf{c}}\\) passes the value-inclusion check, the CREATE Operation proceeds with inserting the new leaf. </p> <p>New Leaf Insertion</p> <p>Note that the first and second least-significant key-bits for both \\(K_\\mathbf{new}\\) and \\(K_\\mathbf{c}\\) are the same.  That is, \\(\\text{kb}_\\mathbf{0new} = 0 = \\text{kb}_\\mathbf{0c}\\) and \\(\\text{kb}_\\mathbf{1new} = 1 = \\text{kb}_\\mathbf{1c}\\).</p> <p>As a result, the new leaf \\(\\mathbf{L_{new}}\\) cannot be inserted at the key-address <code>01</code>, where \\(\\mathbf{L_{\\mathbf{c}}}\\) is positioned. An extension branch \\(\\mathbf{{B}_{ext1}}\\) is formed at the tree-address <code>01</code>. </p> <p>But, can the leaves \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{c}}\\) be child-nodes to \\(\\mathbf{{B}_{ext1}}\\)?</p> <p>Since the third least-significant key-bits of \\(K_\\mathbf{new}\\) and \\(K_\\mathbf{c}\\) are the same; that is, \\(\\text{kb}_\\mathbf{2new} = 1 = \\text{kb}_\\mathbf{2c}\\); leaves \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{c}}\\) cannot be child-nodes to \\(\\mathbf{{B}_{ext1}}\\).</p> <p>Another extension branch \\(\\mathbf{{B}_{ext2}}\\) is formed at the tree-address <code>011</code>.</p> <p>Again, since the fourth least-significant key-bits of \\(K_\\mathbf{new}\\) and \\(K_\\mathbf{c}\\) are the same;  \\(\\text{kb}_\\mathbf{3new} = 0 = \\text{kb}_\\mathbf{3c}\\) ; the leaves \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{c}}\\) cannot be child-nodes to \\(\\mathbf{{B}_{ext2}}\\).</p> <p>A third extension branch \\(\\mathbf{{B}_{ext3}}\\) is needed at the tree-address <code>0110</code>.</p> <p>In this case, the fifth least-significant key-bits of \\(K_\\mathbf{new}\\) and \\(K_\\mathbf{c}\\) are different; i.e.,  \\(\\text{kb}_\\mathbf{4new} = 1\\) and \\(\\text{kb}_\\mathbf{4c} = 0\\). </p> <p>The leaves \\(\\mathbf{L_{new}}\\) and \\(\\mathbf{L_{c}}\\) are now made child-nodes of the extension branch \\(\\mathbf{{B}_{ext3}}\\). See Figure 13(b) below.</p> <p></p>  Figure 13(b): CREATE Operation - Three Branch Extensions  <p>Once unique addresses for the key-value pairs \\(\\big( K_{\\mathbf{c}} , V_\\mathbf{c} \\big)\\) and \\(\\big( K_\\mathbf{{new}} , V_{\\mathbf{new}}\\big)\\)  are reached, and the leaf \\(\\mathbf{L_{new}}\\) is inserted, all the nodes along the navigation path from the new leaf \\(\\mathbf{L_{new}}\\) to the root are updated as follows. </p> <p>The verifier computes,</p> <ol> <li>The hash of the new value, \\(\\text{HV}_\\mathbf{new} = \\mathbf{H_{noleaf}}(V_\\mathbf{new})\\),</li> <li>The new leaf,  \\(\\mathbf{L_{new}} = \\mathbf{H_{leaf}} ( \\text{RK}_{\\mathbf{new}} \\| \\text{HV}_{\\mathbf{new}})\\), </li> <li>Then,  \\(\\mathbf{B_{ext3}} = \\mathbf{H_{noleaf}}( \\mathbf{L_{c}} \\| \\mathbf{L_{new}})\\), </li> <li>Followed by \\(\\mathbf{B_{ext2}} = \\mathbf{H_{noleaf}}( \\mathbf{B_{ext3}}  \\| \\mathbf{0} )\\),</li> <li>And,  \\(\\mathbf{B_{ext1}} = \\mathbf{H_{noleaf}}( \\mathbf{0} \\| \\mathbf{B_{ext2}} )\\),</li> <li>Again,  \\(\\mathbf{B_{new}} = \\mathbf{H_{noleaf}}( \\mathbf{S_{ab}} \\| \\mathbf{B_{ext2}} )\\), </li> <li>And finally computes,  \\(\\mathbf{{root}_{new}} = \\mathbf{H_{noleaf}}( \\mathbf{B_{new}} \\| \\mathbf{L_{d}} )\\).</li> </ol> <p>This completes the CREATE operation at an existing leaf where several branch extensions are needed. </p> <p>The CREATE operation at a non-leaf node clearly changes the topology of the tree.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-deleteremove-operation","title":"The DELETE/REMOVE Operation","text":"<p>The DELETE Operation refers to a removal of a certain key-value pair from a binary SMT. It is in fact the reverse of the CREATE Operation.</p> <p>There are two types of scenarios that can occur when executing a DELETE Operation.</p> <p>There is a scenario where a DELETE Operation is equivalent to an UPDATE Operation of a non-zero leaf to a NULL leaf. In this case the topology of the SMT does not change. This occurs when the leaf being deleted has a non-zero sibling-node.</p> <p>On the other hand, a DELETE Operation can be tantamount to the reverse of a CREATE Operation where extension branches are removed from the tree. The topology of the SMT can drastically change. This scenario occurs when the leaf being removed has a zero sibling-node.</p> <p>A DELETE Operation involves two main steps;</p> <p>Step 1: A READ of the value to be deleted is executed. That is; </p> <p>\u200b   (a) Navigating to the value, </p> <p>\u200b   (b) Checking if the value is included in the root, and </p> <p>\u200b   (c) Checking if the given key (reconstructed from the given Remaining Key and the least-significant key-bits) matches the key at the leaf (reconstructed from the Remaining Key found at the leaf and the given key-bits).</p> <p>Step 2: This step depends on whether the sibling of the leaf to be deleted is zero or not; </p> <p>\u200b   (a) If the sibling is not a zero node, an UPDATE to a zero is performed.</p> <p>\u200b   (b) If the sibling is a zero-node, an UPDATE to a zero is performed and the parent-node is turned into a NULL node with no child-nodes.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#case-1-delete-operation-leaves-with-non-zero-siblings","title":"Case 1: DELETE Operation - Leaves With Non-Zero Siblings","text":"<p>Consider a DELETE of a key-value pair \\(\\big(K_{\\mathbf{b}} , V_\\mathbf{b} \\big)\\) where its leaf \\(\\mathbf{L_b}\\) has a non-zero node sibling.</p> <p>Suppose the data provided includes; the Remaining Key \\(\\tilde{\\text{RK}}_{\\mathbf{b}}\\), the least-significant key-bits \\(\\text{kb}_0 = 0\\) and \\(\\text{kb}_1 = 1\\), the root \\(\\mathbf{{root}_{abc}}\\), and the sibling \\(\\mathbf{L_a}\\) which is not a zero node and the leaf \\(\\mathbf{L_c}\\).</p> <p>With reference to Figure 14(a) below, navigation leads to the leaf \\(\\mathbf{L_b}\\).</p> <p>Next, perform a Merkle proof to check if the hashed value \\(\\text{HV}_\\mathbf{b}\\) at \\(\\mathbf{L_b}\\) is included in the given root;</p> <ul> <li>Compute \\(\\tilde{\\mathbf{L}}_\\mathbf{b} = \\mathbf{H_{leaf}} ( \\text{RK}_{\\mathbf{b}} \\| \\text{HV}_\\mathbf{b} )\\) </li> <li>Then \\(\\tilde{\\mathbf{B}}_\\mathbf{ab} = \\mathbf{H_{noleaf}} ( \\mathbf{L_a} \\| \\tilde{\\mathbf{L}}_\\mathbf{b})\\)</li> <li>And,  \\(\\tilde{\\mathbf{root}}_\\mathbf{abc} = \\mathbf{H_{noleaf}} ( \\tilde{\\mathbf{B}}_\\mathbf{ab}  \\| \\mathbf{L_c} )\\)</li> <li>Check if \\(\\tilde{\\mathbf{root}}_\\mathbf{abc}\\) equals \\(\\mathbf{{root}_{abc}}\\).</li> </ul> <p>Simultaneously, check if \\(\\tilde{K}_{\\mathbf{b}}\\) equals \\(\\text{K}_{\\mathbf{b}}\\), where \\(\\tilde{K}_{\\mathbf{b}} =  \\tilde{\\text{RK}}_{\\mathbf{b}} \\| \\text{kb}_1 \\| \\text{kb}_0\\)  and  \\(\\text{K}_{\\mathbf{b}} =   \\text{RK}_{\\mathbf{b}} \\| \\text{kb}_1 \\| \\text{kb}_0\\)  are keys reconstructed while climbing the tree.</p> <p>Since the sibling \\(\\mathbf{L_a}\\) is not a zero node, the hashed value \\(\\text{HV}_\\mathbf{b}\\) found at the leaf \\(\\mathbf{L_b}\\) is updated to a zero. And the values along the navigation path are also updated accordingly. That is,</p> <ul> <li>The leaf \\(\\mathbf{L_b}\\) is set to \"\\(\\mathbf{0}\\)\", a zero node.</li> <li>The parent-node is now, \\(\\mathbf{B_{a0}} = \\mathbf{H_{noleaf}} ( \\mathbf{L_a} \\| \\mathbf{0} )\\).</li> <li>And, the new root, \\(\\mathbf{{root}_{abc}} =   \\mathbf{H_{noleaf}}(\\mathbf{B_{a0}} \\| \\mathbf{L_a})\\). </li> </ul> <p>See the above DELETE Operation illustrated in Figure 13(a) below, and notice how the SMT maintains its original shape. </p> <p></p>  Figure 14(a): DELETE Operation - Non-Zero Sibling"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#case-2-delete-operation-leaves-with-zero-siblings","title":"Case 2: DELETE Operation - Leaves With Zero Siblings","text":"<p>Consider deleting a key-value pair \\(\\big(K_{\\mathbf{c}} , V_\\mathbf{c} \\big)\\) where its leaf \\(\\mathbf{L_c}\\) has a zero-node sibling.</p> <p>As in Case 1 above, suppose the data provided includes; the Remaining Key \\(\\tilde{\\text{RK}}_{\\mathbf{c}}\\), the least-significant key-bits \\(\\text{kb}_0 = 0\\), \\(\\text{kb}_1 = 1\\) and \\(\\text{kb}_2 = 1\\), the root \\(\\mathbf{{root}_{a0cd}}\\), and the sibling \"\\(\\mathbf{0}\\)\" which is a zero node, and the leaves \\(\\mathbf{L_a}\\) and \\(\\mathbf{L_d}\\).</p> <p>With reference to Figure 14(b) below, navigation leads to the leaf \\(\\mathbf{L_c}\\).</p> <p>The READ step in this case is similar to what is seen in Case 1. </p> <p>The UPDATE step depends on the sibling of \\(\\mathbf{L_c}\\). Since the sibling is \"\\(\\mathbf{0}\\)\", an UPDATE of \\(\\mathbf{L_c}\\) to zero results in the branch \\(\\mathbf{B_{0c}}\\) having two zero nodes as child-nodes. Since \\(\\mathbf{H_{noleaf}} ( \\mathbf{0} \\| \\mathbf{0}) = 0\\) , it is therefore expedient to turn the branch \\(\\mathbf{B_{0c}}\\) into a zero node with no child-nodes. </p> <p>That is, the UPDATE step of this DELETE Operation concludes as follows;</p> <ul> <li>The original branch \\(\\mathbf{B_{0c}}\\) is now \"\\(\\mathbf{0}\\)\", a zero node.</li> <li>The parent-node is now, \\(\\mathbf{B_{a0}} = \\mathbf{H_{noleaf}} ( \\mathbf{L_a} \\| \\mathbf{0}  )\\).</li> <li>And, the new root, \\(\\mathbf{{root}_{a0d}} =   \\mathbf{H_{noleaf}}(\\mathbf{B_{a0}} \\| \\mathbf{L_d})\\). </li> </ul> <p>Notice that, in this example, the DELETE Operation alters the topology of the SMT, as seen in Figure 13(b) below.</p> <p></p>  Figure 14(b): DELETE Operation - Zero Sibling"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#concluding-basic-operations","title":"Concluding Basic Operations","text":"<p>The operations discussed in this section are in fact the very actions the Main State Machine will instruct the Storage State Machine to perform.</p> <p>The 'prover' and the 'verifier', as used in the above explanations, can loosely be interpreted as the Executor of the Storage State Machine and the Storage SM's PIL code, respectively. The zero-knowledge Assembly (zkASM) of the Storage SM plays the facilitator's role. The zkASM is the interpreter between the Storage SM and the Main State Machine, also between the Storage SM and the POSEIDON State Machine. </p> <p>The two hash functions used in building the Storage binary SMTs, are special versions of the POSEIDON family of hash functions.</p> <p>What's left is specifying parameters such as the actual key-length used in the Storage State Machine, how keys and paths are created, as well as cryptographic primitives utilised like the exact POSEIDON hash functions.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#zkprover-storage-parameters","title":"zkProver Storage Parameters","text":"<p>In the Storage SM, the keys and values are strings of 256 bits.</p> <p>Keys will henceforth be represented as 256-bit unsigned integers, which are quadruples of 64-bit field elements; e.g., \\(\\text{Key}_{\\mathbf{0123}} = \\big( \\text{Key}_{\\mathbf{0}} , \\text{Key}_{\\mathbf{1}} , \\text{Key}_{\\mathbf{2}} , \\text{Key}_{\\mathbf{3}} \\big)\\), where each \\(\\text{Key}_{\\mathbf{i}} \\in \\mathbb{F}_p\\), where  \\(p = 2^{64} - 2^{32} + 1\\). </p> <p>Although hashed-values are also 256-bit long and are used in quadruple form, 'committed' values are 256-bit long and are often expressed as octets. It is mainly due to the POSEIDON SM convention, where 256-bit committed values are input as, \\(\\text{V}_{\\mathbf{01..7}} = \\big( \\text{V}_{\\mathbf{0}} , \\text{V}_{\\mathbf{1}} , \\text{V}_{\\mathbf{2}} , \\dots , \\text{V}_{\\mathbf{7}} \\big)\\), and each 32-bit \\(V_{\\mathbf{j}}\\) chunk of bits.</p> <p>In fact, almost every other 256-bit value in the Storage is expressed in the form of a quadruple of 64-bit field elements.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#creating-keys-and-paths","title":"Creating Keys And Paths","text":""},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#how-keys-are-created","title":"How Keys Are Created","text":"<p>In the key-value pair SMT context of our storage design, a key uniquely identifies a leaf. And it is because, although values can change, keys do not. </p> <p>Keys must consequently be generated deterministically, and in such a way that there are no collisions. That is, there must be a one-to-correspondence between keys and leaves.</p> <p>A collision-resistant hash function is therefore the best tool for generating keys. And the most convenient way to generate keys is by hashing some specific information so that the resultant hash uniquely identifies the leaf. The specific Information used for generating keys is the Ethereum Address and some constant. The \\(\\text{POSEIDON}\\) Hash is again used for this purpose.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#constructing-navigation-paths","title":"Constructing Navigation Paths","text":"<p>A path refers to the edges traversed from the root to a leaf. Since the SMTs are binary, all edges can be thought of, as labelled with either a bit \"0\" or \"1\"; Edges to the left labelled with a bit \"0\", while edges to the right are labelled with a bit \"1\".</p> <p>Paths are therefore strings of bits, and are derived from keys in a very specific way.</p> <p>First of all, every key can be thought of as a quadruple, \\(\\text{Key}_{\\mathbf{0123}} = \\big( \\text{Key}_{\\mathbf{0}} , \\text{Key}_{\\mathbf{1}} , \\text{Key}_{\\mathbf{2}} , \\text{Key}_{\\mathbf{3}} \\big) \\in \\mathbb{F}_{p}^4\\). Denote each key part \\(\\text{Key}_{\\mathbf{i}}\\) bit-wise as, </p> \\[\\begin{aligned} \\text{Key}_{\\mathbf{0}} = k_{\\mathbf{0,63}\\ } k_{\\mathbf{0,62}\\ } \\dots k_{\\mathbf{0,2}\\ } k_{\\mathbf{0,1}\\ } k_{\\mathbf{0,0} },\\ \\ \\text{Key}_{\\mathbf{1}} = k_{\\mathbf{1,63}\\ } k_{\\mathbf{1,62}\\ } \\dots k_{\\mathbf{1,2}\\ } k_{\\mathbf{1,1}\\ } k_{\\mathbf{1,0} }, \\\\\\text{Key}_{\\mathbf{2}} = k_{\\mathbf{2,63}\\ } k_{\\mathbf{2,62}\\ } \\dots k_{\\mathbf{2,2}\\ } k_{\\mathbf{2,1}\\ } k_{\\mathbf{2,0} },\\ \\ \\text{Key}_{\\mathbf{3}} = k_{\\mathbf{3,63}\\ } k_{\\mathbf{3,62}\\ } \\dots k_{\\mathbf{3,2}\\ } k_{\\mathbf{3,1}\\ } k_{\\mathbf{3,0} }, \\end{aligned}\\] <p>where the most-significant bit \\(\\text{MSB}(\\text{Key}_{\\mathbf{i}}) = k_{\\mathbf{i,63}\\ }\\) and the least-significant bit \\(\\text{LSB}(\\text{Key}_{\\mathbf{i}}) = k_{\\mathbf{i,0}}\\), for each  \\(\\mathbf{i} \\in \\{ \\mathbf{0}, \\mathbf{1}, \\mathbf{2}, \\mathbf{3} \\}\\).</p> <p>The Navigation Path to the leaf corresponding to the key \\(\\text{Key}_{\\mathbf{0123}}\\) is defined as the following string of shuffled key-bits;</p> \\[\\begin{aligned} k_{\\mathbf{0,0}\\ } k_{\\mathbf{1,0}\\ } k_{\\mathbf{2,0}\\ } k_{\\mathbf{3,0}\\ } k_{\\mathbf{0,1}\\ } k_{\\mathbf{1,1}\\ } k_{\\mathbf{2,1}\\ } k_{\\mathbf{3,1}\\ } k_{\\mathbf{0,2}\\ } k_{\\mathbf{1,2}\\ } k_{\\mathbf{2,2}\\ } k_{\\mathbf{3,2}\\ }\\\\   \\dots k_{\\mathbf{0,62}\\ }  k_{\\mathbf{1,62}\\ } k_{\\mathbf{2,62}\\ }  k_{\\mathbf{3,62}\\ }  k_{\\mathbf{0,63}\\ } k_{\\mathbf{1,63}\\ } k_{\\mathbf{2,63}\\ } k_{\\mathbf{3,63} }. \\end{aligned}\\] <p>That is, the Navigation Path to the leaf corresponding to \\(\\text{Key}_{\\mathbf{0123}}\\) is the string of bits composed of;</p> <ul> <li>The least-significant bits of the four key parts, \\(\\text{Key}_{\\mathbf{0}} , \\text{Key}_{\\mathbf{1}} , \\text{Key}_{\\mathbf{2}} , \\text{Key}_{\\mathbf{3}}\\), appearing in the order of the key parts as: \\(k_{\\mathbf{0,0}\\ } k_{\\mathbf{1,0}\\ } k_{\\mathbf{2,0}\\ } k_{\\mathbf{3,0}}\\).</li> <li>Followed by the second least-significant bits of the four key parts, \\(\\text{Key}_{\\mathbf{0}} , \\text{Key}_{\\mathbf{1}} , \\text{Key}_{\\mathbf{2}} , \\text{Key}_{\\mathbf{3}}\\), appearing in the order of the key parts as: \\(k_{\\mathbf{0,1}\\ } k_{\\mathbf{1,1}\\ } k_{\\mathbf{2,1}\\ } k_{\\mathbf{3,1}}\\). </li> <li>Then the third least-significant bits of the four key parts, \\(\\text{Key}_{\\mathbf{0}} , \\text{Key}_{\\mathbf{1}} , \\text{Key}_{\\mathbf{2}} , \\text{Key}_{\\mathbf{3}}\\), appearing in the order of the key parts as: \\(k_{\\mathbf{0,2}\\ } k_{\\mathbf{1,2}\\ } k_{\\mathbf{2,2}\\ } k_{\\mathbf{3,2}}\\).</li> <li>Up until the most-significant bits of the four key parts, \\(\\text{Key}_{\\mathbf{0}} , \\text{Key}_{\\mathbf{1}} , \\text{Key}_{\\mathbf{2}} , \\text{Key}_{\\mathbf{3}}\\), appearing in the order of the key parts as: \\(k_{\\mathbf{0,63}\\ } k_{\\mathbf{1,63}\\ } k_{\\mathbf{2,63}\\ } k_{\\mathbf{3,63} }\\).</li> </ul> <p></p>  Figure 15 : Navigation Path Derivation  <p>Note that, this construction ensures that in every quadruplet of consecutive path-bits there is a one-to-one correspondence between the bits and the four parts of the key, \\(\\text{Key}_{\\mathbf{0}} , \\text{Key}_{\\mathbf{1}} , \\text{Key}_{\\mathbf{2}} , \\text{Key}_{\\mathbf{3}}\\). </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#reconstructing-the-key-from-path-bits","title":"Reconstructing The Key From Path-Bits","text":"<p>When executing a basic operation such as an UPDATE of a value at a leaf, one has to reconstruct the key from the remaining key found at the leaf and the path-bits spent in navigating to the leaf.</p> <p>Denote the remaining key as a quadruple,  \\(\\text{RKey}_{\\mathbf{0123}} = \\big( \\text{RKey}_{\\mathbf{0}} , \\text{RKey}_{\\mathbf{1}} , \\text{RKey}_{\\mathbf{2}} , \\text{RKey}_{\\mathbf{3}} \\big)\\)</p> <p>Since the Path was constructed by shuffling key-bits from the four parts, \\(\\text{Key}_{\\mathbf{0}}\\), \\(\\text{Key}_{\\mathbf{1}}\\), \\(\\text{Key}_{\\mathbf{2}}\\), \\(\\text{Key}_{\\mathbf{3}}\\), one would expect the reverse-process (going from the Path-bits to the original key) to work just as easily. </p> <p>Perhaps taking the level \\(\\text{lvl}\\) of a leaf and reducing it modulo 4, should be sufficient to tell which part of the Remaining Key, \\(\\text{RKey}_{\\mathbf{i}}\\), must the Path key-bit be appended to.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#example-key-reconstruction","title":"Example. Key Reconstruction","text":"<p>Suppose the leaf storing the key-value pair \\(\\big( \\text{Key}_{\\mathbf{0123}}, \\text{V}_{\\mathbf{01..7}}  \\big)\\) is reached at level 7, the path-bits used are \\(0110101\\), and the remaining key is \\(\\text{RKey}_{\\mathbf{0123}} = \\big( \\text{RKey}_{\\mathbf{0}} , \\text{RKey}_{\\mathbf{1}} , \\text{RKey}_{\\mathbf{2}} , \\text{RKey}_{\\mathbf{3}} \\big)\\).</p> <p>That is, the path-bits are  \\(\\text{path-bit}_6 = 1\\), \\(\\text{path-bit}_5 = 0\\), \\(\\text{path-bit}_4 = 1\\), \\(\\text{path-bit}_3 = 0\\), \\(\\text{path-bit}_2 = 1\\), \\(\\text{path-bit}_1 = 1\\) and \\(\\text{path-bit}_0 = 0\\).</p> <p>So, in order to place \\(\\text{path-bit}_6\\), one first computes \\(7 \\text{ modulo } 4\\) to get \\(3\\). Hence, the \\(\\text{key-bit}_6\\) must be appended to the third key part, \\(\\text{RKey}_{\\mathbf{2}}\\).</p> <p>Next, one climbs the tree to level \\(6\\), where \\(\\text{path-bit}_5 = 0\\). One then computes \\(6 \\text{ modulo } 4\\) and gets \\(2\\). The \\(\\text{path-bit}_5\\) must then be appended to the second key part, \\(\\text{RKey}_{\\mathbf{1}}\\).</p> <p>Again, one climbs the tree to level \\(5\\), where \\(\\text{path-bit}_4 = 1\\). Computing  \\(5 \\text{ modulo } 4\\)  yields \\(1\\). The \\(\\text{path-bit}_4\\) is thence appended to the first key part, \\(\\text{RKey}_{\\mathbf{0}}\\).</p> <p>One then continues in the same fashion; </p> <p>\\(\\text{Climbs the tree to level } 4. \\text{ Computes }\\ 4 \\text{ modulo } 4 = 0. \\text{ Appends path-bit to the fourth part, } \\text{RKey}_{\\mathbf{3}}.\\) \\(\\text{Climbs the tree to level } 3. \\text{ Computes }\\ 3 \\text{ modulo } 4 = 3. \\text{ Appends path-bit to the third part, } \\text{RKey}_{\\mathbf{2}}.\\)\\(\\text{Climbs the tree to level } 2. \\text{ Computes }\\ 2 \\text{ modulo } 4 = 2. \\text{ Appends path-bit to the second part, } \\text{RKey}_{\\mathbf{1}}.\\) \\(\\text{Climbs the tree to level } 1. \\text{ Computes }\\ 1 \\text{ modulo } 4 = 1. \\text{ Appends path-bit to the first part, } \\text{RKey}_{\\mathbf{0}}.\\)</p> <p>The next climb is to the root. The navigation path-bits have been exhausted, and the last append has actually completed reconstruction of the key.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#leaf-levels-and-integers-modulo-4","title":"Leaf Levels and Integers Modulo 4","text":"<p>It is clear, from the above example, that there is a one-to-one correspondence between the integers modulo 4 (i.e., Elements of the group \\(\\mathbb{Z}_4 = \\{ 0, 1, 2, 3 \\}\\)) and remaining key parts \\(\\text{RKey}_{\\mathbf{0}} , \\text{RKey}_{\\mathbf{1}} , \\text{RKey}_{\\mathbf{2}} , \\text{RKey}_{\\mathbf{3}}\\). </p> <p>That is, there is a mapping;</p> \\[\\begin{aligned} 1 \\mapsto \\text{RKey}_{\\mathbf{0}},\\ \\ 2 \\mapsto \\text{RKey}_{\\mathbf{1}},\\ \\  3 \\mapsto \\text{RKey}_{\\mathbf{2}} \\text{ and }\\ 0 \\mapsto \\text{RKey}_{\\mathbf{3}}. \\end{aligned}\\] <p>The quadruple structure of the path bits and the level of leaves therefore have a homomorphic relationship that can be described in terms of the cyclic group of integers modulo 4,  \\(\\mathbb{Z}_4 = \\{ 0, 1, 2, 3 \\}\\).</p> <p>Since addition modulo n is an expensive computation in the state machine context, it is important to find a more efficient algorithm to achieve the same result.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#alternate-cyclic-group-of-order-4","title":"Alternate Cyclic Group Of Order 4","text":"<p>In order to explore cyclic groups of order 4, take the vector  \\(\\mathbf{x} = (1,0,0,0)\\) , and rotate the components of \\(\\mathbf{x}\\) one position to the left.</p> <p>Note that, rotating   \\(\\mathbf{x} = (1,0,0,0)\\)</p> <ul> <li>once, yields \\((0,0,0,1)\\) </li> <li>twice, one obtains \\((0,0,1,0)\\)</li> <li>thrice, one gets \\((0,1,0,0)\\) </li> <li>four times, and the result is  \\(\\mathbf{x} = (1,0,0,0)\\) </li> </ul> <p>Continuously rotating  \\(\\mathbf{x} = (1,0,0,0)\\)  will not result in any other vector but the four vectors </p> \\[ \\mathbf{G_4} = \\{ (1,0,0,0),\\ (0,0,0,1),\\ (0,0,1,0),\\ (0,1,0,0) \\}. \\] <p>This set of four vectors \\(\\mathbf{G_4}\\) together with the described rotation, form an group. </p> <p>In fact, \\(\\mathbf{G_4}\\) is isomorphic (or homomorphically equivalent) to \\(\\mathbb{Z}_4\\) under \"addition modulo 4\".  That is, there is a natural one-to-one correspondence between the elements of \\(\\mathbb{Z}_4\\) and those of \\(\\mathbf{G_4}\\), as follows; $$ 0 \\mapsto (1,0,0,0),\\ \\ 1 \\mapsto (0,1,0,0),\\ \\ 2 \\mapsto (0,0,1,0)\\  \\text{ and }\\ 3 \\mapsto (0,0,0,1). $$</p> <p>Note that the four numbers \\(0\\), \\(1\\), \\(2\\) and \\(3\\) can be expressed in their binary form with just two bits, and the same one-to-one correspondence holds as;</p> \\[ \\text{00} \\mapsto (1,0,0,0),\\ \\ \\text{01} \\mapsto (0,1,0,0),\\ \\ \\text{10} \\mapsto (0,0,1,0)\\  \\text{ and }\\ \\text{11} \\mapsto (0,0,0,1). \\]"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#a-special-cyclic-register-for-leaf-levels","title":"A Special Cyclic Register For Leaf Levels","text":"<p>Define a register called <code>LEVEL</code> which is vector of four bits, three \"0\" bits and one \"1\" bit. And the operation  <code>ROTATE_LEVEL</code>  which is the left rotation of <code>LEVEL</code>'s bits by one position.</p> <p>If <code>LEVEL</code> is initialised as \\((1,0,0,0)\\), observe that applying <code>ROTATE_LEVEL</code> four times brings <code>LEVEL</code> back to \\((1,0,0,0)\\). That is,  $$ (1,0,0,0) \\to (0,0,0,1)  \\to (0,0,1,0) \\to (0,1,0,0) \\to (1,0,0,0) $$ Therefore, <code>LEVEL</code> is cyclic under <code>ROTATE_LEVEL</code>, and is in fact algebraically the same as the cyclic group \\(\\mathbf{G_4}\\) described above.</p> <p>How is the <code>LEVEL</code> register used in key reconstruction?</p> <p>First note that, when navigating the tree, the leaf level can be indicated by one of the four possible states of the <code>LEVEL</code> register. And this works for all possible leaf levels because, for any positive integer \\(j\\);</p> \\[\\begin{aligned} {\\text{LEVEL}} = (1,0,0,0)\\ \\text{indicates that the leaf level is one of the following};\\ 0, 4, 8, \\dots , 0 + 4j. \\ \\\\ {\\text{LEVEL}} = (0,1,0,0)\\ \\text{indicates that the leaf level is one of the following};\\ 1, 5, 9, \\dots , 1 + 4j. \\ \\\\ {\\text{LEVEL}} = (0,0,1,0)\\ \\text{indicates that the leaf level is one of the following};\\ 2, 6, 10, \\dots, 2 + 4j. \\\\ {\\text{LEVEL}} = (0,0,0,1)\\ \\text{indicates that the leaf level is one of the following};\\ 3, 7, 11, \\dots, 3 + 4j. \\end{aligned}\\] <p>Second, the two least-significant bits of each of these number, when written in binary, are as follows; </p> \\[\\begin{aligned} \\text{Each of these numbers};\\ 0, 4, 8, \\dots , 0 + 4j;\\ \\text{ends with } 00.\\ \\ \\\\ \\text{Each of these numbers};\\ 1, 5, 9, \\dots , 1 + 4j;\\ \\text{ends with } 01.\\ \\ \\\\ \\text{Each of these numbers};\\ 2, 6, 10, \\dots , 2 + 4j; \\text{ends with } 10.\\ \\\\ \\text{Each of these numbers};\\ 3, 7, 11, \\dots , 3 + 4j;\\ \\text{ends with } 11. \\end{aligned}\\] <p>It suffices therefore to only read the two least-significant bits of the leaf level in order to determine the position of the bit \"1\" in the <code>LEVEL</code> register.</p> <p>Third, the position of the bit \"1\" in the <code>LEVEL</code> register tallies precisely with the part of the remaining key, \\(\\text{RKey}_{\\mathbf{i}}\\), to which the last used path-bit came from.</p> <p>So then, when reconstructing the key, one needs only check where the bit \"1\" is in the <code>LEVEL</code> register, because</p> \\[\\begin{aligned} {\\text{LEVEL}} = (1,0,0,0)\\ \\ \\text{means, the last used path bit must be appended to } \\mathbf{RKey_0}.\\\\ {\\text{LEVEL}} = (0,1,0,0)\\ \\ \\text{means, the last used path bit must be appended to } \\mathbf{RKey_1}.\\\\ { \\text{LEVEL}} = (0,0,1,0)\\ \\ \\text{means, the last used path bit must be appended to } \\mathbf{RKey_2}.\\\\ {\\text{LEVEL}} = (0,0,0,1)\\ \\ \\text{means, the last used path bit must be appended to } \\mathbf{RKey_3}. \\end{aligned}\\] <p>Since things are rather mechanical in state machines, one or two more functions are needed. For instance, one for initialising the <code>LEVEL</code> register, and another for reading the position of the bit \"1\".</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-textposeidon-hash","title":"The \\(\\text{POSEIDON}\\) HASH","text":"<p>Poseidon SM is the most straight forward once one understands the internal mechanism of the original Poseidon hash function. The hash function's permutation process translates readily to the Poseidon SM states. </p> <p>The \\(\\text{POSEIDON}\\) State Machine carries out \\(\\text{POSEIDON}\\) Actions in accordance with instructions from the Main SM Executor and requests from the Storage SM. That is, it computes hashes of messages sent from any of the two SMs, and also checks if the hashes were correctly computed.</p> <p>The zkProver uses the goldilocks \\(\\text{POSEIDON}\\) which is defined over the field  \\(\\mathbb{F}_p\\), where  \\(p = 2^{64} - 2^{32} + 1\\).</p> <p>The states of the \\(\\text{POSEIDON}\\) SM coincide with the twelve (12) internal states of the \\(\\text{POSEIDON}^{\\pi}\\) permutation function. These are;  <code>in0</code>, <code>in1</code>, ... , <code>in7</code>, <code>hashType</code>, <code>cap1</code>, <code>cap2</code> and <code>cap3</code>. </p> <p>\\(\\text{POSEIDON}^{\\pi}\\) runs 30 rounds, 3 times. Adding up to a total of 90 rounds. It outputs four (4) hash values; <code>hash0</code>, <code>hash1</code>, <code>hash2</code> and <code>hash3</code>.</p> <p></p>  Figure 16 : POSEIDON HASH0  <p>In the case of the zkProver storage, two slightly different \\(\\text{POSEIDON}\\) hashes are used; \\(\\text{HASH0}\\) is used when a branch node is created, whilst \\(\\text{HASH1}\\) is used when a leaf node is created. This depends on the <code>hashType</code>, which is a boolean. So \\(\\text{POSEIDON}\\) acts as \\(\\text{HASH1}\\) when <code>hashType</code> = 1, and \\(\\text{HASH0}\\) when <code>hashType</code> = 0. </p> <p>Since POSEIDON Hashes outputs \\(4 * \\lfloor(63.99)\\rfloor \\text{ bits} = 252\\), and one bit is needed to encode each direction, the tree can therefore have a maximum of 252 levels.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-storage-state-machines-design-and-mechanism","title":"The Storage State Machine's Design and Mechanism","text":"<p>The Storage SM is practically dual in that it is both a State Machine and a Storage, a database. So, instead of the Main SM having to query the Storage as a database itself (i.e., the Main SM itself carrying out the CRUD operations), the Storage has instead been automised to execute these queries (by turning it into a state machine).</p> <p>Since the design of the Storage part has been extensively described in the foregoing sections (in terms of SMTs), the design of the automation now follows. What follows next is the description of,</p> <ul> <li>how the State Machine part is designed, and</li> <li>how it works (i.e., explaining the internal mechanism of the Storage SM). </li> </ul> <p>The Storage SM is composed of three parts; Storage Assembly code, Storage Executor code, and the Storage PIL code. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-storage-assembly","title":"The Storage Assembly","text":"<p>The Storage Assembly is the interpreter between the Main State Machine and its own Executor. It receives instructions from the Main SM and generates a JSON-file containing the corresponding rules and logic, which are stored in a special ROM for the Storage SM.</p> <p>The Storage SM has a primary Storage Assembly code, storage_sm.zkasm, that maps each instruction of the Main SM (i.e., each Storage Action) to the secondary Assembly code of the corresponding basic operation. These basic operations are mainly the CREATE, READ, UPDATE and DELETE, as discussed in previous sections.</p> <p>Considering some special cases, there are all-in-all eight (8) secondary Storage Assembly codes, each for a distinct basic operation; READ or Get, UPDATE, CREATE new value at a zero node, CREATE new value at found leaf, DELETE leaf with zero sibling, DELETE last non-zero node, DELETE leaf with non-zero sibling, and SET a zero node to zero. See Table 1, below, for the specific names of the secondary codes.</p>  Table 1: SMT Actions And Secondary zkASM Codes  Storage Actions File Names Code Names Action Selectors In Primary zkASM Code READ Get Get isGet() UPDATE Set_Update SU isSetUpdate() CREATE new value at a found leaf Set_InsertFound SIF isSetInsertFound() CREATE new value at a zero node Set_InsertNotFound SINF isSetInsertNotFound() DELETE last non-zero node Set_DeleteLast SDL isSetDeleteLast() DELETE leaf with non-zero sibling Set_DeleteFound SDF isSetDeleteFound() DELETE leaf with zero sibling Set_DeleteNotFound SDNF isSetDeleteNotFound() SET a zero node to zero Set_ZeroToZero SZTZ isSetZeroToZero() <p>Input and ouput states of the Storage SM are literally SMTs, given in the form of; the Merkle roots, the relevant siblings, as well as the key-value pairs.</p> <p>Note that state machines use registers in the place of variables. All values needed, for carrying out the basic operations, are stored by the primary Assembly code in the following registers; </p> <p><code>HASH_LEFT</code>, <code>HASH_RIGHT</code>, <code>OLD_ROOT</code>, <code>NEW_ROOT</code>, <code>VALUE_LOW</code>, <code>VALUE_HIGH</code>, <code>SIBLING_VALUE_HASH</code>, <code>RKEY</code>, <code>SIBLING_RKEY</code>, <code>RKEY_BIT</code>, <code>LEVEL</code>.</p> <p>The <code>SIBLING_VALUE_HASH</code> and <code>SIBLING_RKEY</code> registers are only used by the <code>Set_InsertFound</code> and the <code>Set_DeleteFound</code> secondary Assembly codes. The rest of the registers are used in all the secondary Assembly codes. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#smt-action-selectors-in-the-primary-assembly-code","title":"SMT Action Selectors In The Primary Assembly Code","text":"<p>How does the primary Assembly code map the Main SM instructions to the relevant Storage Actions?  </p> <p>It uses selectors. Like switches can either be ON or OFF, selectors can either be 1 or 0, where 1 means the action is selected for execution, while 0 means the instruction does not tally with the required action so a \"jump if zero\" <code>JMPZ</code> is applied.</p> <p>The primary Assembly code uses selectors by following the sequence in which these Storage Actions are listed in Table 1 above. That is,</p> <ul> <li>It first checks if the required action is a <code>Get</code>. If it is so, the storage_sm_get.zkasm code is fetched for execution.</li> <li>If not, it checks if the required action is <code>Set_Update</code>. If it is so, the storage_sm_set_update.zkasm code is fetched for execution.</li> <li>If not, it continues to check if the required action is <code>Set_InsertFound</code>. If it is so, the storage_sm_set_insert_found.zkasm code is fetched for execution.</li> <li>If not, it continues in the same way until the correct action is selected, in which case the corresponding code is fetched for execution.   </li> </ul> <p>That's all the primary Storage Assembly code does, the details of how each if the SMT Actions are stipulated in the individual secondary Assembly codes.</p> <p>The primary and secondary Storage Assembly files are stored as JSON-files in the Storage ROM, ready to be fetched as \"function calls\" by the Storage Executor.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-update-zkasm-code","title":"The UPDATE zkASM Code","text":"<p>Take as an example the Set_UPDATE zkASM code. The primary Storage Assembly code uses the selector <code>isSetUpdate()</code> for Set_UPDATE. </p> <p>Note that an UPDATE action involves,</p> <ol> <li>Reconstructs the corresponding key, from both the remaining key found at the leaf and key-bits used to navigate to the leaf.</li> <li>Ascertains that indeed the old value was included in the old root,</li> <li>Carries out the UPDATE of the old value with the new value, as well as updating all nodes along the path from the leaf to the root. </li> </ol> <p>There is only one Set_UPDATE Assembly code, storage_sm_set_update.zkasm, for all the above three computations.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#key-reconstruction-in-zkasm","title":"Key Reconstruction In zkASM","text":"<p>Key Reconstruction is achieved in two steps; Positioning of the bit \"1\" in the <code>LEVEL</code> register, and using the <code>LEVEL</code> register to \"climb the RKey\". That is, append the path bit last used in navigation to the correct RKey part.</p> <p>Step 1. Positioning the bit \"1\" in the <code>LEVEL</code> register</p> <p>The Set_UPDATE zkASM code, first initialises the <code>LEVEL</code> register to <code>(1,0,0,0)</code>. </p> <p>Then uses the <code>GetLevelBit()</code> function to read the two least-significant bits of the leaf level, which happens in two cases, each with its own two subcases;</p> <ul> <li> <p>Case 1. If the least-significant bit of leaf level is <code>0</code>, then the <code>GetLevelBit()</code> function is used again to read the second least-significant bit of the leaf level.</p> </li> <li> <p>Subcase 1.1: If the second least-significant bit of the leaf level is <code>0</code>, it means the leaf level is a multiple of 4, which is equivalent to 0 because leaf level works in <code>modulo</code> 4. So, the <code>LEVEL</code> register must remain as <code>(1,0,0,0)</code>.</p> </li> <li> <p>Subcase 1.2:  If the second least-significant bit of the leaf level is <code>1</code>, it means the leaf level in its binary form ends with a <code>10</code>. Hence, leaf level is a number of the form <code>2 + 4k</code>, for some positive integer <code>k</code>. As a result, the <code>LEVEL</code> register must be rotated to the position, <code>(0,0,1,0)</code>. The code therefore applies <code>ROTATE_LEVEL</code> twice to <code>LEVEL = (1,0,0,0)</code> in order to bring it to <code>(0,0,1,0)</code>.    </p> </li> <li> <p>Case 2. If the least-significant bit of leaf level is <code>1</code>, then;</p> </li> </ul> <p>The <code>LEVEL</code> register is rotated three times to the left, using ROTATE_LEVEL, and bringing the <code>LEVEL</code> register to <code>(0,1,0,0)</code>. </p> <p>Next, the <code>GetLevelBit()</code> function is used again to read the second least-significant bit of the leaf level. </p> <ul> <li>Subcase 2.1: If the second least-significant bit of the leaf level is <code>0</code>, it means the leaf level in its binary form ends with a <code>01</code>. That is, leaf level is a number of the form <code>1 + 4k</code>, for some positive integer <code>k</code>. And thus, the <code>LEVEL</code> register must remain in its current position, <code>(0,1,0,0)</code>. So it does not need to be rotated.</li> <li>Subcase 2.2: Otherwise, the second least-significant bit of the leaf level is <code>1</code>, which means the leaf level in its binary form ends with a <code>11</code>. Hence, leaf level is a number of the form <code>3 + 4k</code>, for some positive integer <code>k</code>. Consequently, the <code>LEVEL</code> register needs to be rotated from the current position <code>(0,1,0,0)</code> to the position <code>(0,0,0,1)</code>.</li> </ul> <p>Step 2. Using <code>LEVEL</code> to \"climb the RKey\"</p> <p>The Remaining Key is fetched using the <code>GetRKey()</code> function and stored in the <code>RKEY</code> register.</p> <p>When climbing the tree, there are two functions that are used in the code; the CLIMB_RKEY and the ROTATE_LEVEL. </p> <ul> <li>First, the <code>LEVEL</code> register is used to pinpoint the correct part of the Remaining Key to which the path-bit last used in the navigation must be appended. (See the previous subsection on \"A Special Cyclic Register For Leaf Levels\" for a one-to-one correspondence between the positions of \"1\" in <code>LEVEL</code> and the Rkey parts.)</li> <li>Second, the ROTATE_LEVEL is used to rotate the <code>LEVEL</code> register once.  </li> <li>The CLIMB_RKEY is used; Firstly, to shift the value of the pinpointed RKey part one position to the left. Secondly, to insert the last used path bit to the least-significant position of the shifted-value of the pinpointed RKey part.</li> </ul> <p>The above two steps are repeated until all the path bits used in navigation have been appended. In which case, equality between the reconstructed key and the original key is checked. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#checking-inclusion-of-old-value-in-old-root","title":"Checking Inclusion Of Old Value In Old Root","text":"<p>The above key reconstruction, together with checking inclusion of the old value in the old root and updating the old value to the new value, are carried out simultaneously.</p> <p>Since checking inclusion of the old value in the old root follows the same steps as the update of the old value to the new value, the corresponding lines in the Assembly code are similar. It suffices therefore to explain only one of these two computations.</p> <p>Next is the discussion of the update of the old value to the new value.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-update-part-of-set_update","title":"The Update Part Of Set_UPDATE","text":"<p>All values, \\(\\text{V}_{0123}=\\big(\\text{V}_{0},\\text{V}_{1},\\text{V}_{2},\\text{V}_{3},\\text{V}_{4},\\text{V}_{5},\\text{V}_{6},\\text{V}_{7}\\big)\\) are 256-bit long and expressed as lower half and higher half as, <code>VALUE_LOW</code> \\(=\\big(\\text{V}_{0},\\text{V}_{1},\\text{V}_{2},\\text{V}_{3}\\big)\\) and <code>VALUE_HIGH</code> \\(=\\big(\\text{V}_{4},\\text{V}_{5},\\text{V}_{6},\\text{V}_{7} \\big)\\).</p> <p>Step 1. Computing the new leaf value</p> <p>(a) The functions <code>GetValueLow()</code> and <code>GetValueHigh()</code> are used to fetch <code>VALUE_LOW</code> \\(=\\big(\\text{V}_{0},\\text{V}_{1},\\text{V}_{2},\\text{V}_{3}\\big)\\) and <code>VALUE_HIGH</code> \\(=\\big(\\text{V}_{4},\\text{V}_{5},\\text{V}_{6},\\text{V}_{7}\\big)\\), respectively.</p> <p>(b) The <code>VALUE_LOW</code> \\(= \\big(\\text{V}_{0},\\text{V}_{1},\\text{V}_{2},\\text{V}_{3}\\big)\\) is stored in a register called <code>HASH_LEFT</code>, whilst <code>VALUE_HIGH</code> \\(=\\big(\\text{V}_{4},\\text{V}_{5},\\text{V}_{6},\\text{V}_{7}\\big)\\) is stored in another register called <code>HASH_RIGHT</code>.</p> <p>(c) The hashed value of \\(\\text{V}_{0123}\\) is computed using <code>HASH0</code> as, \\(\\text{HASH0}\\big(\\text{HASH}\\_ {\\text{LEFT}}\\|\\text{HASH}\\_ {\\text{RIGHT}}\\big)\\). Note that this is in fact, \\(\\text{POSEIDON}\\big(0\\|0\\|0\\|0\\|\\text{VALUE}\\_ {\\text{LOW}}\\|\\text{VALUE}\\_ {\\text{HIGH}}\\big)\\). The hashed value is then stored in <code>HASH_RIGHT</code>.</p> <p>(This means the <code>HASH_RIGHT</code> and the <code>HASH_LOW</code> are 'make-shift' registers. Whenever a value is stored in it, the old value that was previously stored therein is simply pushed out. They hold values only for the next computation.)</p> <p>(d) Next the Rkey is copied into the <code>HASH_LEFT</code> register. And the leaf value is computed by using <code>HASH1</code> as, \\(\\text{HASH1}\\big(\\text{HASH}\\_ {\\text{LEFT}}\\|\\text{HASH}\\_ {\\text{RIGHT}}\\big)\\). i.e., The value of the leaf is, \\(\\text{HASH1}\\big( \\text{RKey}\\|\\text{HashedValue}\\big)\\). The leaf value is then copied into another register called <code>NEW_ROOT</code>. </p> <p>Step 2. Climbing the SMT</p> <p>Check if the path bit that led to the leaf is 0 or 1, by using the <code>GetNextKeyBit()</code> function.</p> <p>Case 1: If the path bit (called 'key bit' in the code) is 0, then the corresponding sibling is on the right. Therefore, using 'jump if zero' <code>JMPZ</code>,  the code jumps to the <code>SU_SiblingIsRight</code> routine. </p> <p>(a) The leaf value in <code>NEW_ROOT</code> is pushed into the <code>HASH_LEFT</code> register. </p> <p>(b) The hash value of the sibling node is fetched, using the <code>GetSiblingHash()</code> function. And it is pushed into the <code>HASH_RIGHT</code> register.</p> <p>(c) The hash value of the parent node is computed using <code>HASH0</code> as follows, \\(\\text{HASH0}\\big(\\text{HASH}\\_ {\\text{LEFT}} \\|\\text{HASH}\\_{\\text{RIGHT}}\\big)\\). </p> <p>i.e., The parent node is \\(\\text{POSEIDON}\\big(0\\|0\\|0\\|0\\|\\text{LeafValue}\\|\\text{SiblingHash}\\big)\\).</p> <p>Case 2: If the path bit is 1, then the corresponding sibling is on the left. The routine <code>SU_SiblingIsRight</code> is then executed. </p> <p>(a) The leaf value in <code>NEW_ROOT</code> is pushed into the <code>HASH_RIGHT</code> register. </p> <p>(b) The hash value of the sibling node is fetched, using the <code>GetSiblingHash()</code> function. And it is pushed into the <code>HASH_LEFT</code> register.</p> <p>(c) The hash value of the parent node is computed using <code>HASH0</code> as follows, \\(\\text{HASH0}\\big(\\text{HASH}\\_ {\\text{LEFT}}\\|\\text{HASH}\\_ \\text{RIGHT}\\big)\\). </p> <p>i.e., The parent node is \\(\\text{POSEIDON}\\big(0\\|0\\|0\\|0\\|\\text{SiblingHash}\\|\\text{LeafValue}\\big)\\). </p> <p>Step 3. Check if tree top has been reached</p> <p>The code uses the function <code>GetTopTree()</code> to check is the top of the tree has been reached.</p> <p>Case 1. If  <code>GetTopTree()</code>  returns 1, then Step 2 is repeated. But this time using the hash value of the corresponding sibling at the next level (i.e., at <code>leaf level - 1</code>). </p> <p>Case 2.  If  <code>GetTopTree()</code>  returns 0, then the code jumps to the <code>SU_Latch</code> routine. </p> <p>The <code>SU_Latch</code> is an overall routine for the entire Set_UPDATE Assembly code. It is here where, </p> <p>(a) Equality between the reconstructed key and the original key is checked.</p> <p>(b) Equality between the computed old root value and the original old root is checked.</p> <p>Once consistency is established both between the keys and the old roots, then all new values; the new root, the new hash value, and the new leaf value; are set using <code>LATCH_SET</code>. </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-rest-of-the-secondary-assembly-codes","title":"The Rest Of The Secondary Assembly Codes","text":"<p>The Assembly codes for the other seven SMT Actions to a certain extent, follow a similar pattern except for a few cases where especially adjusted routines are used.</p> <p>Actions such as; </p> <ol> <li>The <code>Set_InsertFound</code> (or <code>SIF</code>) may involve a change in the topology of the SMT by extending a branch once or several times. </li> </ol> <p>In cases where a branch has been extended, the SIF Assembly code, when computing the new root, uses another routine called <code>SIF_ClimbBranch</code> just for updating values along the newly extended branch. This is done in addition to the <code>SIF_ClimbTree</code>, which is the exact same routine as the aforementioned <code>SU_ClimbTree</code> of the <code>Set_UPDATE</code> case.</p> <p>It is for the same reason, SIF Assembly utilises special registers; the <code>SIBLING_VALUE_HASH</code> and <code>SIBLING_RKEY</code>. </p> <ol> <li>The opposite SMT Action, the <code>Set_DeleteFound</code> or <code>SDF</code>, may entail a previously extended branch being reversed. </li> </ol> <p>As in the SIF case, if a branch had been extended but now the extension needs to be reversed due to a deleted leaf value, a special routine called <code>SDF_ClimbBranch</code> is used when updating values of nodes along the newly shortened branch. This <code>SDF_ClimbBranch</code> routine is the exact same routine as the<code>SIF_ClimbBranch</code>. Similarly, the SDF Assembly code uses the <code>SDF_ClimbTree</code> as in the Set_UPDATE Assembly.</p> <p>Note also that there is only one <code>Get</code> Assembly code, for the READ SMT Action, and the rest of the secondary Assembly codes are <code>Set_</code> Assembly codes differing according to their respective SMT Actions. So <code>Get</code> uses <code>LATCH_GET</code> at the end of a run, while the <code>Set_</code> codes use <code>LATCH_SET</code>.</p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-storage-executor","title":"The Storage Executor","text":"<p>The Storage Executor like a slave-worker to the master, the Storage Assembly code, carries out all SMT Actions in accordance with rules and logic that the Assembly code has set out.</p> <p>As per instruction of the Main SM, the Storage Executor makes function calls to the Storage ROM for a specific secondary Assembly code stored as a JSON-file, by using the same aforementioned selectors of secondary Assembly codes. </p> <p>For example, if the Main SM requires a new leaf to be created at a found non-zero leaf, the Storage Executor uses <code>isSetInsertFound</code> as a function call for the <code>Set_InsertFound</code> (or <code>SIF</code>) SMT Action. The Storage Executor then proceeds to build commited polynomials and executes the <code>SIF</code> SMT Action.</p> <p>As previously observed, in our very first UPDATE example in this document, all values are expressed as quadruplets of unsigned integers. For example, the Remaining Key looks like this, $$ \\text{RKey} = \\big( \\text{RKey}_0, \\text{RKey}_1, \\text{RKey}_2, \\text{RKey}_3 \\big) $$ The Executor therefore uses an internal 4-element register called <code>op = [_,_,_,_]</code>, for handling values from the Storage ROM, which are needed in the internal step-by-step evaluations of the SMT Action being executed. It is thus reset to 0 after every evaluation.</p> <p>All the function calls seen in the Assembly code; </p> <p><code>GetSibling()</code>, <code>GetValueLow()</code>, <code>GetValueHigh()</code>, <code>GetRKey()</code>, <code>GetSiblingRKey()</code>, <code>GetSiblingHash()</code>, <code>GetSiblingValueLow()</code>, <code>GetSiblingValueHigh()</code>, <code>GetOldValueLow()</code>, <code>GetOldValueHigh()</code>, <code>GetLevelBit()</code>, <code>GetTopTree()</code>, <code>GetTopBranch()</code> and <code>GetNextKeyBit()</code>; </p> <p>are actually performed by the Storage Executor. The values being fetched are carried with the <code>op</code> register. For instance, if the function call is <code>GetRKey()</code> then the Storage Executor gets the RKey from the rom.line file, carries it with <code>op</code> as; </p> <p><code>op[0] = ctx.rkey[0];</code> </p> <p><code>op[1] = ctx.rkey[1];</code></p> <p><code>op[2] = ctx.rkey[2];</code></p> <p><code>op[3] = ctx.rkey[3];</code></p> <p>where <code>ctx</code> signifies an SMT Action. </p> <p>Also, since all SMT Actions require some hashing, the Storage SM delegates all hashing Actions to the \\(\\text{POSEIDON}\\) SM. However, from within the Storage SM, it is best to treat the \\(\\text{POSEIDON}\\) SM as a blackbox. The Storage Executor simply specifies the sets of twelve values to be digested. And the \\(\\text{POSEIDON}\\) SM then returns the required digests of the values.   </p>"},{"location":"zkEVM/zkProver/State-Machines/Secondary-State-Machines/Storage/Storage/#the-storage-pil","title":"The Storage PIL","text":"<p>All computations executed in the Storage SM must be verifiable. A special Polynomial Identity Language (PIL) code is therefore used to set up all the polynomial constraints the verifier needs to validate correctness of execution.</p> <p>The preparation for these polynomial constraints actually starts in the Storage Executor. In order to accomplish this, the Storage Executor uses; selectors, setters and instructions; which are in fact Boolean polynomials. See the list of these Boolean committed polynomials in Table 2, below.</p>  Table 2: Boolean Polynomials For Execution Tracing  <p> Selectors Setters Instructions selFree[i] setHashLeft[i] iHash selSiblingValueHash[i] setHashRight[i] iHashType selOldRoot[i] setOldRoot[i] iLatchSet selNewRoot[i] setNewRoot[i] iLatchGet selValueLow[i] setValueLow[i] iClimbRkey selValueHigh[i] setValueHigh[i] iClimbSiblingRkey selRkeyBit[i] setSiblingValueLow[i] iClimbSiblngRkeyN selSiblingRkey[i] setSiblingValueHigh[i] iRotateLevel selRkey[i] setRkey[i] iJmpz setSiblingRkey[i] iConst0 setRkeyBit[i] iConst1 setLevel[i] iConst2 iConst3 iAddress <p> </p> <p>Everytime each of these Boolean polynomials are utilised or performed, a record of a \"1\" is kept in its register. This is called an execution trace. </p> <p>Therefore, instead of performing some expensive computations in order to verify correctness of execution (at times repeating the same computations being verified), the trace of execution is tested. The verifier takes the execution trace, and tests if it satisfies the polynomial constraints (or identities) in the PIL code. This technique helps the zkProver to achieve succintness as a zero-knowledge proof/verification system.</p>"},{"location":"zkEVM/zkProver/Temporary-Files-Deleteme/zkASM-and-PIL/","title":"zkASM and PIL","text":"<p>The task of creating the execution trace is performed by a component called the zkExecutor. The zkExecutor takes as inputs the transactions of a batch, a ChainID, the root  of a Merkle tree representing the previous state of the zkEVM in that chain and the root of the new state after executing the transactions.  Additionally, the zkExecutor gets values  of the current state of the zkEVM to build the proof.</p> <p>The zkExecutor is in fact an interpreter of an assembly language called zkASM.  The zkASM language is used to build a program called zkROM that  when executed by the zkExecutor provides a suitable execution trace. The zkROM is produced from the zkASM language by using the zkASM compiler, which is located in the following repository: zkASM Compiler.  In the zkROM program (located in the following repository:  zkROM), each EVM opcode is implemented with a set of zkASM instructions.  Each instruction utilizes a row of the execution trace matrix,  also known as a \"step\" of the zkEVM. </p> <p>Note: A complete description of the zkASM language can be found in the  following Section Introduction to zkASM.</p> <p>To see the zkASM compiler in action, it is possible to compile a .zkasm into the corresponding .json file using the following commands inside the previous repository:</p> <pre><code>$ node src/zkasm.js &lt;input.zkasm&gt; -o &lt;output.json&gt;\n</code></pre> <p>Note: Previously, it is important to install the node modules </p> <pre><code>$ npm install\n</code></pre> <p>and build the parsers</p> <pre><code>$ npm run build\n</code></pre> <p>The .json file contains a field <code>program</code> which is an array of maps,  each element representing a line of the .zkasm file. Among many fields,  every element contain </p> <ul> <li><code>fileName</code>: Absolute path of the file containing the corresponding assembly row.</li> <li><code>lineStr</code>: String representing the complete line of the corresponding .zkasm file.</li> <li><code>line</code>: A line identifier. </li> <li>Moreover, the corresponding setters, selectors, constants and instructions will be assigned accordingly.  This point will be important for PIL validations, described below. </li> </ul> <p>The zkExecutor is part of the zkProver, which is the core component of the Polygon zkEVM.</p> <p></p>  Figure 1: Big picture of the zkProver  <p>At the same time, there exists the need to check the correctness of each transition between the rows of the execution trace generated by the zkExecutor. To do so, a new Polynomial Identity Language PIL have been created. Recall that having an execution trace is equivalent as having polynomials, each one  representing each column. Therefore, using this language we will be able to express several relations between consecutive rows of each of the columns  computed by the zkExecutor in a polynomial-like way, allowing us to prove the  correct execution via a STARK Recursion. The .pil files are compiled via a PIL compiler,  which is located in the following repository: PIL Compiler. The compiler, similarly as in the zkASM case, produces a .json which will be interpreted by the STARK generator and, together with the execution trace (seen as a set of polynomial evaluations) generated by the zkExecutor, will produce a proof. </p> <p>Note: A complete description of the PIL language can be found in the  following Section Introduction to PIL.</p> <p>To see the PIL compiler in action, it is possible to compile a .pil into the corresponding .json file using the following commands inside the previous repository:</p> <pre><code>$ node src/pil.js &lt;input.pil&gt; -o &lt;output.pil.json&gt;\n</code></pre> <p>Note: Previously, it is important to install the node modules </p> <pre><code>$ npm install\n</code></pre> <p>and build the parsers</p> <pre><code>$ npm run build\n</code></pre> <p>First of all, the resulting .json file specifies, under the <code>references</code> key,  all the polynomials that are references in the .pil file. The <code>references</code> key-value  stores, in its keys, the name and the namespace associated to each polynomial in the form <code>nameSpace.name</code>. Each value describes a property associated to each polynomial such:</p> <ul> <li> <p><code>type</code>: specifies if a certain polynomial is commited, constant, calculated...</p> </li> <li> <p><code>id</code>: unique id associated to each polynomial.</p> </li> <li> <p><code>polDeg</code>: reflects the resulting polynomial degree.</p> </li> <li> <p><code>isArray</code>: flag to control array-based polynomial definitions  (see PIL Components for more information). </p> </li> </ul> <p>Among all the contents of the .json file, there is a key called <code>expressions</code> which  is an array containing all the identities and operations among the corresponding polynomials defined by the zkExecutor. The used values are input freely from the  executor or taken from the .json compiled by the zkASM compiler. Moreover, there  exists other keys which represent all inclusion, permutation and copy constrain arguments. This .json will be finally used in the STARK proof generation, which  will prove all the specified constrains. </p> <p>Another important key fields for debugging purposes are</p> <ul> <li> <p><code>nCommitements</code>: which specifies the total number of commited polynomials. </p> </li> <li> <p><code>nConstants</code>: which specifies the total number of constant polynomials  referenced in the PIL file. </p> </li> </ul>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/","title":"Fibonacci","text":"<p>Designing a simple zero-knowledge cryptographic tool or app can involve a lot of intricacies. Consider now, how complex it is to develop a zkEVM. It is a huge and complex project.</p> <p>In this document we breakdown the complexities of the Polygon zkEVM's design in terms of a simplified example, a Fibonacci State Machine. The aim is to illustrate, in a generic sense, how the state machine approach has been implemented to realise the Polygon zkEVM.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#fibonacci-state-machine","title":"Fibonacci State Machine","text":"<p>Consider constructing a membership cryptographic tool, which determines whether a given number \\(\\beta\\) is a member of the Fibonacci sequence or not. The tool must be cryptographically secure, needs to preserve privacy, and should be designed in terms of a state machine.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#the-fibonacci-sequence","title":"The Fibonacci Sequence","text":"<p>The Fibonacci sequence  \\(\\mathbf{a_1, a_2, \\dots , a_n}\\)  has the property that the sum of every two consecutive members \\(\\mathbf{a_{i-1}}\\) and \\(\\mathbf{a_i}\\) gives the value of the next member \\(\\mathbf{a_{i+1}}\\). That is,  \\(\\mathbf{ a_{i+1} = a_{i-1} + a_i }\\). </p> <p>Here are the first twelve members of the sequence;</p> <p>$$ \\mathbf{ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \\dots} $$ It is easy to check whether  \\(\\mathbf{377}\\)  and  \\(\\mathbf{987}\\)  are members of the Fibonacci sequence. But to do the same with \\(\\mathbf{ 12,586,269,025 }\\), one clearly needs a formula or a computer program. The task here is a state machine crypto tool to achieve this.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#the-fibonacci-state-machine","title":"The Fibonacci State Machine","text":"<p>Consider a state machine with registries \\(\\mathbf{A} = ( A_1, A_2, \\dots , A_l )\\) and  \\(\\mathbf{B} = ( B_1, B_ 2, \\dots , B_l )\\), so that the i-th state is the pair \\(\\big( A_i , B_i \\big)\\).  Such a state machine is a Fibonacci state machine if indeed the registry values conform to the format of the Fibonnacci sequence. See the picture below, with the initial conditions  \\(A_1 = 0\\)  and  \\(B_1 = 1\\). </p> <p></p>  Figure 1 : Fibonacci State Machine - Two Registries  <p>Since the two registries contain the Fibonacci sequence, except that \\(\\mathbf{B}\\) is one step ahead of \\(\\mathbf{A}\\), they are related as follows,</p> \\[ \\begin{aligned}  A_{i+1} &amp;= B_i , \\\\  B_{i+1} &amp;= A_i + B_i. \\end{aligned} \\] <p>The idea here is to express the registries as polynomials and ultimately employ a polynomial commitment scheme in order to fully construct the membership crypto tool. </p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#polynomial-identities","title":"Polynomial Identities","text":"<p>As it is the tradition in blockchains, the polynomials that represent the two registries are taken from the set of polynomials \\(\\mathbb{Z}_p[x]\\),  where the coefficients are elements of a prime field \\(\\mathbb{Z}_p\\). </p> <p>For this specific example, as shown in Figure 1 above, the polynomials are evaluated over the subgroup \\(H = \\{\\omega,\\omega^2,\\omega^3,\\dots,\\omega^8 = 1\\} = \\langle\\omega\\rangle\\) of order \\(8\\). </p> <p>Define two polynomials \\(P(x)\\) and \\(Q(x)\\) such that  $$ P(\\omega^i) = A_i, \\ Q(\\omega^i) = B_i. $$</p> <p>Since every \\(x\\) in \\(H\\) is of the form \\(x = \\omega^i\\) for some \\(i\\), we have</p> \\[ \\begin{aligned} P(x\\omega) &amp;=  P(\\omega^{i + 1})  =  A_{i+1},\\\\ Q(x\\omega) &amp;= Q(\\omega^{i+1})  =  B_{i+1}. \\end{aligned} \\] <p>But substituting the relations, \\(A_{i+1} = B_i\\) and \\(B_{i+1} = A_i + B_i\\), results in the following identities,</p> \\[ \\begin{aligned} P(x\\omega) &amp;= A_{i+1} = B_i = Q(\\omega^i) = \\bigg\\lvert_H Q(x),\\\\  Q(x\\omega) &amp;= B_{i+1} = A_i + B_i  = P(\\omega^i) + Q(\\omega^i) = \\bigg\\lvert_H P(x) + Q(x). \\end{aligned} \\] <p>That is, </p> \\[ \\begin{aligned} P(x\\omega) &amp;= \\bigg\\lvert_H  Q(x),\\\\ Q(x\\omega) &amp;= \\bigg\\lvert_H  P(x) + Q(x). \\end{aligned} \\]"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#non-cyclic-polynomial-identities-problem","title":"Non-cyclic Polynomial Identities Problem","text":"<p>If these polynomial identities accurately express the two registries, then every member of the Fibonacci sequence should satisfy them. </p> <p>Note that the definition of \\(H\\) does not restrict the values of \\(i\\) to be less or equal to \\(8\\). Even if we set \\(i = 27\\), the element  \\(\\omega^{27}\\)  is in \\(H\\) because  \\(\\omega^{27} = w^8 \\cdot \\omega^8 \\cdot \\omega^8 \\cdot \\omega^3 = 1 \\cdot 1 \\cdot 1 \\cdot \\omega^3 = \\omega^3\\).</p> <p>However, the unrestricted value of  \\(i\\)  presents problems with the above polynomial identities. </p> <p>For example, let us test if the polynomial identities hold for all values of  \\(i\\) . We let  \\(x = \\omega^8\\)  and use the registry values given in Figure 1.</p> <ul> <li>For the first identity we get, </li> </ul> \\[ \\begin{aligned} &amp;P(x \\omega) = P(\\omega^8 \\cdot \\omega)  =   P(\\omega^1)  =  A_1 = 0,\\ \\ \\text{but}\\\\ &amp;Q(x) = Q(w^8) = B_8 = 21 \\not= 0. \\end{aligned} \\] <ul> <li>Similarly, for the second identity, we get,</li> </ul> \\[ \\begin{aligned} &amp;Q(x \\omega) = Q(\\omega) = B_1 = 1\\\\ &amp;P(x) = P(\\omega^8) + Q(\\omega^8) = 21 + 13 = 34 \\not= 1. \\end{aligned} \\] <p>This means the polynomial identities are not aligned with the registries of the Fibonacci state machine because although \\(H\\) is cyclic, the identities are not. </p> <p>We therefore need some error-correcting polynomial \\(R(x)\\) which makes the polynomial identities cyclic. Such a polynomial must also be in \\(\\mathbb{Z}_p[x]\\).</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#correcting-errors-in-polynomial-identities","title":"Correcting Errors In Polynomial Identities","text":"<p>We first modify our Fibonacci state machine by adding a third registry \\(\\mathbf{C} = ( C_1, C_2, \\dots , C_l)\\). Set the registry values to  \\(\\mathbf{C} = ( 1, 0, 0, \\dots , 0)\\). So the Fibonacci state machine is now as depicted in Figure 2 below.</p> <p></p>  Figure 2 : Fibonacci State Machine - Three Registries  <p>The corresponding polynomial \\(R(x)\\) is defined as follows,  $$ R(\\omega^i) = C_i. $$</p> <p>That is, </p> \\[ \\begin{aligned} R(\\omega^i) &amp;= C_i = 1, \\text{ if }\\ \\ i \\mod 8 = 1 , \\\\ R(\\omega^i) &amp;= C_i = 0, \\text{ otherwise}. \\end{aligned} \\] <p>The polynomial \\(R(x)\\) is incorporated into the previous polynomial identities as follows,</p> \\[ \\begin{aligned} P(x \\omega) &amp;= \\bigg\\lvert_H Q(x) \\big( 1 - R(x \\omega) \\big),\\\\ Q(x \\omega) &amp;= \\bigg\\lvert_H \\big( P(x) + Q(x) \\big) \\big( 1 - R(x \\omega) \\big) + R(x \\omega) \\end{aligned} \\] <p>Let us test if these new polynomial identities are cyclic, by again using  \\(x = \\omega^8\\). </p> <ul> <li>For the first identity we have </li> </ul> \\[ \\begin{aligned} LHS &amp;= P(x \\omega) = P(\\omega^8 \\cdot \\omega) = P(\\omega^1) = A_1 = 0,\\\\ RHS &amp;= Q(x) \\big( 1 - R(x \\omega) \\big) = Q(\\omega^8) \\big( 1 - R(\\omega^8 \\cdot \\omega) \\big) = A_8 \\big( 1 - R(\\omega) \\big) = 13 \\big( 1 - 1 \\big) = 0. \\end{aligned} \\] <p>So the first identity holds true for  \\(x = \\omega^8\\),  and it is easy to check that it holds true for all other values of  \\(x\\)  in  \\(H\\).</p> <ul> <li>For the second identity we have</li> </ul> \\[ \\begin{aligned} LHS &amp;= Q(x\\omega) = Q(\\omega^8 \\cdot \\omega) = Q(\\omega^1) = B_1 = 1,\\\\ \\\\ RHS &amp;= \\big(P(\\omega^8) + Q(\\omega^8) \\big) \\big( 1 - R(\\omega^8 \\cdot \\omega) \\big) + R(\\omega^8 \\cdot \\omega)\\\\  &amp;= \\big( A_8 + B_8 \\big) \\big( 1 - R(\\omega^1) \\big) + R(\\omega^1)\\\\ &amp;= \\big( 13 + 21 \\big) \\big( 1 - 1 \\big) + 1 = 1. \\end{aligned} \\] <p>The second identity also holds true for \\(x = \\omega^8\\), and it is readily verifiable that it holds true for all other values of \\(x\\) in \\(H\\).</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#varied-initial-conditions","title":"Varied Initial Conditions","text":"<p>Note that instead of being restricted to the given initial conditions \\(\\big( A_1 , B_1 \\big) = \\big( 0 , 1 \\big)\\),  the Fibonacci state machine together with its polynomial identities can be easily adjusted to any other initial conditions  \\(\\big( A_1 , B_1 \\big)\\) as follows; </p> \\[ \\begin{aligned}  P(x \\omega) &amp;= \\bigg\\lvert_H Q(x) \\big( 1 - R(x \\omega) \\big) + A_1 R(x \\omega),\\\\ Q(x \\omega) &amp;= \\bigg\\lvert_H \\big( P(x) + Q(x) \\big) \\big( 1 - R(x \\omega) \\big) + B_1 R(x \\omega) . \\end{aligned} \\]"},{"location":"zkEVM/zkProver/Verifiable-Computations/Fibonacci/#proving-our-state-machine-high-level","title":"Proving Our State Machine (High Level)","text":"<p>The previous polynomial relations can be efficiently proven via polynomial commitments such as Kate and FRI-based.</p> <p></p>  Figure 3 : Polynomial Commitment Scheme  <p>Commitment schemes are binding and hiding:</p> <ol> <li>Binding: The prover can not change the polynomial he or she committed to.</li> <li>Hiding: The verifier cannot deduce which polynomial the prover committed to, by merely looking at the commitment.</li> </ol>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Introduction/","title":"Introduction","text":""},{"location":"zkEVM/zkProver/Verifiable-Computations/Introduction/#concept","title":"Concept","text":"<p>Polygon zkEVM is a zk-rollup that executes smart contracts transparently, by publishing zero-knowledge validity proofs, while maintaining opcode compatibility with the Ethereum Virtual Machine.</p> <p>The decision of proving EVM transactions instead of creating a virtual machine with  simpler transactions is for minimizing the friction of current Ethereum users and dApps when using the solution. It is an approach that requires the recreation of all the EVM opcodes, which allows the transparent deployment of any existing Ethereum smart contract.  For this purpose, a new set of technologies and tools have been engineered and developed and, they are briefly presented below.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Introduction/#evm-arithmetization","title":"EVM Arithmetization","text":"<p>The first step to prove the execution correctness of an EVM transaction is to build a suitable execution trace. By a suitable execution trace, we mean a set of values that fulfill the constraints imposed by the EVM processing. The trace is expressed as a matrix, where each column has a name. Each column is interpolated into a polynomial and the correctness of the execution is finally reduced to verifying a set of identities between polynomials (columns). The process of designing the proper set of columns and identities is called arithmetization. The Polygon zkEVM provides an efficient arithmetization of the EVM.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Introduction/#executor-zkasm-and-zkprover","title":"Executor, zkASM and zkProver","text":"<p>The task of creating the execution trace is performed by a component called the executor. The executor takes as inputs the transactions of a batch, a ChainID, the root  of a Merkle tree representing the previous state of the zkEVM in that chain and the root of the new state after executing the transactions.  Additionally, the executor gets values  of the current state of the zkEVM to build the proof.</p> <p>The executor is in fact an interpreter of an assembly language called zkASM.  The zkASM language is used to build a program called zkROM that  when executed by the Executor provides a suitable execution trace. In the zkROM program, each EVM opcode is implemented with a set of zkASM instructions.  Each instruction utilizes a row of the execution trace matrix,  also known as a \"step\" of the zkEVM. </p> <p>The executor is part of the zkProver, which is the core component of the Polygon zkEVM. The following figure shows, at a high level, the interaction of the zkProver with the other components of the solution, which are the Node and the Database (DB):</p> <p></p> <ol> <li> <p>The Node sends the content of the Ethereum state and the EVM Merkle trees to the DB, to be stored there. </p> </li> <li> <p>The Node sends the input batch of transactions to the zkProver. </p> </li> <li> <p>The zkProver accesses the DB, fetching the information it needs to produce verifiable proofs of the transaction batch sent by the Node. </p> </li> <li> <p>The zkProver generates the proofs of transactions, and sends these proofs back to the Node. </p> </li> </ol>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Introduction/#polynomial-identity-language-pil","title":"Polynomial Identity Language (PIL)","text":"<p>The Polynomial Identity Language (PIL) is a novel domain-specific language for defining the constraints of the execution trace of state machines.  It is used to define the name of the polynomials of the execution trace and, to describe the identities or relationships that these polynomials must fulfill to consider an execution as correct.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Introduction/#modular-design","title":"Modular Design","text":"<p>The amount of columns and identities can grow beyond thousands  for the execution trace of complex state machines like the EVM. Managing such a huge matrix makes its design complex and hard to handle.</p> <p>To simplify this, the Polygon zkEVM uses a divide and conquer technique in which the execution trace is split in smaller matrices. Then, using a proving technique called plookup, it is possible to  relate rows in one matrix with rows in another matrix. In particular, we use inclusion and permutation. Inclusion checks that the rows in a matrix are included in another matrix. Permutation checks that the rows of a matrix are the same  rows of another matrix but in a different order.  </p> <p>The PIL language allows to name the columns of each matrix in which the execution trace is divided (using the keyword \\(\\mathtt{namespace}\\)) and, it also allows the definition of inclusions  (using the keyword \\(\\mathtt{in}\\)) and permutations (using the keyword \\(\\mathtt{is}\\)). </p> <p>In the Polygon zkEVM, the execution trace is divided into a main matrix also called  the main state machine and secondary matrices also called secondary state machines. </p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Introduction/#further-reading","title":"Further Reading","text":"<p>In the subsections following, simple examples of arithmetization are shown and, the assembly and PIL languages are introduced.  In posterior sections, the assembly, the PIL, and the secondary state machines are described in more detail.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Modular-Design/","title":"Modular Design","text":""},{"location":"zkEVM/zkProver/Verifiable-Computations/Modular-Design/#divide-and-conquer","title":"Divide and Conquer","text":"<p>We want now to extend the previous idea to a more complex machine that can handle, for example, multiplications. </p> <p>We could keep adding columns to our state machine to express such operations but that would make the design complex and hard to handle. Instead, we are going to use a divide and conquer technique:</p> <ul> <li> <p>Our zk-EVM architecture comprises different connected state machines.</p> </li> <li> <p>Each state machine is devoted to proving the execution of a specific task.</p> </li> <li> <p>Then, relevant columns (polynomials) of these different state machines are related using inclusion proofs (with plookup).</p> </li> </ul> <p>To illustrate this important process:</p> <ul> <li> <p>Let's design a state machine to manage arithmetic operations with elements of 32 bits.</p> </li> <li> <p>Then, let's connect this state machine to our main state machine with an inclusion proof.</p> </li> </ul>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Modular-Design/#arithmetic-state-machine","title":"Arithmetic State Machine","text":"<p>The arithmetic state machine will check sums, subtractions, multiplications and divisions with elements of 32 bits.</p> <p>For this, we use the following constraint with five registries: $$ \\mathcal{A}_i \\cdot \\mathcal{B}_i + \\mathcal{C}_i = 2^{32} \\mathcal{D}_i + \\mathcal{E}_i. $$</p> <p>Notice that the multiplication between \\(\\mathcal{A}_i\\) and \\(\\mathcal{B}_i\\), which are elements of 32 bits, can be expressed with \\(\\mathcal{E}_i\\) and \\(\\mathcal{D}_i\\) where these are also elements of 32 bits. The \\(\\mathcal{D_i}\\) term carries the exceeding part of the multiplication.</p> <p>As before, we will express the previous relation as a cyclic polynomial identity at some subgroup \\(H\\) of roots of unity of \\(\\mathbb{Z}_{p}\\):</p> \\[ \\mathcal{A}(x) \\cdot \\mathcal{B}(x) + \\mathcal{C}(x) = 2^{32} \\mathcal{D}(x) + \\mathcal{E}(x).  \\] <p>Notice also that we have to enforce that all the images of \\(\\mathcal{A}(x)\\), \\(\\mathcal{B}(x)\\), \\(\\mathcal{C}(x)\\), \\(\\mathcal{D}(x)\\) and \\(\\mathcal{E}(x)\\) at \\(H\\) are elements of 32 bits.</p> <p>We will design a machine to check this kind of operations as follows:</p> \\[ \\tiny \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline  \\textbf{set}\\mathcal{A} &amp;  \\textbf{set}\\mathcal{B}  &amp;  \\textbf{set}\\mathcal{C} &amp;  \\textbf{set}\\mathcal{D} &amp;  \\textbf{set}\\mathcal{E} &amp;  \\textbf{latch}  &amp; \\textbf{freeIn} &amp;  \\mathcal{A} &amp;  \\mathcal{A'} &amp;  \\mathcal{B} &amp; \\mathcal{B'} &amp; \\mathcal{C} &amp; \\mathcal{C'} &amp; \\mathcal{D} &amp; \\mathcal{D'} &amp; \\mathcal{E} &amp; \\mathcal{E'}\\\\ \\hline 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0x0003 &amp; 0 &amp; 0x003 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\hline 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0x0002 &amp; 0x0003 &amp; 0x0003 &amp; 0 &amp; 0x0002 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0x0004 &amp; 0x0003 &amp; 0x0003 &amp; 0x0002 &amp; 0x0002 &amp; 0 &amp; 0x0004 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0x0003 &amp; 0x0003 &amp; 0x0002 &amp; 0x0002 &amp; 0x0004 &amp; 0x0004 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0x000a &amp; 0x0003 &amp; 0x0003 &amp; 0x0002 &amp; 0x0002 &amp; 0x0004 &amp; 0x0004 &amp; 0 &amp; 0 &amp; 0 &amp; 0x000a\\\\ \\hline 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\mathbf{1} &amp; 0x1111 &amp;  \\mathbf{0x0003} &amp; 0x1111 &amp;  \\mathbf{0x0002} &amp; 0x0002 &amp;  \\mathbf{0x0004} &amp; 0x0004 &amp;  \\mathbf{0} &amp; 0 &amp;  \\mathbf{0x000a} &amp; 0x000a\\\\ \\hline 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0x2222 &amp; {0x1111} &amp; 0x1111 &amp; {0x0002} &amp; 0x2222 &amp; {0x0004} &amp; 0x0004 &amp; {0} &amp; 0 &amp; {0x000a} &amp; 0x000a\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0x3333 &amp; {0x1111} &amp; 0x1111 &amp; {0x2222} &amp; 0x2222 &amp; {0x0004} &amp; 0x3333 &amp; {0} &amp; 0 &amp; {0x000a} &amp; 0x000a\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0x0246 &amp; {0x1111} &amp; 0x1111 &amp; {0x2222} &amp; 0x2222 &amp; {0x3333} &amp; 0x3333 &amp; {0} &amp; 0x0246 &amp; {0x000a} &amp; 0x000a\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0xb975 &amp; {0x1111} &amp; 0x1111 &amp; {0x2222} &amp; 0x2222 &amp; {0x3333} &amp; 0x3333 &amp; {0x0246} &amp; 0x0246 &amp; {0x000a} &amp; 0xb975\\\\  \\hline 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp;  \\mathbf{1} &amp; 0x7777 &amp; \\mathbf{0x1111} &amp; 0x7777 &amp; \\mathbf{0x2222} &amp; 0x2222 &amp; \\mathbf{0x3333} &amp; 0x3333 &amp; \\mathbf{0x0246} &amp; 0x0246 &amp; \\mathbf{0xb975} &amp; 0xb975\\\\ \\hline ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ... &amp; ...\\\\ \\hline \\end{array} \\] <p>Accents are used to denote the next value of the registry. We use latch to flag when the operation is ready and there is the need to check the constraint with the actual values of \\(\\mathcal{A}, \\mathcal{B}, \\mathcal{C}, \\mathcal{D}, \\mathcal{E}\\). Notice that \\(\\textbf{set}\\mathcal{A}\\), \\(\\textbf{set}\\mathcal{B}\\), \\(\\textbf{set}\\mathcal{C}\\), \\(\\textbf{set}\\mathcal{D}\\), \\(\\textbf{set}\\mathcal{E}\\) and latch are constant (preprocessed), in other words, they do not depend on the input.</p> <p>The column freeIn is committed and contains the values for which we want to do the arithmetic operations. The values of \\(\\mathcal{A}\\), \\(\\mathcal{B}\\), \\(\\mathcal{C}\\), \\(\\mathcal{D}\\) and \\(\\mathcal{E}\\) depend on the freeIn and are obviously also committed.</p> <p>Therefore, the polynomial identities that define the arithmetic state machine are the following: </p> \\[\\begin{aligned} \\mathcal{A'} &amp;= \\mathbf{sel}\\mathcal{A}\\cdot(\\mathbf{freeIn}-\\mathcal{A}) + \\mathcal{A} \\\\ \\mathcal{B'} &amp;= \\mathbf{sel}\\mathcal{B}\\cdot(\\mathbf{freeIn}-\\mathcal{B}) + \\mathcal{B} \\\\ \\mathcal{C'} &amp;= \\mathbf{sel}\\mathcal{C}\\cdot(\\mathbf{freeIn}-\\mathcal{C}) + \\mathcal{C} \\\\ \\mathcal{D'} &amp;= \\mathbf{sel}\\mathcal{D}\\cdot(\\mathbf{freeIn}-\\mathcal{D}) + \\mathcal{D} \\\\ \\mathcal{E'} &amp;= \\mathbf{sel}\\mathcal{E}\\cdot(\\mathbf{freeIn}-\\mathcal{E}) + \\mathcal{E} \\\\ 0 &amp;= [ \\mathcal{A} \\cdot \\mathcal{B} + \\mathcal{C} - (2^{32} \\mathcal{D} + \\mathcal{E}) ] \\cdot \\mathbf{latch} \\\\ \\mathbf{freeIn} &amp;\\subset byte4\\end{aligned}\\] <p>Note that we only have to check that \\(\\mathbf{freeIn} \\subset byte4\\) because \\(\\mathcal{A}, \\mathcal{B}, \\mathcal{C}, \\mathcal{D}, \\mathcal{E}\\) will only take the \\(\\mathbf{freeIn}\\) values. The following figure illustrates the design of our arithmetic machine:</p> <p></p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Modular-Design/#extending-our-main-state-machine","title":"Extending our Main State Machine","text":"<p>Taking our main state machine as reference, we extend it to 5 registries and add a flag called arith to connect it to the arithmetic state machine. This allows us to check arithmetic operations between our resgistries whenever arith flag is setted to \\(1\\). The overall design is the following one:</p> <p></p> <p>The following figure exemplifies how we can connect both machines. The main point is that, when the arith flag is set to \\(1\\), we need to ensure that the registries are present in the our arithmetic table when latch is \\(1\\), i.e, the arithmetic constraint is fullfiled. Hence, we need to ensure the following inclusion:</p> <p></p> \\[[arith \\cdot A , arith \\cdot B , arith \\cdot C , arith \\cdot D, arith \\cdot op] \\subset [latch \\cdot \\mathcal{A} , latch \\cdot \\mathcal{B} , latch \\cdot \\mathcal{C} , latch \\cdot \\mathcal{D} , latch \\cdot \\mathcal{E}]\\] <p>Notice that we use op because it contains the value of the E registry in the current tick.</p> <p>As we can see in the next figure, we use Plookup as a bus to connect our main state machine to the other specific state machines: </p> <p></p> <p>This allows us to design in a modular way a virtual state machine that can be verified with zero knowledge technology.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/","title":"Simple State Machine","text":"<p>Next we show the arithmetization process of a more complex but yet simple state machine. Unlike the Fibonacci state machine, our simple state machine transitions from one state to the next in response to certain external instructions. See Figure 1 below, for such a state machine, with registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\), and a state \\(\\big(\\texttt{A}^{\\texttt{i}},\\texttt{B}^{\\texttt{i}}\\big)\\) that changes to another state \\(\\big(\\texttt{A}^{\\texttt{i+2}},\\texttt{B}^{\\texttt{i+2}}\\big)\\) in accordance to two instructions, \\(\\texttt{Instruction}^{\\texttt{i}}\\) and \\(\\texttt{Instruction}^{\\texttt{i+1}}\\).</p> <p></p>   Figure 1: A State Machine Receiving Instructions  <p>In the context of the zkProver, these instructions are written as zk-Assembly (zkASM) codes, and stored in a ROM in JSON-format.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#state-machine-instructions","title":"State Machine Instructions","text":"<p>Suppose the above simple state machine receives an input, together with the following execution instruction, \\(\\texttt{Instruction}^{\\texttt{1}}\\), written in Assembly.</p>  Table 1: Instruction^1 written in zk-Assembly  \\[\\begin{array}{|l|c|} \\hline \\texttt{ } &amp; \\texttt{Instruction}^{\\texttt{1}} \\\\ \\hline \\texttt{line 1} &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A}\\\\ \\hline \\texttt{line 2} &amp; \\mathtt{3 =&gt; B} \\\\ \\hline \\texttt{line 3} &amp; \\mathtt{:ADD} \\\\ \\hline \\texttt{line 4} &amp; \\mathtt{0 =&gt; A,B} \\\\ \\hline \\end{array}\\] <p>In accordance with each line of \\(\\texttt{Instruction}^{\\texttt{1}}\\), the state machine executor must;</p> <ul> <li>\\(\\texttt{line 1}\\): Get a free input value and move it into register \\(\\texttt{A}\\).</li> <li>\\(\\texttt{line 2}\\): Move the value \\(\\mathtt{3}\\) into register \\(\\mathtt{B}\\).</li> <li>\\(\\texttt{line 3}\\): Compute the sum of registry values \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\), and save the output into register \\(\\mathtt{A}\\).</li> <li>\\(\\texttt{line 4}\\): Set the registers \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\) to the value \\(\\mathtt{0}\\).</li> </ul> <p>For a free input value of \\(7\\), the corresponding state transitions can be recorded in a table as follows;</p>  Table 2: Record of all State Changes  \\[\\begin{array}{|l|c|c|c|c|c|c|} \\hline \\texttt{ } &amp; \\texttt{Instruction}^{\\texttt{1}} &amp; \\mathtt{free} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} \\\\ \\hline \\texttt{line 1} &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A} &amp; 7 &amp; 0 &amp; 7 &amp; 0 &amp; 0 \\\\ \\hline \\texttt{line 2} &amp; \\mathtt{3 =&gt; B} &amp; 0 &amp; 7 &amp; 7 &amp; 0 &amp; 3 \\\\ \\hline \\texttt{line 3} &amp; \\mathtt{:ADD} &amp; 0 &amp; 7 &amp; 10 &amp; 3 &amp; 3 \\\\ \\hline \\texttt{line 4} &amp; \\mathtt{0 =&gt; A,B} &amp; 0 &amp; 10 &amp; 0 &amp; 3 &amp; 0 \\\\ \\hline \\end{array}\\] <p>Note that \\(\\mathtt{A'}\\) and \\(\\mathtt{B'}\\) denote the next state of the registers \\(\\mathtt{A}\\) and \\(\\mathtt{B}\\), respectively. </p> <p>Observe also that, each line of \\(\\texttt{Instruction}^{\\texttt{1}}\\) does not always affect all register values. Since every register is initialised to \\(\\mathtt{0}\\) at the start, the state transitions are such that,</p> <ul> <li>\\(\\texttt{line 1}\\) only affects two registers; \\(\\mathtt{free}\\) and \\(\\mathtt{A'}\\).</li> <li>\\(\\texttt{line 2}\\) affects the register \\(\\mathtt{B'}\\) alone. Any other state change is due to the rules and the logic of the state machine (i.e., changes in registers; \\(\\mathtt{free}\\) and \\(\\mathtt{A}\\)).</li> <li>\\(\\texttt{line 3}\\) affects the register \\(\\mathtt{A'}\\) alone. Again, the state change in register \\(\\mathtt{B}\\) is due to the state machine's rules and logic.</li> <li>\\(\\texttt{line 4}\\) affects only two registers; \\(\\mathtt{A'}\\) and \\(\\mathtt{B'}\\). The state change in register \\(\\mathtt{A}\\) is also due to the rules and the logic of the state machine.</li> </ul>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#computational-trace","title":"Computational Trace","text":"<p>Recall that the intention with developing these state machines is not only to carry out computations, but to also ensure that correctness of these computations is verifiable. In addition, verification must be achievable even by users with modest computer power. That said, keeping record of computations, as seen in Table 2 above, is not preferable for verification purposes, because the registry values can be very large for some state machines. And thus, defeating the ultimate purpose and aim of our rollup.</p> <p>One therefore needs a way to keep track of all the computations and their correct execution, without requiring excessive memory. This is achieved by utilising the computational trace.</p> <p>For our verification purposes, the computational trace does not capture the actual state values of each state transition, but uses selectors and setters to keep record of whether registry values have been altered (during each state transition) in a way that tallies with the received instructions.</p> <p>Like switches that can either be ON or OFF, selectors and setters can also be either \\(\\mathtt{1}\\) or \\(\\mathtt{0}\\).</p> <p>Rule for the \\(\\texttt{inFree}\\) selector: Record \\(\\texttt{inFree}\\) as \\(\\mathtt{1}\\) only if the value of the register \\(\\texttt{free}\\) is non-zero.</p> <p>Rule for selectors \\(\\{\\texttt{setX}\\}\\): Each selector \\(\\texttt{setX}\\) is recorded;</p> <ul> <li>As the value \\(\\mathtt{1}\\), if the value of the corresponding registry \\(\\texttt{X}\\) was involved in (or contributed to) the computation,</li> <li>Otherwise, \\(\\texttt{selX}\\) is recorded as the value \\(\\mathtt{0}\\).</li> </ul> <p>Rule for setters \\(\\{\\texttt{setY}\\}\\): Each setter \\(\\texttt{setY}\\) is recorded;</p> <ul> <li>As the value \\(\\mathtt{1}\\), if the corresponding registry value \\(\\texttt{Y}\\) was altered by the instruction,</li> <li>Or, as the value \\(\\mathtt{0}\\), otherwise.</li> </ul> <p>The computational trace therefore consists mostly of bits, instead of large registry values. </p> <p>In the zkEVM context, the computational trace is stored as a lookup table in the ROM of the relevant state machine.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#example-computational-trace","title":"Example (Computational Trace)","text":"<p>Take as an example, \\(\\texttt{Instruction}^{\\texttt{1}}\\) above. Set selectors \\(\\texttt{selA}\\), \\(\\texttt{selB}\\) and \\(\\texttt{inFree}\\) for the registers \\(\\texttt{A}\\), \\(\\texttt{B}\\) and \\(\\texttt{free}\\), respectively. And, setters \\(\\texttt{setA}\\) and \\(\\texttt{setB}\\) for the registers \\(\\mathtt{A'}\\) and \\(\\mathtt{B'}\\), respectively. </p> <p>As discussed above;</p> <ul> <li>The register values, \\(\\mathtt{free}\\) and \\(\\mathtt{A'}\\), were changed in \\(\\texttt{line 1}\\). Therefore, only selector \\(\\texttt{inFree}\\) and setter \\(\\texttt{setA}\\) are recorded as \\(\\mathtt{1}\\).</li> <li>The register values  \\(\\mathtt{B'}\\), \\(\\mathtt{free}\\) and \\(\\mathtt{A}\\) were changed in \\(\\texttt{line 2}\\). But, only setter \\(\\texttt{setB}\\) is recorded as \\(\\mathtt{1}\\) because it is the only change the instruction effected.</li> <li>The register values \\(\\mathtt{A'}\\) and \\(\\mathtt{B}\\) were changed in \\(\\texttt{line 3}\\). So, setter \\(\\texttt{setA}\\) is recorded as \\(\\mathtt{1}\\). But since register values \\(\\texttt{A}\\) and \\(\\texttt{B}\\) were involved in the computation in \\(\\texttt{line 3}\\), they are also recorded as \\(\\mathtt{1}\\). </li> <li>The register values  \\(\\mathtt{A'}\\), \\(\\mathtt{B'}\\) and \\(\\mathtt{A}\\) were changed in \\(\\texttt{line 4}\\). Consequently, only setters \\(\\texttt{setA}\\) and \\(\\texttt{setB}\\) are recorded as \\(\\mathtt{1}\\).</li> </ul> <p>The computational trace after executing \\(\\texttt{Instruction}^{\\texttt{1}}\\) is as reflected in Table 3 below.</p>  Table 3: Computational Trace for Instruction^1  \\[\\begin{array}{|l|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\texttt{ } &amp; \\texttt{Instruction}^{\\texttt{1}} &amp; \\mathtt{free} &amp; \\texttt{setB} &amp; \\texttt{setA} &amp; \\texttt{inFree} &amp; \\texttt{selB} &amp; \\texttt{selA} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} \\\\ \\hline \\texttt{line 1} &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A} &amp; 7 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 7 &amp; 0 &amp; 0 \\\\ \\hline \\texttt{line 2} &amp; \\mathtt{3 =&gt; B} &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 7 &amp; 7 &amp; 0 &amp; 3 \\\\ \\hline \\texttt{line 3} &amp; \\mathtt{:ADD} &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 7 &amp; 10 &amp; 3 &amp; 3 \\\\ \\hline \\texttt{line 4} &amp; \\mathtt{0 =&gt; A,B} &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 10 &amp; 0 &amp; 3 &amp; 0 \\\\ \\hline \\end{array}\\]"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#arithmetic-constraints","title":"Arithmetic Constraints","text":"<p>Next we create a proper set of arithmetic constraints required in proving correctness of execution. Similar to the Fibonacci SM, where each state had to conform to polynomial identities and each polynomial identity was nothing but an algebraic relation between two consecutive states, our executor SM also needs such algebraic relations. These algebraic relations are also called arithmetic constraints.</p> <p>In order to fully express the relations between the next values of registries \\(\\texttt{A}\\) and \\(\\texttt{B}\\) as a linear combination of the current registry values, auxiliary registers and selectors need to be added.</p> <p>This is shown in Figure 2 below, as an algebraic processor of sorts.</p> <p></p>  Figure 2: The State Machine as an Algebraic Processor <p>The notation used in Figure 2 is as follows,</p> <p>a)  \\(\\mathtt{inFree}^i \\in \\{0,1\\}\\) indicates whether \\(\\mathtt{free^i}\\) is included in the linear combination or not.</p> <p>b)  \\(\\mathtt{setX}^i \\in \\{0,1\\}\\) indicates whether the result of the linear combination was moved into \\(\\mathtt{X^{i+1}}\\) or not.</p> <p>c) \\(\\mathtt{freeIn}^i\\) carries inputs freely chosen in order to execute the program.</p> <p>d) \\(\\mathtt{const}^i\\) carries fixed values moved into specified registers as per instructions received. $$ \\text{ } $$</p> <p>Introducing new auxiliary registers results in the following extended table. </p> \\[ \\begin{array}{|l|c|} \\hline \\texttt{ \\ } &amp; \\texttt{Instruction}^{\\texttt{1}}\\\\ \\hline \\texttt{line 1} &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A}\\\\\\hline \\texttt{line 2} &amp; \\mathtt{3 =&gt; B}\\\\\\hline \\texttt{line 3} &amp; \\mathtt{:ADD}\\\\\\hline \\texttt{line 4} &amp; \\mathtt{0 =&gt; A,B}\\\\\\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|c|c|} \\hline \\texttt{free} &amp; \\texttt{const} &amp; \\texttt{setB} &amp; \\texttt{setA} &amp; \\texttt{inFree} &amp; \\texttt{selB} &amp; \\texttt{selA}\\\\\\hline 7 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0\\\\\\hline 0 &amp; 3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\\\hline 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\\\\\hline 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\\\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|} \\hline \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'}\\\\\\hline 0 &amp; 7 &amp; 0 &amp; 0\\\\\\hline 7 &amp; 7 &amp; 0 &amp; 3\\\\\\hline 7 &amp; 10 &amp; 3 &amp; 3\\\\\\hline 10 &amp; 0 &amp; 3 &amp; 0\\\\\\hline \\end{array} \\] <p>Henceforth, the relations between the states of the registries can be expressed algebraically as follows: </p> \\[\\begin{aligned} &amp;\\mathtt{A}^{i+1} = \\mathtt{A}^i + \\mathtt{setA}^i \\cdot (\\mathtt{selA}^i \\cdot \\mathtt{A}^i + \\mathtt{selB}^i \\cdot \\mathtt{B^i} + \\mathtt{inFree}^i \\cdot \\mathtt{free}^i + \\mathtt{const}^i - \\mathtt{A}^i), \\\\ &amp;\\mathtt{B}^{i+1} = \\mathtt{B}^i + \\mathtt{setB}^i \\cdot (\\mathtt{selA}^i \\cdot \\mathtt{A}^i + \\mathtt{selB}^i \\cdot \\mathtt{B}^i + \\mathtt{inFree}^i \\cdot \\mathtt{free}^i + \\mathtt{const}^i - \\mathtt{B}^i).\\\\ \\end{aligned}\\]"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#polynomial-constraints","title":"Polynomial Constraints","text":"<p>Let's represent the states of these registries for four steps as polynomials \\(\\mathtt{A}, \\mathtt{B} \\in \\mathbb{Z}_p[x]\\) evaluated on the subgroup \\(H = \\{\\omega, \\omega^2, \\omega^3, \\omega^4 = 1\\}\\), in order to produce a cyclic relation:</p> \\[\\begin{aligned} &amp;\\mathtt{A}(x\\omega) = \\mathtt{A}(x) + \\mathtt{setA}(x) \\cdot (\\mathtt{selA}(x) \\cdot \\mathtt{A}(x) + \\mathtt{selB}(x) \\cdot \\mathtt{B}(x) + \\mathtt{inFree}(x) \\cdot \\mathtt{free}(x) + \\mathtt{const}(x) - \\mathtt{A}(x)), \\\\ &amp;\\mathtt{B}(x\\omega) = \\mathtt{B}(x) + \\mathtt{setB}(x) \\cdot (\\mathtt{selA}(x) \\cdot \\mathtt{A}(x) + \\mathtt{selB}(x) \\cdot \\mathtt{B}(x) + \\mathtt{inFree}(x) \\cdot \\mathtt{free}(x) + \\mathtt{const}(x) - \\mathtt{B}(x)). \\end{aligned}\\] <p>Observe that the program is completely described by the constant (and public) polynomials \\(\\mathtt{selA(x)}\\), \\(\\mathtt{selB(x)}\\), \\(\\mathtt{setA(x)}\\), \\(\\mathtt{setB(x)}\\), \\(\\mathtt{inFree(x)}\\) and \\(\\mathtt{const(x)}\\).</p> <p>The polynomial \\(\\mathtt{free}(x)\\) can be public or committed and by changing this polynomial, we can proof different executions for different initial conditions for the same \"program\".</p> <p>In our previous program, we can provide a result of the execution by giving \\(A(\\omega^4)\\).</p> <p>Notice that the last instruction resets the states' values and \"glues\" the last instruction with the first one, achieving a cycle.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#programs-with-conditional-jumps","title":"Programs with Conditional Jumps","text":"<p>We are going to add the instruction \\(\\mathtt{JMPZ}\\) to our assembly. \\(\\mathtt{JMPZ}\\) jumps to a specified position in the program if the preceding state of the register \\(\\mathtt{A}\\) is zero. </p> <p>In the next program, \\(\\mathtt{JMPZ}\\) will jump to position \\(5\\) if the previous result of \\(\\mathtt{A + B}\\) (which is actually stored in the register \\(\\mathtt{A}\\)) is \\(0\\): </p> \\[ \\begin{array}{|c|l|} \\hline \\textbf{Position} &amp; \\texttt{Instruction} \\\\ \\hline 0 &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A}  \\\\ \\hline 1 &amp; \\mathtt{-3 =&gt; B} \\\\ \\hline 2 &amp; \\mathtt{:ADD} \\\\ \\hline 3 &amp; \\mathtt{:JMPZ(5)} \\\\ \\hline  4 &amp; \\mathtt{:ADD} \\\\ \\hline 5 &amp; \\mathtt{0 =&gt; A, B} \\\\ \\hline \\end{array} \\] <p>Note: We will discuss later on how to introduce negative values into our program.</p> <p>In programs with conditional jumps, our previous model will not work, because the flow of the program may vary depending on the values of the input.</p> <p>As it can be seen next, with conditional jumps, the length of the execution trace is not constant (it depends on the free input):</p> \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{Instruction} &amp; \\mathtt{free} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} \\\\ \\hline \\mathtt{\\$\\{getInput()\\} =&gt; A} &amp; 7 &amp; 0 &amp; 7 &amp; 0 &amp; 0 \\\\ \\hline \\mathtt{-3 =&gt; B} &amp; 0 &amp; 7 &amp; 7 &amp; 0 &amp; -3 \\\\ \\hline \\mathtt{:ADD} &amp; 0 &amp; 7 &amp; 4 &amp; -3 &amp; -3 \\\\ \\hline \\mathtt{:JMPZ(5)} &amp; 0 &amp; 4 &amp; 4 &amp; -3 &amp; -3 \\\\ \\hline \\mathtt{:ADD} &amp; 0 &amp; 4 &amp; 1 &amp; -3 &amp; -3 \\\\ \\hline \\mathtt{0 =&gt; A, B} &amp; 0 &amp; 1 &amp; 0 &amp; -3 &amp; 0 \\\\ \\hline \\end{array} \\] \\[ \\begin{array}{|l|c|c|c|c|c|} \\hline \\texttt{Instruction} &amp; \\mathtt{free} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} \\\\ \\hline \\mathtt{\\$\\{getInput()\\} =&gt; A} &amp; 3 &amp; 0 &amp; 3 &amp; 0 &amp; 0\\\\ \\hline \\mathtt{-3 =&gt; B} &amp; 0 &amp; 3 &amp; 3 &amp; 0 &amp; -3\\\\ \\hline \\mathtt{:ADD} &amp; 0 &amp; 3 &amp; 0 &amp; -3 &amp; -3\\\\ \\hline \\mathtt{:JMPZ(5)} &amp; 0 &amp; 0 &amp; 0 &amp; -3 &amp; -3\\\\ \\hline \\mathtt{0 =&gt; A, B} &amp;  0 &amp; 0 &amp; 0 &amp; -3 &amp; 0\\\\ \\hline \\end{array} \\] <p>The first execution is done in 6 steps, while the second is in 5 steps.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#managing-conditional-jumps","title":"Managing Conditional Jumps","text":"<p>Now, let us introduce a new model to manage a program that contains conditional jumps.</p> <p></p> <p>To do this, we need to add the Program Counter (PC). The \\(\\mathtt{PC}\\) is a special registry that contains the position of the instruction in the program being executed.</p> <p>We use \\(\\texttt{op}^i\\) as a shorthand for the linear combination of our state machine to simplify the forthcoming constraints: $$ \\mathtt{op}^i := \\mathtt{setA}^i \\cdot \\mathtt{A}^i + \\mathtt{setB}^i \\cdot \\mathtt{B}^i + \\mathtt{inFree}^i \\cdot \\mathtt{free}^i + \\mathtt{const}^i. $$</p> <p></p> <p>The \\(\\mathtt{JMPZ}\\) instruction will jump to the instruction \\(\\texttt{addr}^i\\) (specified by the \\(\\mathtt{JMPZ}\\) instruction) if \\(\\texttt{op}^i\\) is zero. Let us first develop some procedure to check if our operation is or not zero in \\(\\mathbb{Z}_p\\): </p> <p>To check that a number in the field \\(\\mathbb{Z}_p\\) is zero, we use the fact that a number \\(a\\) has a multiplicative inverse \\(a^{-1}\\) if and only if \\(a \\neq 0\\). </p> <p>Using this fact, we use the following definition and constraint to do the \\(\\mathtt{isZero}\\) check:</p> \\[\\begin{aligned} &amp;\\mathtt{isZero}^i := 1 - \\mathtt{op}^i \\cdot (\\mathtt{op}^i)^{-1}, \\\\ &amp;\\mathtt{isZero}^i \\cdot \\mathtt{op}^i = 0. \\end{aligned}\\] <p>We can proof that the previous equations describe the desired check by case examination where \\(a \\neq 0\\) and \\(\\alpha, \\beta \\in \\mathbb{Z}_p\\):</p> <p>\\(\\mathtt{op}^i = 0,~(\\mathtt{op}^i)^{-1} = \\alpha,~\\mathtt{isZero}^i = 1\\) passes the definition and constraint,</p> <p>\\(\\mathtt{op}^i = a,~(\\mathtt{op}^i)^{-1} = a^{-1},~\\mathtt{isZero}^i = 0\\) passes the definition and constraint.</p> <p>\\(\\mathtt{op}^i = 0,~(\\mathtt{op}^i)^{-1} = \\alpha,~\\mathtt{isZero}^i \\neq 1\\) does not pass the definition of \\(\\mathtt{isZero}\\).</p> <p>\\(\\mathtt{op}^i = a,~(\\mathtt{op}^i)^{-1} = \\beta,~\\mathtt{isZero}^i \\neq 0\\) does not pass the definition and constraint,  either you consider \\(\\beta = 0\\), \\(\\beta = a^{-1}\\) or \\(\\beta \\neq a^{-1}\\).</p> <p>We can mix the two equations into just one constraint: $$ \\mathtt{isZero}^i \\cdot \\mathtt{op}^i = 0,~~\\mathtt{isZero}^i = 1 - \\mathtt{op}^i \\cdot (\\mathtt{op}^i)^{-1}~~\\rightarrow~~(1 - \\mathtt{op}^i \\cdot (\\mathtt{op}^i)^{-1}) \\cdot \\mathtt{op}^i = 0. $$</p> <p>Let us introduce the following machinery to our setup in order to introduce jumps:</p> <p></p> <p>We add a selector \\(\\texttt{jmpz}^i \\in \\{0,1\\}\\) to our state machine to code the \\(\\mathtt{JMPZ}\\) instruction and express the behaviour of the PC. Then, the set of constraints is the following:</p> \\[\\begin{aligned} &amp;\\mathtt{op}^i := \\mathtt{setA}^i \\cdot \\mathtt{A}^i + \\mathtt{setB}^i \\cdot \\mathtt{B}^i + \\mathtt{inFree}^i \\cdot \\mathtt{free}^i + \\mathtt{const}^i, \\\\ &amp;\\mathtt{PC}^{i+1} = \\mathtt{PC}^i + 1 + \\mathtt{jmpz}^i \\cdot (1 - \\mathtt{op}^i \\cdot (\\mathtt{op}^i)^{-1}) \\cdot (\\mathtt{addr}^i  - \\mathtt{PC}^i - 1),\\\\ &amp;(1 - \\mathtt{op}^i \\cdot (\\mathtt{op}^i)^{-1}) \\cdot \\mathtt{op}^i = 0. \\end{aligned}\\] <p>Observe that:</p> <ol> <li>If \\(\\mathtt{op}^i \\neq 0\\), then \\((1 - \\mathtt{op}^i \\cdot (\\mathtt{op}^i)^{-1}) = 0\\) and hence \\(\\mathtt{PC}^{i+1} = \\mathtt{PC}^i + 1\\); </li> <li>If \\(\\mathtt{op}^i = 0\\), then \\((1 - \\mathtt{op}^i \\cdot (\\mathtt{op}^i)^{-1}) = 1\\) and hence \\(\\mathtt{PC}^{i+1} = \\mathtt{PC}^i + 1 + \\mathtt{addr}^i  - \\mathtt{PC}^i - 1 = \\mathtt{addr}^i\\).</li> </ol> <p>This is exactly the wanted behaviour.</p> <p>Next, we show the execution traces for the free inputs 7 and 3 respectively:</p> \\[ \\scriptsize \\begin{array}{|l|} \\hline \\texttt{Instruction} \\\\ \\hline \\mathtt{\\$\\{getInput()\\} =&gt; A} \\\\ \\hline \\mathtt{-3 =&gt; B} \\\\ \\hline \\mathtt{:ADD} \\\\ \\hline \\mathtt{:JMPZ(5)} \\\\ \\hline \\mathtt{:ADD} \\\\ \\hline \\mathtt{0 =&gt; A, B, PC} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\texttt{free} &amp; \\textbf{const} &amp; \\texttt{addr} &amp; \\texttt{jmpz} &amp; \\texttt{setB} &amp; \\texttt{setA} &amp; \\texttt{inFree} &amp;  \\texttt{selB} &amp; \\texttt{selA} &amp; \\texttt{op} &amp; \\texttt{invOp} \\\\ \\hline 7 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 7 &amp; 7^{-1} \\\\ \\hline 0 &amp; -3 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -3 &amp; (-3)^{-1} \\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; \\mathbf{\\color{blue!75!black} 4} &amp; \\mathbf{\\color{blue!75!black} 4^{-1}} \\\\ \\hline 0 &amp; 0 &amp; 5 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|} \\hline \\mathtt{PC} &amp; \\mathtt{PC'} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} \\\\ \\hline 0 &amp; 1 &amp; 0 &amp; 7 &amp; 0 &amp; 0\\\\ \\hline 1 &amp; 2 &amp; 7 &amp; 7 &amp; 0 &amp; -3\\\\ \\hline 2 &amp; 3 &amp; 7 &amp; 4 &amp; -3 &amp; -3\\\\ \\hline 3 &amp; 4 &amp; 4 &amp; 4 &amp; -3 &amp; -3\\\\ \\hline 4 &amp; 5 &amp; 4 &amp; 1 &amp; -3 &amp; -3\\\\ \\hline 5 &amp; 0 &amp; 1 &amp; 0 &amp; -3 &amp; 0\\\\ \\hline \\end{array} \\] \\[ \\scriptsize \\begin{array}{|l|} \\hline \\texttt{Instruction} \\\\ \\hline \\mathtt{\\$\\{getInput()\\} =&gt; A} \\\\ \\hline \\mathtt{-3 =&gt; B} \\\\ \\hline \\mathtt{:ADD} \\\\ \\hline \\mathtt{:JMPZ(5)} \\\\ \\hline \\mathtt{0 =&gt; A, B} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\texttt{free} &amp; \\texttt{const} &amp; \\texttt{addr} &amp; \\texttt{jmpz} &amp; \\texttt{setB} &amp; \\texttt{setA} &amp; \\texttt{inFree} &amp;  \\texttt{selB} &amp; \\texttt{selA} &amp; \\texttt{op} &amp; \\texttt{invOp} \\\\ \\hline 3 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 3 &amp; 3^{-1} \\\\ \\hline 0 &amp; -3 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -3 &amp; (-3)^{-1} \\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; \\mathbf{\\color{blue!75!black} 0} &amp; \\mathbf{\\color{blue!75!black} \\alpha} \\\\ \\hline 0 &amp; 0 &amp; 5 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|} \\hline \\mathtt{PC} &amp; \\mathtt{PC'} &amp; \\mathtt{A} &amp; \\mathtt{A'} &amp; \\mathtt{B} &amp; \\mathtt{B'} \\\\ \\hline 0 &amp; 1 &amp; 0 &amp; 3 &amp; 0 &amp; 0\\\\ \\hline 1 &amp; 2 &amp; 3 &amp; 3 &amp; 0 &amp; -3\\\\ \\hline 2 &amp; 3 &amp; 3 &amp; 0 &amp; -3 &amp; -3\\\\ \\hline 3 &amp; 5 &amp; 3 &amp; 0 &amp; -3 &amp; -3\\\\ \\hline 5 &amp; 0 &amp; 0 &amp; 0 &amp; -3 &amp; 0\\\\ \\hline \\end{array} \\] <p>Note that we use \\(\\mathtt{invOp}\\) for the column containing the inverses of \\(\\mathtt{op}\\).</p> <p>Note also that the \\(\\mathtt{PC}\\) turns to be an important registry when jumps are included in the set of possible instructions because jumps can modify the sequence of instructions that is executed also known as \"the trace\".</p> <p>Now, our polynomials are definitely not preprocessed, this is because the values of the table will not only depend on the program, but also on the free input values. Hence, we need to ensure that we are verifying the correct program. </p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#proving-the-execution-of-the-correct-program","title":"Proving the Execution of the \"Correct Program\"","text":"<p>Up to now, we can prove that each instruction is correctly executed, but, how do we prove that we are executing the correct set of instructions, that is to say, that we are executing the \"correct program\"? The solution seems obvious: Check that every executed instruction is some instruction in the program, but how do we do this in a succinct manner?</p> <p>To do so, we have to provide a codification for each instruction and then we will check that the codification of the execution's instructions is included in the codification of the program's instructions.</p> <p>Let's begin showing how to encode the constant values of our instructions. As a particular example, consider that we want to use signed integers of 4 bits (in the real machine, we will use an analogous 32 bits codification). The four bit codification is shown next: </p> \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline -8 &amp; -7 &amp; -6 &amp; ... &amp; -2 &amp; -1 &amp; 0 &amp; 1 &amp; 2 &amp; ... &amp; 6 &amp; 7 &amp; 8 \\\\ \\hline 1000 &amp; 1001 &amp; 1010 &amp; ... &amp; 1110 &amp; 1111 &amp; 0000 &amp; 0001 &amp; 0010 &amp; ... &amp; 0110 &amp; 0111 &amp; 1000 \\\\ \\hline \\end{array}\\] <p>Notice that with this arithmetic \\(8=-8\\), which is a weird case that we discard, using only values from -7 to 7. Then, we encode these values in elements of the field \\(\\mathbb{Z}_p\\):</p> \\[\\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|} \\hline -7 &amp; -6 &amp; ... &amp; -2 &amp; -1 &amp; 0 &amp; 1 &amp; 2 &amp; ...&amp; 6 &amp; 7 \\\\ \\hline p-7 &amp; p-6 &amp; ... &amp; p-2 &amp; p-1 &amp; 0 &amp; 1 &amp; 2 &amp; ...&amp; 6 &amp; 7  \\\\ \\hline \\end{array}\\] <p>So, we have to enforce that \\(\\mathsf{const}(x) \\in \\{p-7, p-6, ..., p-2, p-1, 0,1,2, ..., 6, 7\\}\\).</p> <p>We enforce the previous condition with the following equivalent inclusion: </p> \\[\\mathsf{const}(x) + 7 \\in \\{0,1,2,...,14\\}\\] <p>Hence, we will use \\(\\mathsf{const}(x) + 7\\) in base \\(2\\) instead of \\(\\mathsf{const}(x)\\) to encode our instruction, just to avoid the sum. </p> <p>Let's now explain how to encode every distinct instruction to be executed by the program: </p> \\[ \\scriptsize \\begin{array}{|c|l|} \\hline \\mathbf{Instruction} \\\\ \\hline \\mathtt{\\$\\{getInput()\\} =&gt; A} \\\\ \\hline \\mathtt{-3 =&gt; B} \\\\ \\hline \\mathtt{:ADD} \\\\ \\hline \\mathtt{:JMPZ(5)} \\\\ \\hline \\mathtt{:ADD} \\\\ \\hline \\mathtt{0 =&gt; A, B, PC} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|} \\hline \\mathbf{\\color{blue!75!black} \\texttt{const+7}} &amp; \\texttt{addr} &amp; \\texttt{jmpz} &amp; \\texttt{setB} &amp; \\texttt{setA} &amp; \\texttt{inFree} &amp; \\texttt{selB} &amp; \\texttt{selA} &amp; \\texttt{instruction} \\\\ \\hline \\mathbf{\\color{blue!75!black} 7} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0111.0000.001100 \\\\ \\hline \\mathbf{\\color{blue!75!black} 4} &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0100.0000.010000 \\\\ \\hline \\mathbf{\\color{blue!75!black} 7} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0111.0000.001011\\\\ \\hline \\mathbf{\\color{blue!75!black} 7} &amp; 5 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0111.0101.100000 \\\\ \\hline \\mathbf{\\color{blue!75!black} 7} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0111.0000.001011 \\\\ \\hline \\mathbf{\\color{blue!75!black} 7} &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0111.0000.111000 \\\\ \\hline \\end{array} \\] <p>Observe that we have codified the instruction using the following rule: $$ \\texttt{instruction}^i := 2^{10}\\cdot(\\texttt{const}^i + 7) + 2^6\\cdot \\texttt{addr}^i + 2^5\\cdot \\texttt{jmpz}^i + 2^4 \\cdot \\texttt{setB}^i + 2^3 \\cdot \\texttt{setA}^i + 2^2 \\cdot \\texttt{inFree}^i + 2 \\cdot \\texttt{selB}^i + \\texttt{selA}^i. $$</p> <p>That is, we are codifying it as the concatenated base \\(2\\) integer of all the values (in the order of appearance on the table).</p> <p>Note that additionally, we will need to check that the selectors are binary and that \\(\\texttt{addr}\\) is composed of \\(4\\) bits, i.e., \\(\\texttt{addr}^i \\in \\{0, 1, \\dots, 15\\}\\)</p> <p>Also observe that, when \\(\\texttt{const}^i+7 = 7\\), this means that \\(\\texttt{const}^i = 0\\), so the constant is not used in those cases. </p> <p>Now, to prove the program, every instruction will be uniquely identified by its code and position in the program (we also use 4 bits in this example for the position).</p> <p>We define the \\(\\mathtt{ROM}\\) of the program as the sum between every instruction and the position in which it is defined: $$ \\texttt{ROM}^i := 2^{14}  \\cdot \\texttt{position}^i + \\texttt{instruction}^i. $$</p> <p>Observe that the \\(\\mathtt{ROM}\\) uniquely identifies the program we want to verify and it is independent of the different possible executions. </p> <p>The resulting \\(\\mathtt{ROM}\\) of our program is the following:</p> \\[ \\begin{array}{|c|c|} \\hline \\texttt{position} &amp; \\mathbf{Instruction} \\\\ \\hline 0 &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A} \\\\ \\hline 1 &amp; \\mathtt{-3 =&gt; B} \\\\ \\hline 2 &amp; \\mathtt{:ADD} \\\\ \\hline 3 &amp; \\mathtt{:JMPZ(5)} \\\\ \\hline 4 &amp; \\mathtt{:ADD} \\\\ \\hline 5 &amp; \\mathtt{0 =&gt; A, B, PC} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|} \\hline \\texttt{ROM} \\\\ \\hline 0111.0000.001100 \\\\ \\hline 0100.0000.010000 \\\\ \\hline 0111.0000.001011\\\\ \\hline 0111.0101.100000 \\\\ \\hline 0111.0000.001011 \\\\ \\hline 0111.0000.111000 \\\\ \\hline \\end{array} \\] <p>We will encode the program trace using the PC:</p> \\[ \\scriptsize \\begin{array}{|c|c|c|c|c|c|} \\hline \\mathtt{PC} \\\\ \\hline 0 \\\\ \\hline 1 \\\\ \\hline 2 \\\\ \\hline 3 \\\\ \\hline 4 \\\\ \\hline 5 \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|} \\hline \\mathtt{position} &amp; \\mathbf{Instruction} \\\\ \\hline 0 &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A} \\\\ \\hline 1 &amp; \\mathtt{-3 =&gt; B} \\\\ \\hline 2 &amp; \\mathtt{:ADD} \\\\ \\hline 3 &amp; \\mathtt{:JMPZ(5)} \\\\ \\hline 4 &amp; \\mathtt{:ADD} \\\\ \\hline 5 &amp; \\mathtt{0 =&gt; A, B, PC} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|c|c|c|} \\hline \\texttt{const+7} &amp; \\texttt{addr} &amp; \\texttt{jmpz} &amp; \\texttt{setB} &amp; \\texttt{setA} &amp; \\texttt{inFree} &amp;  \\texttt{selB} &amp; \\texttt{selA} \\\\ \\hline 7 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ \\hline 4 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline 7 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\\\ \\hline 7 &amp; 5 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline 7 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\\\ \\hline 7 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|} \\hline \\mathtt{insTrace} \\\\ \\hline 0000.0111.0000.001100 \\\\ \\hline 0001.0100.0000.010000 \\\\ \\hline 0010.0111.0000.001011\\\\ \\hline 0011.0111.0101.100000 \\\\ \\hline 0100.0111.0000.001011 \\\\ \\hline 0101.0111.0000.111000 \\\\ \\hline \\end{array} \\] \\[ \\scriptsize \\begin{array}{|c|c|c|c|c|c|} \\hline \\mathtt{PC} \\\\ \\hline 0 \\\\ \\hline 1 \\\\ \\hline 2 \\\\ \\hline 3 \\\\ \\hline 5 \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|} \\hline \\mathtt{position} &amp; \\mathbf{Instruction} \\\\ \\hline 0 &amp; \\mathtt{\\$\\{getInput()\\} =&gt; A} \\\\ \\hline 1 &amp; \\mathtt{-3 =&gt; B} \\\\ \\hline 2 &amp; \\mathtt{:ADD} \\\\ \\hline 3 &amp; \\mathtt{:JMPZ(5)} \\\\ \\hline 4 &amp; \\mathtt{0 =&gt; A, B, PC} \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|c|c|c|} \\hline \\texttt{const+7} &amp; \\texttt{addr} &amp; \\texttt{jmpz} &amp; \\texttt{setB} &amp; \\texttt{setA} &amp; \\texttt{inFree} &amp;  \\texttt{selB} &amp; \\texttt{selA} \\\\ \\hline 7 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ \\hline 4 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline 7 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\\\ \\hline 7 &amp; 5 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline 7 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ \\hline \\end{array} \\hspace{0.1cm} \\begin{array}{|c|c|c|c|c|c|} \\hline \\mathtt{insTrace} \\\\ \\hline 0000.0111.0000.001100 \\\\ \\hline 0001.0100.0000.010000 \\\\ \\hline 0010.0111.0000.001011\\\\ \\hline 0011.0111.0101.100000 \\\\ \\hline 0101.0111.0000.111000 \\\\ \\hline \\end{array} \\] <p>Recall that our main question was: How do we actually check correctness in an efficient manner?</p> <p>We can achieve it with the Plookup protocol. So, to check that the correct program is being executed, we simply have to use Plookup to determine if:</p> \\[\\mathsf{insTrace(x)} \\subset \\mathsf{ROM(x)}\\] <p>In words, the trace being executed is an execution of the actual program if the instruction trace is contained in the ROM of the program.</p>"},{"location":"zkEVM/zkProver/Verifiable-Computations/Simple-State-Machine/#identities-to-prove-an-execution-trace","title":"Identities to Prove an Execution Trace","text":"<p>As a summary, we have seen that the following set of identities are used to define our program:</p> \\[\\begin{aligned} &amp;\\mathsf{A}(x\\omega) = \\mathsf{A}(x) + \\mathsf{setA}(x) \\cdot (\\mathsf{op}(x) - \\mathsf{A}(x)), \\\\ &amp;\\mathsf{B}(x\\omega) = \\mathsf{B}(x) + \\mathsf{setB}(x) \\cdot (\\mathsf{op}(x) - \\mathsf{B}(x)), \\\\ &amp;\\mathsf{PC}(x\\omega) = \\mathsf{PC}(x) + 1 + \\mathsf{jmpz}(x) \\cdot (1 - \\mathsf{op}(x) \\cdot \\mathsf{invOp}(x)) \\cdot (\\mathsf{addr}(x)  - \\mathsf{PC}(x) - 1), \\\\ &amp;(1 - \\mathsf{op}(x) \\cdot \\mathsf{invOp}(x)) \\cdot \\mathsf{op}(x) = 0. \\end{aligned}\\] <p>With the following definition: $$ \\mathsf{op}(x) := \\mathsf{selA}(x) \\cdot \\mathsf{A}(x) + \\mathsf{selB}(x) \\cdot \\mathsf{B}(x) + \\mathsf{inFree}(x) \\cdot \\mathsf{free}(x) + \\mathsf{const}(x). $$</p> <p>Moreover, we should add the following Plookup checks: </p> \\[\\begin{aligned} &amp;\\textsf{const}(x) + 7 \\subset \\{0,1, \\dots, 14\\},\\\\ &amp;\\mathsf{addr}(x) \\subset \\{0,1, \\dots, 15\\},\\\\ &amp;\\mathsf{position}(x) \\subset \\{0,1, \\dots, 15\\},\\\\ &amp;\\mathsf{PC}(x) \\subset \\{0,1, \\dots, 15\\},\\\\ &amp;\\textsf{insTrace}(x) \\subset \\textsf{ROM}(x). \\end{aligned}\\] <p>With the following definitions:</p> \\[\\begin{aligned} &amp;\\textsf{instruction}(x) := 2^{10}\\cdot(\\textsf{const}(x) + 7) + 2^6\\cdot \\textsf{addr}(x) + 2^5\\cdot \\textsf{jmpz}(x) + 2^4 \\cdot \\textsf{setB}(x) + \\\\  &amp;\\qquad \\qquad \\qquad \\quad~~2^3 \\cdot \\textsf{setA}(x) + 2^2 \\cdot \\textsf{inFree}(x) + 2 \\cdot \\textsf{selB}(x) + \\textsf{selA}(x),\\\\ &amp;\\textsf{ROM}(x) := 2^{14}  \\cdot \\textsf{position}(x) + \\textsf{instruction}(x), \\\\ &amp;\\textsf{insTrace}(x) := 2^{14}  \\cdot \\textsf{PC}(x) + \\textsf{instruction}(x). \\end{aligned}\\] <p>Finally, it should be checked that the whole set of selectors are, in fact, binary:</p> \\[\\begin{aligned} &amp;\\mathsf{selA}(x) \\cdot (\\mathsf{selA}(x) - 1) = 0, \\quad \\mathsf{setA}(x) \\cdot (\\mathsf{setA}(x) - 1) = 0, \\quad\\\\ &amp;\\mathsf{selB}(x) \\cdot (\\mathsf{selB}(x)- 1) = 0, \\quad \\mathsf{setB}(x) \\cdot (\\mathsf{setB}(x) - 1) = 0, \\quad\\\\ &amp;\\mathsf{inFree}(x) \\cdot (\\mathsf{inFree}(x) - 1) = 0, \\quad \\mathsf{jmpz}(x) \\cdot (\\mathsf{jmpz}(x) - 1) = 0. \\end{aligned}\\] <p>Regarding the polynomials, in this state machine:</p> <ol> <li> <p>We have to commit \\(\\textsf{inFree}(x), \\textsf{selA}(x), \\textsf{selB}(x), \\textsf{setA}(x), \\textsf{setB}(x)\\) \\(\\textsf{A}(x), \\textsf{B}(x), \\textsf{const}(x),\\) \\(\\textsf{jmpz}(x),\\) \\(\\textsf{invOp}(x)\\), \\(\\textsf{addr}(x)\\), \\(\\textsf{free}(x)\\), \\(\\textsf{position}(x)\\) and \\(\\textsf{PC}(x)\\).</p> </li> <li> <p>While the only constant (preprocessed) polynomial is \\(\\textsf{ROM}(x)\\).</p> </li> </ol>"}]}